<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>Google C++ Style Guide (Japanese)</title>
    <link rel="stylesheet" type="text/css" href="include/styleguide.ja.css">
    <script language="javascript" src="include/styleguide.ja.js"></script>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
    <style>
        /* 翻訳ポップアップ */
        span:hover {
            background-color: #FFC;
        }

        #tip_popup {
            position: absolute;
            border: 1px solid black;
            max-width: 50%;
            background-color: #EFF;
            padding: 8px;
            z-index: 100;
            left: -99999px;
        }

        span.src {
            display: none;
        }
    </style>
    <script language="javascript">
        // 翻訳ポップアップ
        $(document).ready(function () {
            $("body").append('<div id="tip_popup"></div>');
            var tip = $('#tip_popup');
            $("span").each(function () {
                if ($(this).attr("title")) {
                    $(this).attr("data-title", $(this).attr("title"));
                    $(this).removeAttr("title");
                    $(this).mousemove(function (m) { tip.html($(this).attr("data-title")); });
                    $(this).mousemove(function (m) { tip.css({ left: (m.pageX + 20) + "px", top: (m.pageY + 20) + "px" }); });
                    $(this).mouseout(function () { tip.css({ left: "-99999px" }); });
                }
                else if ($(this).children("span.src")) {
                    $(this).mousemove(function (m) { tip.html($(this).children("span.src").html()); });
                    $(this).mousemove(function (m) { tip.css({ left: (m.pageX + 20) + "px", top: (m.pageY + 20) + "px" }); });
                    $(this).mouseout(function () { tip.css({ left: "-99999px" }); });
                }

            });
        });
    </script>

    <link rel="shortcut icon" type="image/x-icon" href="https://www.google.com/favicon.ico" />
</head>
<body onload="initStyleGuide();">
    <div id="content">
        <h1><span title="Google C++ Style Guide">Google C++ スタイルガイド</span> 日本語訳</h1>
        <div>本ドキュメントは <a href="https://github.com/google/styleguide/">https://github.com/google/styleguide/</a> にて公開されているGoogle C++ Style Guideを日本語に訳したものです。</div>
        <div>commit <a href="https://github.com/google/styleguide/blob/db0a26320f3e930c6ea7225ed53539b4fb31310c/cppguide.html">db0a263  on 18 Nov</a> を底本としています。(訳文にマウスを重ねると原文が表示されます)</div>
        <div>オリジナルと同様<a href="https://creativecommons.org/licenses/by/3.0/">CC-By 3.0 License</a>で頒布します。</div>
        <div>誤訳の指摘・改善案は<a href="https://github.com/ttsuki/styleguide/issues">Issues</a> or <a href="https://github.com/ttsuki/styleguide/pulls">Pull Requests</a>までお願いします。</div>
        <div class="horizontal_toc" id="tocDiv"></div>

        <div class="main_body">

            <h2 class="ignoreLink" id="Background"><span title="Background">本ガイドの背景</span></h2>

            <p>
                <span title="C++ is one of the main development languages used by many of Google's open-source projects.">C++は、多くのGoogleのオープンソースプロジェクトで使われている主要言語のうちのひとつです。</span> <span title="As every C++ programmer knows, the language has many powerful features, but this power brings with it complexity, which in turn can make code more bug-prone and harder to read and maintain.">C++のプログラマなら誰でも知っているように、この言語はパワフルな機能がありますが、一方でこのパワフルさが複雑さを招き、バグを発生させやすくしたり、また可読性やメンテナンス性の妨げになったりしています。</span>
            </p>

            <p>
                <span title="The goal of this guide is to manage this complexity by describing in detail the dos and don'ts of writing C++ code.">本ガイドの目的は、C++のコードを書く際に、すべきこと、すべきでないことを詳しく説明することによって、この複雑性を管理下に置くことです。</span> <span title="These rules exist to keep the code base manageable while still allowing coders to use C++ language features productively.">
                    これらのルールは、プログラマがC++の言語機能を生産的に使用できるようにしたまま、コードベースを管理しやすくするために存在します。
                </span>
            </p>

            <p>
                <span title="Style, also known as readability, is what we call the conventions that govern our C++ code."><em>スタイル</em>とは、リーダビリティとしても知られ、私たちのC++コードを管理するための規約のことです。</span> <span title="The term Style is a bit of a misnomer, since these conventions cover far more than just source file formatting.">これらの規約は、単にソースファイルのフォーマットだけではなく、広い範囲を含むため<em>スタイル</em>という用語はちょっとふさわしくないかもしれません。</span>
            </p>

            <p>
                <span title="Most open-source projects developed by Google conform to the requirements in this guide.">Googleのオープンソースプロジェクトのほとんどが、本ガイドに則っています。</span>
            </p>





            <p><span title="Note that this guide is not a C++ tutorial: we assume that the reader is familiar with the language.">注意してほしいのは、このガイドはC++のチュートリアルではないということです。このガイドは読者がC++に精通していることを想定して書かれています。</span> </p>

            <h3 id="Goals"><span title="Goals of the Style Guide">本ガイドの目的</span></h3>
            <div class="stylebody">
                <p><span title="Why do we have this document?">なぜ本ガイドは書かれたか</span></p>

                <p>
                    <span title="There are a few core goals that we believe this guide should serve.">このガイドで役立つと思われるいくつかの中核的目標があります。</span> <span title="These are the fundamental whys that underlie all of the individual rules.">それらは、すべての個々のルールの根底となっている基本的なものです。</span> <span title="By bringing these ideas to the fore, we hope to ground discussions and make it clearer to our broader community why the rules are in place and why particular decisions have been made.">私たちは、この考え方を前面に出すことで、議論が行われ、より広範囲なコミュニティにおいて、これらのルールがなぜ作られ、なぜそのように決められたのか、より明確に伝わることを望んでいます。</span>
                    <span title="If you understand what goals each rule is serving, it should be clearer to everyone when a rule may be waived (some can be), and what sort of argument or alternative would be necessary to change a rule in the guide.">個々のルールがどのような目的を果たそうとしているか理解できれば、いつルールの採用を取りやめるべきか、ルールを変更するためにどんな議論や代替案が必要か、より明確になるでしょう。</span>
                </p>

                <p><span title="The goals of the style guide as we currently see them are as follows:">本スタイルガイドの目的は今のところ次のとおりです。</span></p>
                <dl>
                    <dt><span title="Style rules should pull their weight">スタイルルールを重くしすぎないこと</span></dt>
                    <dd>
                        <span title="The benefit of a style rule must be large enough to justify asking all of our engineers to
remember it.">個々のスタイルルールは「所属するすべてのエンジニアが覚えなくてはならない」ことを正当化できるくらいに価値のあるものでなければなりません。</span> <span title="The benefit is measured relative to the codebase we would get without the rule, so a rule against a very harmful practice may still have a small benefit if people are unlikely to do it anyway.">ルールの価値は「仮にそのルールが無かったら書かれたかもしれないコード」との比較で測定されます。このため、仮に「非常に有害な慣行に対するルール」があったとしても、「そもそもそんなルールがなくとも普通はしないよね」という場合、そのルールの価値は低いと考えます。</span> <span title="This principle mostly explains the rules we don&#8217;t have, rather than the rules we do: for example, goto contravenes many of the following principles, but is already vanishingly rare, so the Style Guide doesn&#8217;t discuss it.">この原則は、どちらかというと、本スタイルガイドに書かれていないルールについて説明しています。例えば、<code>goto</code>の濫用はこれに続く多くの原則に違反しますが、すでにそれが行われること自体がレアケースになっています。このため、本ガイドでは<code>goto</code>の濫用については取り扱いません。</span>
                    </dd>

                    <dt><span title="Optimize for the reader, not the writer">コードの(書き手ではなく)読み手に優しいこと</span></dt>
                    <dd><span title="Our codebase (and most individual components submitted to it) is expected to continue for quite some time.">我々のコードベース(と、ほとんどの個々のコンポーネント)は、今後長い長い時を経ていくことが予想されます。</span> <span title="As a result, more time will be spent reading most of our code than writing it.">結果的に、そのコードを書くのに費やした時間に比べて、はるかに多くの時間がコードを読むために割かれることでしょう。</span> <span title="We explicitly choose to optimize for the experience of our average software engineer reading, maintaining, and debugging code in our codebase rather than ease when writing said code.">私たちは、私たちの平均的なエンジニアが「簡単にコードが書けること」よりも、「コードを読み、メンテし、デバッグがやりやすいこと」に最適化することを明示的に選択します。</span> <span title="&quot;Leave a trace for the reader&quot; is a particularly common sub-point of this principle:">特に「読者のためのヒントを残す」がこの原則の共通のサブテーマになっています。</span> <span title="When something surprising or unusual is happening in a snippet of code (for example, transfer of pointer ownership), leaving textual hints for the reader at the point of use is valuable (std::unique_ptr demonstrates the ownership transfer unambiguously at the call site).">コードの中で見慣れないことをするとき(たとえばポインタの所有権を移す)、読み手のためにヒントを残しておくことは価値があります(<code>std::unique_ptr</code>は明白に所有権を移すことを示しています)。</span> </dd>

                    <dt><span title="Be consistent with existing code">既存のコードと一貫性が保たれていること</span></dt>
                    <dd> <span title="Using one style consistently through our codebase lets us focus on other (more important) issues.">１つのスタイルをコードベース全体で一貫して用いることで、私たちは他の(より重要な)問題にフォーカスすることができます。</span> <span title="Consistency also allows for automation: tools that format your code or adjust your #includes only work properly when your code is consistent with the expectations of the tooling.">一貫性は自動化を進めやすくもします。コードフォーマットツールは、ツールが期待するコードとあなたのコードが一貫しているときにのみ正しく動作します。</span> <span title="In many cases, rules that are attributed to &quot;Be Consistent&quot; boil down to &quot;Just pick one and stop worrying about it&quot;">多くの場合「一貫性を保つ」に起因するルールは「ただ１つを選び、それについて悩むことをやめる」ということです。</span> <span title="the potential value of allowing flexibility on these points is outweighed by the cost of having people argue over them.">これらの点の多様性を認めることの潜在的な価値よりも、それについて議論するコストの方が上回っているのです。</span></dd>

                    <dt><span title="Be consistent with the broader C++ community when appropriate">より広範囲なC++コミュニティと一貫性があること</span></dt>
                    <dd><span title="Consistency with the way other organizations use C++ has value for the same reasons as consistency within our code base.">C++を使う他の組織のやり方と一貫性を保つことも、我々コードベース内で一貫性を保つことと同じ理由で価値があります。</span><span title="If a feature in the C++ standard solves a problem, or if some idiom is widely known and accepted, that's an argument for using it.">あるC++標準の機能が問題を解けるのならば、あるイディオムが広く知られて受け入れられているのならば、それを使うための議論をします。</span> <span title="However, sometimes standard features and idioms are flawed, or were just designed without our codebase's needs in mind.">しかし、時折、標準的な機能やイディオムは、不備があったり、あるいは単に私たちのコードベースのニーズを満たさない形でデザインされていたりします。</span> <span title="In those cases (as described below) it's appropriate to constrain or ban standard features.">このような場合、これらの標準機能は制限または禁止することが適切です。</span> <span title="In some cases we prefer a homegrown or third-party library over a library defined in the C++ Standard, either out of perceived superiority or insufficient value to transition the codebase to the standard interface.">いくつかのケースでは、C++標準ライブラリよりも自家製もしくはサードパーティのライブラリを選ぶ場合もあります。標準的なインターフェースにコードベースを移行することには知的優位性も十分な価値もありません。</span></dd>

                    <dt><span title="Avoid surprising or dangerous constructs">見慣れない、あるいは危険な構成は避けること</span></dt>
                    <dd>
                        <span title="C++ has features that are more surprising or dangerous than one might think at a glance.">C++には、ちょっと考えただけでは気が付かないかもしれない、驚くような、あるいは危険な機能も存在します。</span> <span title="Some style guide restrictions are in place to prevent falling into these pitfalls.">本ガイドにおけるいくつかの制限ルールは、このような落とし穴を避けるためのものです。</span> <span title="There is a high bar for style guide waivers on such restrictions, because waiving such rules often directly risks compromising program correctness.">これらのルールを破棄するとプログラムの正確性が失われる可能性があるため、それらのルールを破棄するためには高いハードルを設けています。</span>
                    </dd>

                    <dt><span title="Avoid constructs that our average C++ programmer would find tricky or hard to maintain">平均的なC++プログラマがトリッキーと感じたり、メンテしにくいと感じたりするような構成は避けること</span></dt>
                    <dd><span title="C++ has features that may not be generally appropriate because of the complexity they introduce to the code.">C++はその複雑さゆえに、コードに導入するのが適切でないような機能も持っています。</span> <span title="In widely used code, it may be more acceptable to use trickier language constructs, because any benefits of more complex implementation are multiplied widely by usage, and the cost in understanding the complexity does not need to be paid again when working with new portions of the codebase.">広く使われているコードの中は、トリッキーな言語構造の方が受け入れられることもあるかもしれません。その場合の理由は、より複雑な実装が過去に繰り返されてきたことや、その複雑なものを理解するコストは、コードベースの新しい部分で仕事をする時にもう一度払う必要はないからです。</span> <span title="When in doubt, waivers to rules of this type can be sought by asking  your project leads.">これを疑うのであれば、このタイプのルールの破棄についてプロジェクトリーダーと相談してください。</span> <span title="This is specifically important for our codebase because code ownership and team membership changes over time: even if everyone that works with some piece of code currently understands it, such understanding is not guaranteed to hold a few years from now.">これは我々のコードベースでは特に重要です。なぜなら、コードの担当者やチームメンバーは時とともに変わるからです。誰かがそのコードを理解して触っていたとしても、その理解が今から1年後にも保たれている保証はどこにもありません。</span></dd>

                    <dt><span title="Be mindful of our scale">我々のプロジェクト規模に留意すること</span></dt>
                    <dd><span title="With a codebase of 100+ million lines and thousands of engineers, some mistakes and simplifications for one engineer can become costly for many.">1億行以上のコードがあり、何千人ものエンジニアがいる状況において、ある一人のエンジニアのミスや単純化によるコストは非常に高くつくことがあります。</span> <span title="For instance it's particularly important to avoid polluting the global namespace: name collisions across a codebase of hundreds of millions of lines are difficult to work with and hard to avoid if everyone puts things into the global namespace.">たとえば、グローバル名前空間汚染を避けることは非常に重要です。何億行ものコードベースの間で、もし、誰もがグローバル名前空間に何でもかんでもおいていたら、名前の衝突は不可避です。</span></dd>

                    <dt><span title="Concede to optimization when necessary">必要な最適化は厭わない</span></dt>
                    <dd><span title="Performance optimizations can sometimes be necessary and appropriate, even when they conflict with the other principles of this document.">たとえ本ガイドのルールと競合したとしても、ときにパフォーマンスの最適化は必要かつ適切な場合もあります。</span></dd>
                </dl>

                <p>
                    <span title="The intent of this document is to provide maximal guidance with reasonable restriction.">本文書の目的は理にかなった制限の下での最大限のガイダンスを提供することです。</span> <span title="As always, common sense and good taste should prevail.">いつもどおり、常識や良識が優先されるべきです。</span> <span title="By this we specifically refer to the established conventions of the entire Google C++ community, not just your personal preferences or those of your team.">これによって、我々は、具体的に、あなたの個人的な好みやあなたのチームについてだけではなく、Google C++コミュニティ全体で確立された規約に言及します。</span>
                    <span title="Be skeptical about and reluctant to use clever or unusual constructs: the absence of a prohibition is not the same as a license to proceed.">巧妙なあるいは見慣れない構成には、懐疑的であってください。禁止されていないことはやっていいというわけではありません。</span>
                    <span title="Use your judgment, and if you are unsure, please don't hesitate to ask your project leads to get additional input.">自分の判断に従ってください。ルールに賛同できない場合には、自プロジェクトのリーダーに対して更なるインプットを求めることを躊躇わないようにしください。</span>
                </p>

            </div>



            <h2 id="Header_Files"><span title="Header Files">ヘッダファイル</span></h2>

            <p><span title="In general, every .cc file should have an associated .h file.">原則的に、全ての<code>.cc</code>ファイルは関連付く<code>.h</code>ファイルを持つようにします。</span> <span title="There are some common exceptions, such as unittests and small .cc files containing just a main() function.">ただし、ユニットテストや<code>main()</code>だけを含むような小さな<code>.cc</code>は例外です。</span></p>


            <p><span title="Correct use of header files can make a huge difference to the readability, size and performance of your code.">正しくヘッダーファイルを扱うことは、コードの可読性やサイズ、パフォーマンスに大きな違いをもたらします。</span></p>

            <p><span title="The following rules will guide you through the various pitfalls of using header files.">以下のルールはヘッダーファイルに関する様々な落とし穴を避けて通るための道しるべとなるはずです。</span></p>

            <a id="The_-inl.h_Files"></a>
            <h3 id="Self_contained_Headers"><span title="Self-contained Headers">自己完結型ヘッダー</span></h3>

            <div class="summary">
                <p>
                    <span title="Header files should be self-contained (compile on their own) and end in .h.">ヘッダファイルは自己完結(単体でコンパイルできる)していなくてはならず、名前は<code>.h</code>で終わります。</span>
                    <span title="Non-header files that are meant for inclusion should end in .inc and be used sparingly.">ヘッダファイルではない、includeして使われるべきものは<code>.inc</code>で終わるようにしますが、なるべく使用は控えるようにしましょう。
                </p>
            </div>

            <div class="stylebody">
                <p><span title="All header files should be self-contained.">すべてのヘッダは自己完結していなくてはなりません。</span> <span title="Users and refactoring tools should not have to adhere to special conditions to include the header.">ヘッダの使用者やリファクタリングツールは、そのヘッダがincludeされる際に、なんら特別な条件を守る必要がないようにします。</span><span title="Specifically, a header should have header guards and include all other headers it needs.">特に、ヘッダには<a href="#The__define_Guard">インクルードガード</a>を持たせ、そのヘッダ自身が必要とするすべての他のヘッダをincludeします。</span></p>

                <p><span title="Prefer placing the definitions for template and inline functions in the same file as their declarations.">テンプレートやインライン関数などの定義は、宣言と同じファイルに含めましょう。</span> <span title="The definitions of these constructs must be included into every .cc file that uses them, or the program may fail to link in some build configurations.">これらの定義は、それを用いるすべての<code>.cc</code>ファイルに含まれる必要があり、さもなくばビルド環境によってはリンクに失敗するかもしれません。</span> <span title="If declarations and definitions are in different files, including the former should transitively include the latter.">もし宣言と定義が違うファイルに分かれているならば、前者は後者をincludeすべきです。</span> <span title="Do not move these definitions to separately included header files (-inl.h); this practice was common in the past, but is no longer allowed.">これらの定義を分割ヘッダファイル(<code>-inl.h</code>)に移動してはなりません。その手法は古いやり方であり、現在は禁止されています。</span></p>

                <p><span title="As an exception, a template that is explicitly instantiated for all relevant sets of template arguments, or that is a private implementation detail of a class, is allowed to be defined in the one and only .cc file that instantiates the template.">例外として、すべての関連するテンプレート引数セットについて明示的に例示されたテンプレートや、クラスのprivateな実装であるテンプレートは、そのテンプレートを実体化している唯一の<code>.cc</code>ファイルで定義しても構いません。</span></p>

                <p><span title="There are rare cases where a file designed to be included is not self-contained.">レアケースながら、includeされるが自己完結でないようなデザインも存在します。</span> <span title="These are typically intended to be included at unusual locations, such as the middle of another file.">これらはたいていの場合、別のファイルの途中(中ほど)など変わった場所でinlucdeされることを想定しています。</span> <span title="They might not use header guards, and might not include their prerequisites.">それらのファイルは、<a href="#The__define_Guard">インクルードガード</a>を持っていなかったり、そのヘッダ内で必要なものをincludeしていなかったりします。</span> <span titile="Name such files with the .inc extension.">このようなファイルには、<code>.inc</code>拡張子を持たせるようにします。</span><span title="Use sparingly, and prefer self-contained headers when possible.">また、なるべく使用は避け、可能な限り自己完結型ヘッダを使うことを選択しましょう。</span></p>

            </div>

            <h3 id="The__define_Guard"><span title="#define guards">インクルードガード</span></h3>

            <div class="summary">
                <p>
                    <span title="All header files should have #define guards to prevent multiple inclusion.">すべてのヘッダファイルは、インクルードガード(<code>#define</code> guards)を持たなくてはなりません。</span>
                    <span title="The format of the symbol name should be &lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H_.">その際のシンボル名は<code><i>&lt;PROJECT&gt;</i>_<i>&lt;PATH&gt;</i>_<i>&lt;FILE&gt;</i>_H_</code>の形でなくてはなりません。</span>
                </p>
            </div>

            <div class="stylebody">



                <p><span title="To guarantee uniqueness, they should be based on the full path in a project's source tree.">ユニーク性を保証するため、プロジェクト内ソースツリーのフルパスに基づくものにします。</span> <span title="For example, the file foo/src/bar/baz.h in project foo should have the following guard:">たとえば、プロジェクトfooに含まれるファイル<code>foo/src/bar/baz.h</code>のガードは次のようにします。</span></p>

<pre>#ifndef FOO_BAR_BAZ_H_
#define FOO_BAR_BAZ_H_

...

#endif  // FOO_BAR_BAZ_H_
</pre>




            </div>

            <h3 id="Forward_Declarations"><span title="Forward Declarations">前方宣言</span></h3>

            <div class="summary">
                <p><span title="Avoid using forward declarations where possible.">前方宣言は可能な限り避けましょう。</span> <span title="Just #include the headers you need.">必要ならば単にヘッダを<code>#include</code>してください。</p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p><span title="A &quot;forward declaration&quot; is a declaration of a class, function, or template without an associated definition.">前方宣言とは、関連付く定義のないクラス・関数・テンプレートの宣言のことです。</span></p>
                </div>

                <div class="pros">
                    <ul>
                        <li><span title="Forward declarations can save compile time, as #includes force the compiler to open more files and process more input.">前方宣言は、<code>#include</code>がコンパイラに多数のファイルを開かせてそれを処理させるためのコンパイル時間を節約することができます。</span></li>

                        <li><span title="Forward declarations can save on unnecessary recompilation.">前方宣言は、不必要な再コンパイルを抑えることができます。</span><span title="#includes can force your code to be recompiled more often, due to unrelated changes in the header."><code>#include</code>は、ヘッダの変更があなたのコードに無関係な場合でもコードを再コンパイルする必要があるため、再コンパイルの頻度が上がります。</span></li>
                    </ul>
                </div>

                <div class="cons">
                    <ul>
                        <li><span title="Forward declarations can hide a dependency, allowing user code to skip necessary recompilation when headers change.">前方宣言は、依存性を隠してしまうため、コードの再コンパイルが必要な場合でも、それをスキップさせてしまうことがあります。</span></li>

                        <li><span title="A forward declaration may be broken by subsequent changes to the library.">前方宣言は、将来のライブラリ側の変更によって壊れる可能性があります。</span> <span title="Forward declarations of functions and templates can prevent the header owners from making otherwise-compatible changes to their APIs, such as widening a parameter type, adding a template parameter with a default value, or migrating to a new namespace.">関数やテンプレートの前方宣言は、元のヘッダの持ち主がAPIに対する互換性のない変更(パラメータの型を拡張したり、デフォルト値とともにテンプレートパラメータを増やしたり、新しい名前空間への移行したり)をすることを妨げになります。</span></li>

                        <li><span title="Forward declaring symbols from namespace std yields undefined behavior."><code>std::</code>名前空間のシンボルに対する前方宣言は未定義動作を引き起こします。</span></li>

                        <li>
                            <span title="It can be difficult to determine whether a forward declaration or a full #include is needed.">前方宣言だけで済むのか、<code>#include</code>が必要かを判断するのは、難しいことがあります。</span> <span title="Replacing an #include with a forward declaration can silently change the meaning of code:">次のコードの<code>#include</code>を単に前方宣言に置き換えてしまうと、コードの意味が変わってしまいます。</span>
                            <pre>      // b.h:
      struct B {};
      struct D : B {};

      // good_user.cc:
      #include "b.h"
      void f(B*);
      void f(void*);
      void test(D* x) { f(x); }  // calls f(B*)
      </pre>

                            <span title="If the #include was replaced with forward decls for B and D, test() would call f(void*)."><code>B</code>と<code>D</code>に対する<code>#include</code>を、単に前方宣言に置き換えてしまった場合、test()は <code>f(void*)</code> を呼び出すことになるでしょう。</span>
                        </li>

                        <li><span title="Forward declaring multiple symbols from a header can be more verbose than simply #include-ing the header.">ある1つのヘッダに含まれる複数のシンボルを前方宣言することは、単にそのヘッダを<code>#include</code>するよりも冗長になってしまいます。</span></li>

                        <li><span title="Structuring code to enable forward declarations (e.g. using pointer members instead of object members) can make the code slower and more complex.">前方宣言を使ってコードを作ろうとすると、(メンバにオブジェクトではなくポインタにしなくてはならないなど)、実行速度を下げ、しかも複雑なコードを書く羽目になるかもしれません。</span></li>


                    </ul>
                </div>

                <div class="decision">
                    <ul>
                        <li><span title="Try to avoid forward declarations of entities defined in another project.">外部プロジェクト内に存在するモノの前方宣言は避けましょう。</span></li>

                        <li><span title="When using a function declared in a header file, always #include that header.">ヘッダで宣言されている関数を使いたい場合は、常にそのヘッダを<code>#include</code>しましょう。</span></li>

                        <li><span title="When using a class template, prefer to #include its header file.">クラステンプレートを使いたい場合、ヘッダを<code>#include</code>しましょう。</span></li>
                    </ul>

                    <p><span title="Please see Names and Order of Includes for rules about when to #include a header.">ヘッダの<code>#include</code>関するルール<a href="#Names_and_Order_of_Includes">インクルードの名前と順序</a>も読んでください。</span></p>
                </div>

            </div>

            <h3 id="Inline_Functions"><span title="Inline Functions">インライン関数</span></h3>

            <div class="summary">
                <p><span title="Define functions inline only when they are small, say, 10 lines or fewer.">インライン関数は、関数の定義が小さいとき(10行以下)だけ使うようにしましょう。</span></p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p><span title="You can declare functions in a way that allows the compiler to expand them inline rather than calling them through the usual function call mechanism.">関数は、コンパイラに対して、通常の関数呼び出しの代わりに、直接その場に展開することを許した形で宣言することができます。</p>
                </div>

                <div class="pros">
                    <p><span title="Inlining a function can generate more efficient object code, as long as the inlined function is small.">関数のインライン化によって、インライン化される関数が小さければ、効率的なオブジェクトコードを生成することができるようになります。</span><span title="Feel free to inline accessors and mutators, and other short, performance-critical functions.">アクセサ(訳注:日本語圏でいうGetterのこと)やミューテータ(訳注:日本語圏でいうSetterのこと)、パフォーマンスクリティカルな小さい関数はどんどんインライン化しましょう。</span></p>
                </div>

                <div class="cons">
                    <p><span title="Overuse of inlining can actually make programs slower.">インライン関数を使いすぎると実のところプログラムは遅くなることもあります。</span> <span title="Depending on a function's size, inlining it can cause the code size to increase or decrease.">関数のサイズによっては、インライン化によってコードのサイズも増えたり減ったりします。</span> <span title="Inlining a very small accessor function will usually decrease code size while inlining a very large function can dramatically increase code size.">とても小さいアクセッサ関数をインライン化する場合たいていコードのサイズは小さくなりますが、一方で、大きな関数をインライン化してしまうと全体のコードサイズは劇的に大きくなってしまうこともあります。</span> <span title="On modern processors smaller code usually runs faster due to better use of the instruction cache.">イマドキのCPUにおいては、大抵の場合、命令キャッシュがうまく使える小さいコードの方が動作が速いです。</span></p>
                </div>

                <div class="decision">
                    <p><span title="A decent rule of thumb is to not inline a function if it is more than 10 lines long.">経験的なルールとして、関数が10行より多くなったらインライン化すべきではないです。</span> <span title="Beware of destructors, which are often longer than they appear because of implicit member- and base-destructor calls!">デストラクタに特に気を付けましょう。デストラクタは、暗黙的にメンバのデストラクタと基底デストラクタを呼び出すため見た目より長くなることがしばしばあるのです！</span></p>

                    <p><span title="Another useful rule of thumb: it's typically not cost effective to inline functions with loops or switch statements (unless, in the common case, the loop or switch statement is never executed).">もう１つ、有用な経験的なルールとして、大抵の場合、ループやswitch文のある関数は(それらがまったく実行されないような場合を除いて)インライン化しても効率的にはなりません。</p>

                    <p><span title="It is important to know that functions are not always inlined even if they are declared as such; for example, virtual and recursive functions are not normally inlined.">重要な知識として、インライン関数はインラインで宣言されたからといって常にインライン化されるわけではありません。たとえば仮想関数や再帰関数は通常インライン化されません。</span> <span title="Usually recursive functions should not be inline.">通常、再帰関数はインライン化すべきではありません。</span> <span title="The main reason for making a virtual function inline is to place its definition in the class, either for convenience or to document its behavior, e.g., for accessors and mutators.">仮想関数をクラス内にインラインで定義する理由は、利便性や、(GetterやSetterの場合など)動作に関するドキュメントとしての役割があるからです。</span></p>
                </div>

            </div>

            <h3 id="Names_and_Order_of_Includes"><span title="Names and Order of Includes">インクルードの名前と順序</span></h3>

            <div class="summary">
                <p><span title="Use standard order for readability and to avoid hidden dependencies:">可読性を保つため、また、依存関係が隠れるのを防ぐため、次に示す順序でヘッダをincludeします。</span> <span title="Related header, C library, C++ library,  other libraries' .h, your project's .h.">関連付くヘッダ, Cライブラリヘッダ, C++ライブラリヘッダ, 他のライブラリヘッダ, 自分のプロジェクトのヘッダ.</span></p>
            </div>

            <div class="stylebody">
                <p>
                    <span title="All of a project's header files should be listed as descendants of the project's source directory without use of UNIX directory shortcuts . (the current directory) or .. (the parent directory).">プロジェクトヘッダはプロジェクトソースディレクトリ以下に配置しなくてはなりません。UNIXディレクトリショートカットである <code>.</code>(カレントディレクトリ)や、<code>..</code>(親ディレクトリ)は省きます。</span> <span title="For example, google-awesome-project/src/base/logging.h should be included as:">たとえば、<code>google-awesome-project/src/base/logging.h</code>は次のようにインクルードされます。
                </p>

<pre>#include "base/logging.h"
</pre>

                <p><span title="In dir/foo.cc or dir/foo_test.cc, whose main purpose is to implement or test the stuff in dir2/foo2.h, order your includes as follows:"><code><var>dir2/foo2</var>.h</code>の宣言を実装もしくはテストする目的のファイル、<code><var>dir/foo</var>.cc</code>や<code><var>dir/foo_test</var>.cc</code>の中では、次の順序でincludeします。</span></p>

                <ol>
                    <li><code><var>dir2/foo2</var>.h</code>.</li>

                    <li><span title="C system files.">C システムヘッダ</span></li>

                    <li><span title="C++ system files.">C++ システムヘッダ</span></li>

                    <li><span title="Other libraries' .h files.">ほかのライブラリの<code>.h</code>ファイル</li>

                    <li><span title="Your project's .h files.">あなたのプロジェクトの.hファイル</span></li>
                </ol>

                <p>
                    <span title="With the preferred ordering, if dir2/foo2.h omits any necessary includes, the build of dir/foo.cc or dir/foo_test.cc will break.">この順番であれば、もし<code><var>dir2/foo2</var>.h</code>が必要なincludeを省くと、<code><var>dir/foo</var>.cc</code>や<code><var>dir/foo</var>_test.cc</code>のビルドが失敗します。</span>

                    <span title="Thus, this rule ensures that build breaks show up first for the people working on these files, not for innocent people in other packages.">このルールであれば、ビルドが壊れたことを、他のパッケージで作業している無実の人ではなく、このファイルで作業をしていた人に一番最初に見せることができます。</span>
                </p>

                <p><span title="dir/foo.cc and dir2/foo2.h are usually in the same directory (e.g. base/basictypes_test.cc and base/basictypes.h), but may sometimes be in different directories too."><code><var>dir/foo</var>.cc</code>と<code><var>dir2/foo2</var>.h</code>は、一般的に同じディレクトリに置きますが(たとえば、<code>base/basictypes_test.cc</code>と<code>base/basictypes.h</code>)、異なるディレクトリに置いてもよいです。</p>


                <p><span title="Within each section the includes should be ordered alphabetically.">各セクション内ではアルファベット順に並べます。</span> <span title="Note that older code might not conform to this rule and should be fixed when convenient.">古いコードはこのルールに沿ってないかもしれませんが、利便性を考えたときは修正(訳注:be fixed)します。</span></p>

                <p>
                    <span title="You should include all the headers that define the symbols you rely upon, except in the unusual case of forward declaration.">ヘッダは、<a href="#Forward_Declarations">前方宣言</a>の例外を除いて、ヘッダが定義するシンボルに関連するすべてのヘッダをインクルードしなくてはなりません。</span> <span title="If you rely on symbols from bar.h, don't count on the fact that you included foo.h which (currently) includes bar.h: include bar.h yourself, unless foo.h explicitly demonstrates its intent to provide you the symbols of bar.h.">
                        もし、あなたが<code>bar.h</code>のシンボルに依存した定義をしようとしているのであれば、(仮にその時点で<code>bar.h</code>をインクルードしている<code>foo.h</code>をインクルードしていたとしてもその事実は忘れて、)素直に<code>bar.h</code>をインクルードするようにします。<code>foo.h</code>が<code>bar.h</code>のシンボルを提供すると明示的に説明している場合は除きます。
                    </span>

                    <span title="However, any includes present in the related header do not need to be included again in the related cc (i.e., foo.cc can rely on foo.h's includes).">関連ヘッダでインクルードしているヘッダは、<code>cc</code>ファイルで再度インクルードしないようにします。(つまり、<code>foo.cc</code>は、<code>foo.h</code>がインクルードに依存することができます)</span>
                </p>

                <p>
                    <span title="For example, the includes in google-awesome-project/src/foo/internal/fooserver.cc might look like this:">
                        例をあげます。<code>google-awesome-project/src/foo/internal/fooserver.cc</code>のインクルードは次のようになります。
                    </span>
                </p>


<pre>#include "foo/server/fooserver.h"

#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

#include &lt;hash_map&gt;
#include &lt;vector&gt;

#include "base/basictypes.h"
#include "base/commandlineflags.h"
#include "foo/server/bar.h"
</pre>

                <p class="exception"><span title="Sometimes, system-specific code needs conditional includes.">システム特有のコードは、しばしば条件が必要なインクルードを必要とする場合があります。</span> <span title="Such code can put conditional includes after other includes.">このようなコードは他のインクルードの後に条件付きインクルードを配置します。</span> <span title="Of course, keep your system-specific code small and localized.">もちろんのことですが、システム特有のコードは小さく局所的に保つようにしましょう。</span> <span title="Example:">例:</span></p>

<pre>#include "foo/public/fooserver.h"

#include "base/port.h"  // For LANG_CXX11.

#ifdef LANG_CXX11
#include &lt;initializer_list&gt;
#endif  // LANG_CXX11
</pre>

            </div>

            <h2 id="Scoping"><span title="Scoping">スコープ</span></h2>

            <h3 id="Namespaces"><span title="Namespaces">名前空間</span></h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            With few exceptions, place code in a namespace.
                        </span>
                        細かい例外を除いて、コードは名前空間の中に置いてください。
                    </span>
                    <span>
                        <span class="src">
                            Namespaces should have unique names based on the project name, and possibly its path.
                        </span>
                        名前空間はプロジェクト名やファイルのパスに基づいてユニークな名前をつけてください。
                    </span>
                    <span>
                        <span class="src">
                            Do not use <i>using-directives</i> (e.g.
                            <code>using namespace foo</code>).
                        </span>また、usingディレクティブ(<code>using namespace foo</code>)は使ってはいけません。
                    </span>
                    <span>
                        <span class="src">
                            Do not use inline namespaces.
                        </span>
                        インライン名前空間も使ってはいけません。
                    </span>

                    <span>
                        <span class="src">
                            For unnamed namespaces, see
                            <a href="#Unnamed_Namespaces_and_Static_Variables">
                                Unnamed Namespaces and
                                Static Variables
                            </a>.
                        </span>
                        無名名前空間については<a href="#Unnamed_Namespaces_and_Static_Variables">無名名前空間と静的変数</a>を参照してください。
                    </span></a>.
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        <span>
                            <span class="src">
                                Namespaces subdivide the global scope
                                into distinct, named scopes, and so are useful for preventing
                                name collisions in the global scope.
                            </span>
                            名前空間は、グローバルなスコープを名前付きのスコープに分割し、グローバルスコープにおける名前の衝突を防ぐのに有用です。
                        </span>
                    </p>
                </div>

                <div class="pros">

                    <p>
                        <span>
                            <span class="src">
                                Namespaces provide a method for preventing name conflicts
                                in large programs while allowing most code to use reasonably
                                short names.
                            </span>
                            名前空間を用いることで、大きなプログラムにおける名前の衝突を避け、コードの大部分で理にかなった短い名前を使うことができるようになります。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                For example, if two different projects have a class
                                <code>Foo</code> in the global scope, these symbols may
                                collide at compile time or at runtime.
                            </span>たとえば、2つのプロジェクトが同じ名前のクラス<code>Foo</code>をグローバル名前空間に持っていたとすると、これらのシンボルはコンパイル時や実行時に衝突してしまうかもしれません。
                        </span><span>
                            <span class="src">
                                If each project
                                places their code in a namespace, <code>project1::Foo</code>
                                and <code>project2::Foo</code> are now distinct symbols that
                                do not collide, and code within each project's namespace
                                can continue to refer to <code>Foo</code> without the prefix.
                            </span>
                            しかし、各プロジェクトが独自の名前空間を持っていれば、同名だったシンボル<code>project1::Foo</code>と<code>project2::Foo</code>は区別できるようになり、衝突しなくなります。一方で、各プロジェクトの名前空間内のコードは、引き続き、プレフィクスなしの<code>Foo</code>で参照を保つことができます。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">Inline namespaces automatically place their names in the enclosing scope.</span>
                            インライン名前空間は、自動的に、その内部に持つ名前を、自身を囲む(外側の)スコープに配置します。
                        </span>

                        <span>
                            <span class="src">Consider the following snippet, for example:</span>
                            例として、次のスニペットについて考えます。
                        </span>
                    </p>

<pre>namespace X {
inline namespace Y {
  void foo();
}  // namespace Y
}  // namespace X
</pre>

                    <p>
                        <span>
                            <span class="src">
                                The expressions <code>X::Y::foo()</code> and
                                <code>X::foo()</code> are interchangeable.
                            </span>
                            このとき、式<code>X::Y::foo()</code>は<code>X::foo()</code>とも書けます。
                        </span>
                        <span>
                            <span class="src">
                                Inline namespaces are primarily intended for ABI compatibility across versions.
                            </span>
                            インライン名前空間は、主にバージョン間におけるABIの互換性を保つことを目的としています。
                            `
                        </span>
                    </p>
                </div>

                <div class="cons">

                    <p>
                        <span>
                            <span class="src">
                                Namespaces can be confusing, because they complicate
                                the mechanics of figuring out what definition a name refers
                                to.
                            </span>
                            名前空間は、その名前解決の仕組みの複雑さから、混乱を招くこともあります。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Inline namespaces, in particular, can be confusing
                                because names aren't actually restricted to the namespace
                                where they are declared.
                            </span>
                            インライン名前空間は、事実上その中で宣言される名前を名前空間の中に閉じ込めないため、特に混乱しやすいです。
                        </span>
                        <span>
                            <span class="src">
                                They are only useful as part of
                                some larger versioning policy.
                            </span>
                            インライン名前空間は、バージョン管理ポリシーの一部としてのみ役に立ちます。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                In some contexts, it's necessary to repeatedly refer to
                                symbols by their fully-qualified names.
                            </span>
                            いくつかの文脈では、シンボルを解決するのに完全修飾された名前を用いる必要があります。
                        </span>
                        <span>
                            <span class="src">
                                For deeply-nested
                                namespaces, this can add a lot of clutter.
                            </span>
                            名前空間のネストが深い場合、コードが散らってしまうことになりかねません。
                        </span>
                    </p>
                </div>

                <div class="decision">

                    <p>
                        <span>
                            <span class="src">
                                Namespaces should be used as follows:
                            </span>
                            名前空間は次のように使いましょう:
                        </span>
                    </p>

                    <ul>
                        <li>
                            <span>
                                <span class="src">Follow the rules on <a href="#Namespace_Names">Namespace Names</a></span>
                                <a href="#Namespace_Names">名前空間の名前</a>のルールに従ってください。
                            </span>
                        </li>
                        <li>
                            <span>
                                <span class="src">Terminate namespaces with comments as shown in the given examples.</span>
                                名前空間の終わりには、先の例の通り、コメントをつけてください。
                            </span>
                        </li>
                        <li>
                            <p>
                                <span>
                                    <span class="src">
                                        Namespaces wrap the entire source file after
                                        includes,
                                        <a href="https://gflags.github.io/gflags/">gflags</a> definitions/declarations
                                        and forward declarations of classes from other namespaces.
                                    </span>
                                    名前空間は、include文や<a href="https://gflags.github.io/gflags/">gflags</a>の定義と宣言、他の名前空間のクラスの前方宣言の後に続くソースコードをすべて包むようにしてください。
                                </span>
                            </p>
                            <span>
                                <span class="src">
<pre>// In the .h file
namespace mynamespace {

// All declarations are within the namespace scope.
// Notice the lack of indentation.
class MyClass {
 public:
  ...
  void Foo();
};

}  // namespace mynamespace
</pre>
                                </span>
                                <pre>// .h ファイル
namespace mynamespace {

// すべての宣言は名前空間のスコープに含めます。
// インデントはしません。
class MyClass {
 public:
  ...
  void Foo();
};

}  // namespace mynamespace
</pre>
<pre>// .ccファイル
namespace mynamespace {

// 関数の定義は名前空間に含めます。
void MyClass::Foo() {
  ...
}

}  // namespace mynamespace
</pre>
                            </span>

                            <p>
                                <span>
                                    <span class="src">
                                        More complex <code>.cc</code> files might have additional details,
                                        like flags or using-declarations.
                                    </span>
                                    より複雑な <code>.cc</code>ファイルは、flagsやusing宣言などを含む場合もあります。
                                </span>
                            </p>
                            <span>
                                <span class="src">
<pre>#include "a.h"

DEFINE_FLAG(bool, someflag, false, "dummy flag");

namespace a {

using ::foo::bar;

...code for a...         // Code goes against the left margin.

}  // namespace a
</pre>
                                </span>
                                <pre>#include "a.h"

DEFINE_FLAG(bool, someflag, false, "dummy flag");

namespace a {

using ::foo::bar;

...code for a...         // コードの左側には余白を入れない。

}  // namespace a
</pre>
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Do not declare anything in namespace
                                    <code>std</code>, including forward declarations of
                                    standard library classes.
                                </span><code>std</code>名前空間の中には、標準ライブラリの前方宣言を含めて、何も宣言してはいけません。
                            </span>
                            <span>
                                <span class="src">
                                    Declaring entities in
                                    namespace <code>std</code> is undefined behavior, i.e.,
                                    not portable.
                                </span><code>std</code>名前空間の中に何かを宣言することは、コードの移植性を失わせ、未定義の動作を引き起こします。
                            </span><span>
                                <span class="src">
                                    To declare entities from the standard
                                    library, include the appropriate header file.
                                </span>標準ライブラリのエンティティを宣言するためには適切なヘッダファイルをインクルードします。
                            </span>
                        </li>

                        <li>
                            <p>
                                <span>
                                    <span class="src">
                                        You may not use a <i>using-directive</i>
                                        to make all names from a namespace available.
                                    </span>
                                    名前空間内のすべての名前を利用できるようにするための<i>usingディレクティブ</i>は使ってはいけません。
                                </span>
                            </p>
                            <span>
                                <span class="src">
<pre class="badcode">// Forbidden -- This pollutes the namespace.
using namespace foo;
</pre>
                                </span>
                                <pre class="badcode">// ダメ。名前空間を汚染している。
using namespace foo;
</pre>
                            </span>
                        </li>

                        <li>
                            <p>
                                <span>
                                    <span class="src">
                                        Do not use <i>Namespace aliases</i> at namespace scope
                                        in header files except in explicitly marked
                                        internal-only namespaces, because anything imported into a namespace
                                        in a header file becomes part of the public
                                        API exported by that file.
                                    </span>
                                    内部的に使用すると明示した名前空間の中を除いて、名前空間の別名(Namespace ailiases)</i>をヘッダファイルの名前空間のスコープで使ってはいけません。なぜならば、ヘッダファイルで名前空間にインポートされたすべてのものが、そのヘッダファイルが提供するpublicなAPIの一部として公開されることになるからです。
                                </span>
                            </p>

                            <span>
                                <span class="src">
                                    <pre>// Shorten access to some commonly used names in .cc files.
namespace baz = ::foo::bar::baz;
</pre>
                                </span>
                                <pre>// .ccファイルの中でたくさん使われる名前へのショートカットを作る。
namespace baz = ::foo::bar::baz;
</pre>
                            </span>
                            <span>
                                <span class="src">
<pre>// Shorten access to some commonly used names (in a .h file).
namespace librarian {
namespace impl {  // Internal, not part of the API.
namespace sidetable = ::pipeline_diagnostics::sidetable;
}  // namespace impl

inline void my_inline_function() {
  // namespace alias local to a function (or method).
  namespace baz = ::foo::bar::baz;
  ...
}
}  // namespace librarian
</pre>
                                </span><pre>// .hファイルの中で、よく使われる名前へのショートカットを作る。
namespace librarian {
namespace impl {  // 内部用。APIではありません。
namespace sidetable = ::pipeline_diagnostics::sidetable;
}  // namespace impl

inline void my_inline_function() {
  // 関数内に限定された名前空間の別名。
  namespace baz = ::foo::bar::baz;
  ...
}
}  // namespace librarian
</pre>
                            </span>

                        </li>
                        <li><span><span class="src">Do not use inline namespaces.</span>インライン名前空間は使ってはいけません。</span></li>
                    </ul>
                </div>
            </div>

            <h3 id="Unnamed_Namespaces_and_Static_Variables"><span title="Unnamed Namespaces and Static Variables">無名名前空間と静的変数</span></h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            When definitions in a <code>.cc</code> file do not need to be
                            referenced outside that file, place them in an unnamed
                            namespace or declare them <code>static</code>.
                        </span>
                        <code>.cc</code>ファイル中に、ファイル外から参照される必要がない定義を行うときは、それらを無名の名前空間内で宣言するか、<code>static</code>に宣言します。
                    </span>
                    <span>
                        <span class="src">
                            Do not use either
                            of these constructs in <code>.h</code> files.
                        </span>
                        これらの宣言を<code>.h</code>においてはいけません。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        <span>
                            <span class="src">
                                All declarations can be given internal linkage by placing them in
                                unnamed namespaces, and functions and variables can be given internal linkage by
                                declaring them <code>static</code>.
                            </span>
                            無名名前空間内のすべての宣言は内部リンケージとなります。また<code>static</code>に宣言された関数や変数も内部リンケージとなります。
                        </span>
                        <span>
                            <span class="src">
                                This means that anything you're declaring
                                can't be accessed from another file.
                            </span>
                            内部リンケージとなったものは、他のファイルからアクセスできません。
                        </span>
                        <span>
                            <span class="src">
                                If a different file declares something
                                with the same name, then the two entities are completely independent.
                            </span>
                            仮に、他のファイルで同じ名前が宣言されていたとしても、それらは2つの独立した別々の実体として扱われます。
                        </span>
                    </p>
                </div>

                <div class="decision">

                    <p>
                        <span>
                            <span class="src">
                                Use of internal linkage in <code>.cc</code> files is encouraged
                                for all code that does not need to be referenced elsewhere.
                            </span>
                            <code>.cc</code>で内部リンケージを使うことで、他の場所からこれらのコードは参照されてないということを強調できます。
                        </span>
                        <span>
                            <span class="src">
                                Do not use internal linkage in <code>.h</code> files.
                            </span>
                            <code>.h</code>ファイルでは内部リンケージは使用してはいけません。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Format unnamed namespaces like named namespaces.
                            </span>
                            無名名前空間も、名前付きの名前空間と同じようにフォーマットします。
                        </span>
                        <span>
                            <span class="src">
                                In the
                                terminating comment, leave the namespace name empty:
                            </span>
                            無名名前空間が終わるときのコメントは、以下の例のように名前空間名を空白のままにしておきます。
                        </span>
                    </p>

<pre>namespace {
...
}  // namespace
</pre>
                </div>
            </div>

            <h3 id="Nonmember,_Static_Member,_and_Global_Functions"><span title="Nonmember, Static Member, and Global Functions">メンバではない関数、静的メンバ関数、グローバル関数</h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Prefer placing nonmember functions in a namespace; use completely global
                            functions rarely.
                        </span>
                        メンバではない関数はいずれかの名前空間内におきましょう。完全なグローバル関数は滅多に使ってはいけません。
                    </span>
                    <span>
                        <span class="src">
                            Prefer grouping functions with a namespace instead of
                            using a class as if it were a namespace.
                        </span>
                        グローバル関数をグループ化するときは、クラスではなく名前空間を使いましょう。
                    </span>
                    <span>
                        <span class="src">
                            Static methods of a class should
                            generally be closely related to instances of the class or the class's static
                            data.
                        </span>
                        静的メンバ関数は、そのクラスのインスタンスや静的メンバ変数と関連性が強い場合にのみ用います。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <div class="pros">
                    <p>
                        <span>
                            <span class="src">
                                Nonmember and static member functions can be useful in
                                some situations.
                            </span>
                            静的メンバ関数や、メンバではない通常の関数は、いくつかのシチュエーションで有用です。
                        </span>
                        <span>
                            <span class="src">
                                Putting nonmember functions in a
                                namespace avoids polluting the global namespace.
                            </span>
                            通常の関数はいずれかの名前空間内に置くことで、グローバル名前空間の汚染を避けられます。
                        </span>
                    </p>
                </div>

                <div class="cons">
                    <p>
                        <span>
                            <span class="src">
                                Nonmember and static member functions may make more sense
                                as members of a new class, especially if they access
                                external resources or have significant dependencies.
                            </span>
                            通常の関数や、静的メンバ関数は、それらが外部のリソースにアクセスしたり強く依存したりしているときに、クラスのメンバとするよりも理にかなっている場合があります。
                        </span>
                    </p>
                </div>

                <div class="decision">
                    <p>
                        <span>
                            <span class="src">
                                Sometimes it is useful to define a
                                function not bound to a class instance.
                            </span>
                            場合により、関数はクラスインスタンスに紐付けない方が便利なことがあります。
                        </span>
                        <span>
                            <span class="src">
                                Such a function
                                can be either a static member or a nonmember function.
                            </span>
                            このような関数は、静的メンバ関数やメンバではない通常の関数とすることができます。
                        </span>
                        <span>
                            <span class="src">
                                Nonmember functions should not depend on external
                                variables, and should nearly always exist in a namespace.
                            </span>
                            メンバでない関数は、外部の変数に依存してはいけません。
                            また、常に近しい名前空間の中に存在していなければなりません。
                        </span>
                        <span>
                            <span class="src">
                                Rather than creating classes only to group static member
                                functions which do not share static data, use
                                <a href="#Namespaces">namespaces</a> instead.
                                静的な変数を共有しない、通常の関数をまとめるだけのクラスを作るのではなく、<a href="#Namespaces">名前空間</a>を使います。
                            </span>
                        </span>
                        <span>
                            <span class="src">
                                For a header
                                <code>myproject/foo_bar.h</code>, for example, write
                            </span>
                            例として、<code>myproject/foo_bar.h</code>は以下のように記述します。
                        </span>
                    </p>
<pre>namespace myproject {
namespace foo_bar {
void Function1();
void Function2();
}  // namespace foo_bar
}  // namespace myproject
</pre>
                    <p>
                        <span>
                            <span class="src">instead of</span>
                            悪い例:
                        </span>
                    </p>
<pre class="badcode">namespace myproject {
class FooBar {
 public:
  static void Function1();
  static void Function2();
};
}  // namespace myproject
</pre>
                    <p>
                        <span>
                            <span class="src">
                                If you define a nonmember function and it is only
                                needed in its <code>.cc</code> file, use
                                <a href="#Unnamed_Namespaces_and_Static_Variables">internal linkage</a> to limit
                                its scope.
                            </span>
                            通常の関数が特定の<code>.cc</code>ファイルでのみ使用される場合、<a href="#Unnamed_Namespaces_and_Static_Variables">内部リンケージ</a>を用いることで、スコープを制限することができます。
                        </span>
                    </p>
                </div>

            </div>

            <h3 id="Local_Variables"><span title="Local Variables">ローカル変数</span></h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Place a function's variables in the narrowest scope
                            possible, and initialize variables in the declaration.
                        </span>
                        関数内の変数は、可能な限りそのスコープを狭めるようにしてください。また、関数内の変数は、宣言と同時に初期化してください。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <p>
                    <span>
                        <span class="src">
                            C++ allows you to declare variables anywhere in a
                            function.
                        </span>
                        C++では、関数のどこでも変数を宣言することができます。
                    </span>
                    <span>
                        <span class="src">
                            We encourage you to declare them in as local a
                            scope as possible, and as close to the first use as
                            possible.
                        </span>
                        我々は、変数のスコープをできる限り局所的にし、できる限り初めて使用する場所の近くで宣言することをおすすめしています。
                    </span>
                    <span>
                        <span class="src">
                            This makes it easier for the reader to find the
                            declaration and see what type the variable is and what it
                            was initialized to.
                        </span>
                        そうすることによって、コードの読者が、変数の宣言がどこにあるか、型は何か、どのように初期化されたかを、見つけやすくすることができます。
                    </span>
                    <span>
                        <span class="src">
                            In particular, initialization should
                            be used instead of declaration and assignment, e.g.:
                        </span>
                        特に、変数の初期化は宣言と同時に行うようにし、宣言と代入を別に行うようなことは避けてください。例:
                    </span>
                </p>
                <span>
                    <span class="src">
<pre class="badcode">int i;
i = f();      // Bad -- initialization separate from declaration.
</pre>
                    </span>
                    <pre class="badcode">int i;
i = f();      // 悪い例。初期化が宣言と分かれている。
</pre>
                </span>
                <span>
                    <span class="src">
<pre>int j = g();  // Good -- declaration has initialization.
</pre>
                    </span>
                    <pre>int j = g();  // よい例。宣言と同時に初期化が行われている。
</pre>
                </span>
                <span>
                    <span class="src">
<pre class="badcode">std::vector&lt;int&gt; v;
v.push_back(1);  // Prefer initializing using brace initialization.
v.push_back(2);
</pre>
                    </span>
                    <pre class="badcode">std::vector&lt;int&gt; v;
v.push_back(1);  // {}による初期化を使う方がよい。
v.push_back(2);
</pre>
                </span>
                <span>
                    <span class="src">
<pre>std::vector&lt;int&gt; v = {1, 2};  // Good -- v starts initialized.
</pre>
                    </span>
                    <pre>std::vector&lt;int&gt; v = {1, 2};  // よい例。 vは初期化されている。
</pre>
                </span>

                <p>
                    <span>
                        <span class="src">
                            Variables needed for <code>if</code>, <code>while</code>
                            and <code>for</code> statements should normally be declared
                            within those statements, so that such variables are confined
                            to those scopes.  E.g.:
                        </span>

                        <code>if</code>文や<code>while</code>文、<code>for</code>文で使用される変数は、通常は、それらの文の中で宣言します。そうすることで、変数のスコープを制限することができます。例：
                    </span>
                </p>
<pre>while (const char* p = strchr(str, '/')) str = p + 1;
</pre>
                <p>
                    <span>
                        <span class="src">
                            There is one caveat: if the variable is an object, its
                            constructor is invoked every time it enters scope and is
                            created, and its destructor is invoked every time it goes
                            out of scope.
                        </span>
                        ただし、もし変数がオブジェクトだったとすると、スコープに入るたびに毎回コンストラクタが呼ばれ、オブジェクトが生成され、スコープから出るたびに毎回デストラクタが呼ばれることになります。
                    </span>
                </p>
                <span>
                    <span class="src">
<pre class="badcode">// Inefficient implementation:
for (int i = 0; i &lt; 1000000; ++i) {
  Foo f;  // My ctor and dtor get called 1000000 times each.
  f.DoSomething(i);
}
</pre>
                    </span>
                    <pre class="badcode">// 非効率的な実装
for (int i = 0; i &lt; 1000000; ++i) {
  Foo f;  // コンストラクタとデストラクタがそれぞれ 1000000 回ずつ呼ばれる。
  f.DoSomething(i);
}
</pre>
                </span>

                <p>
                    <span>
                        <span class="src">
                            It may be more efficient to declare such a variable
                            used in a loop outside that loop:
                        </span>
                        こういった場合、変数はループの外で宣言する方が効率的になる場合があります。
                    </span>
                </p>
                <span>
                    <span class="src">
<pre>Foo f;  // My ctor and dtor get called once each.
for (int i = 0; i &lt; 1000000; ++i) {
  f.DoSomething(i);
}
</pre>
                    </span>
                    <pre>Foo f;  // コンストラクタとデストラクタは1回ずつ呼ばれる。
for (int i = 0; i &lt; 1000000; ++i) {
  f.DoSomething(i);
}
</pre>
                </span>
            </div>

            <h3 id="Static_and_Global_Variables"><span title="Static and Global Variables">静的変数とグローバル変数</span></h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Variables of class type with <a href="http://en.cppreference.com/w/cpp/language/storage_duration#Storage_duration">
                                static storage duration
                            </a> are forbidden: they cause hard-to-find bugs due
                            to indeterminate order of construction and destruction.
                        </span>
                        <a href="http://en.cppreference.com/w/cpp/language/storage_duration#Storage_duration">静的記憶域期間(static storage duration)</a>を持ったクラス型の変数は禁止です。これらの変数は不定な順番で生成(construct)・破壊(destruct)されるため、発見が困難な不具合を引き起こすことにつながります。
                    </span>
                    <span>
                        <span class="src">
                            However, such
                            variables are allowed if they are <code>constexpr</code>: they have no
                            dynamic initialization or destruction.
                        </span>
                        ただし、そのような変数でも<code>constexpr</code>と共に定義される場合は使用が認められます。これらは動的な初期化や破壊が行われないため問題になりません。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <p>
                    <span>
                        <span class="src">
                            Objects with static storage duration, including global
                            variables, static variables, static class member
                            variables, and function static variables, must be Plain
                            Old Data (POD): only ints, chars, floats, or pointers, or
                            arrays/structs of POD.
                        </span>
                        静的な生存時間を持つオブジェクト(グローバル変数や静的変数、静的クラスメンバ変数、関数内静的変数を含む)は、必ずPlain Old Data(POD)でなくてはなりません。PODとは、組み込みの整数型(int,char,...)、浮動小数点型(float,double,...)、ポインタ、PODの配列、PODだけで構成された構造体のことです。
                    </span>
                </p>

                <p>
                    <span>
                        <span class="src">
                            The order in which class constructors and initializers
                            for static variables are called is only partially
                            specified in C++ and can even change from build to build,
                            which can cause bugs that are difficult to find.
                        </span>
                        C++において、静的変数のコンストラクタや初期化子の呼び出し順序は、部分的にしか決められておらず、ビルドのたびに変わる可能性すらあり、これらは非常に見つけづらいバグの元となります。
                    </span>
                    <span>
                        <span class="src">
                            Therefore in addition to banning globals of class type,
                            we do not allow non-local static variables to be initialized
                            with the result of a function, unless that function (such
                            as getenv(), or getpid()) does not itself depend on any
                            other globals.
                        </span>
                        このため、クラス型のグローバル変数に加え、(呼び出す関数が他のグローバルに依存していない場合を除いて)関数の結果によって初期化されるローカルでない静的変数も許容できません。
                    </span>
                    <span>
                        <span class="src">
                            However, a static POD variable within
                            function scope may be initialized with the result of a
                            function, since its initialization order is well-defined
                            and does not occur until control passes through its
                            declaration.
                        </span>
                        一方で、関数スコープの静的POD変数は、その初期化順序は十分に定義され、かつ、その宣言を初めて通過するまで初期化されないため、関数の結果で初期化されても問題ありません。
                    </span>
                </p>

                <p>
                    <span>
                        <span class="src">
                            Likewise, global and static variables are destroyed
                            when the program terminates, regardless of whether the
                            termination is by returning from <code>main()</code> or
                            by calling <code>exit()</code>.
                        </span>
                        ここまでの初期化の話と同様に、グローバル変数や静的変数は、(<code>main()</code>の処理が終わったか<code>exit()</code>の呼び出しであるかに関わらず)プログラムの終了時に破壊されます。
                    </span>
                    <span>
                        <span class="src">
                            The order in which
                            destructors are called is defined to be the reverse of
                            the order in which the constructors were called.
                        </span>
                        このときのデストラクタが呼ばれる順序は、コンストラクタが呼ばれた順の逆順と定義されていますが、
                    </span>
                    <span>
                        <span class="src">
                            Since
                            constructor order is indeterminate, so is destructor
                            order.
                        </span>
                        そもそも、コンストラクタの呼び出し順序は決まっていないため、デストラクタの呼び出し順序も決まっていません。
                    </span>
                    <span>
                        <span class="src">
                            For example, at program-end time a static variable
                            might have been destroyed, but code still running
                            &#8212; perhaps in another thread
                            &#8212; tries to access it and fails.
                        </span>
                        たとえば、プログラム終了処理時には静的変数は破壊されますが、まだ実行中のコード(おそらく別スレッド)がその変数にアクセスしようとして失敗するかもしれません。
                    </span>
                    <span>
                        <span class="src">
                            Or the
                            destructor for a static <code>string</code> variable
                            might be run prior to the destructor for another variable
                            that contains a reference to that string.
                        </span>
                        あるいは、静的な<code>string</code>のデストラクタが、その文字列への参照を持つ別の変数のデストラクタよりも先に実行されてしまうかもしれません。
                    </span>
                </p>

                <p>
                    <span>
                        <span class="src">
                            One way to alleviate the destructor problem is to
                            terminate the program by calling
                            <code>quick_exit()</code> instead of <code>exit()</code>.
                        </span>
                        このデストラクタ問題を軽減する1つの方法は、プログラムを終了するために<code>exit()</code>ではなく<code>quick_exit()</code>を呼び出すことです。
                    </span>
                    <span>
                        <span class="src">
                            The difference is that <code>quick_exit()</code> does not
                            invoke destructors and does not invoke any handlers that
                            were registered by calling <code>atexit()</code>.
                        </span>
                        <code>quick_exit()</code>は、<code>exit()</code>と違って、変数のデストラクタを呼び出さず、<code>atexit()</code>で事前に登録されたハンドラも呼び出しません。
                    </span>
                    <span>
                        <span class="src">
                            If you
                            have a handler that needs to run when a program
                            terminates via <code>quick_exit()</code> (flushing logs,
                            for example), you can register it using
                            <code>at_quick_exit()</code>.
                        </span>
                        たとえばログのflushなど、<code>quick_exit()</code>でプログラムを終了する場合に実行しないといけないことがある場合は<code>at_quick_exit()</code>で、ハンドラを登録することができます。
                    </span>
                    <span>
                        <span class="src">
                            (If you have a handler that
                            needs to run at both <code>exit()</code> and
                            <code>quick_exit()</code>, you need to register it in
                            both places.)
                        </span>
                        (<code>exit()</code>と<code>quick_exit()</code>のどちらが呼び出されてもハンドラを実行したい場合は、両方に登録しておく必要があります。)
                    </span>
                </p>

                <p>
                    <span>
                        <span class="src">
                            As a result we only allow static variables to contain
                            POD data.
                        </span>
                        結果的には、静的変数に格納できるものはPODだけです。
                    </span>
                    <span>
                        <span class="src">
                            This rule completely disallows
                            <code>std::vector</code> (use C arrays instead), or
                            <code>string</code> (use <code>const char []</code>).
                        </span>
                        このルールは、静的な<code>std::vector</code>や<code>string</code>を認めないことを意味します。
                        これらの代わりに、Cの配列や、<code>const char[]</code>を使うようにしてください。
                    </span>
                </p>



                <p>
                    <span>
                        <span class="src">
                            If you need a static or global
                            variable of a class type, consider initializing a pointer
                            (which will never be freed), from either your main()
                            function or from pthread_once().
                        </span>
                        もし、クラス型の静的変数やグローバル変数がほしくなった場合は、変数をポインタとして用意し、<code>main()</code>や<code>pthread_once()</code>の処理の中などで初期化する方法を検討してください(ポインタの解放処理はどこにも書きません)
                        。
                    </span>
                    <span>
                        <span class="src">
                            Note that this must be a
                            raw pointer, not a "smart" pointer, since the smart
                            pointer's destructor will have the order-of-destructor
                            issue that we are trying to avoid.
                        </span>
                        このとき宣言するポインタは生のポインタとし、スマートポインタ等を使用してはいけません。
                        スマートポインタのデストラクタは、ここまで回避しようとしてきたデストラクタ呼び出し順序の問題を再燃させてしまいます。
                    </span>
                </p>





            </div>

            <h2 id="Classes"><span title="Classes">クラス</span></h2>

            <p>
                <span>
                    <span class="src">
                        Classes are the fundamental unit of code in C++.
                    </span>
                    クラスはC++におけるコードの基本単位です。
                </span>
                <span>
                    <span class="src">
                        Naturally, we use them extensively.
                    </span>
                    もちろん、我々は、それらを広く使っています。
                </span>
                <span>
                    <span class="src">
                        This section lists the main dos and
                        don'ts you should follow when writing a class.
                    </span>
                    このセクションでは、クラスを書くときに、すべきこと、すべきでないことについて述べます。
                </span>
            </p>

            <h3 id="Doing_Work_in_Constructors"><span title="Doing Work in Constructors">コンストラクタで行うこと</span></h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Avoid virtual method calls in constructors, and avoid
                            initialization that can fail if you can't signal an error.
                        </span>
                        コンストラクタで仮想メンバ関数を呼ぶのはやめましょう。エラーを伝える手段がない場合、失敗するかもしれない初期化処理を行うのはやめましょう。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        <span>
                            <span class="src">
                                It is possible to perform arbitrary initialization in the body
                                of the constructor.
                            </span>
                            コンストラクタでは任意の初期化処理を行うことができます。
                        </span>
                    </p>
                </div>

                <div class="pros">
                    <ul>
                        <li>
                            <span>
                                <span class="src">
                                    No need to worry about whether the class has been initialized or
                                    not.
                                </span>
                                クラスが初期化済みであるかどうか、気にかけなくてよくなります。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Objects that are fully initialized by constructor call can
                                    be <code>const</code> and may also be easier to use with standard containers
                                    or algorithms.
                                </span>
                                コンストラクタで完全に初期化されるオブジェクトは、<code>const</code>にしやすく、標準コンテナや標準アルゴリズムで扱いやすくなります。
                            </span>
                        </li>
                    </ul>

                </div>

                <div class="cons">
                    <ul>
                        <li>
                            <span>
                                <span class="src">
                                    If the work calls virtual functions, these calls
                                    will not get dispatched to the subclass
                                    implementations.
                                </span>
                                コンストラクタで仮想関数が呼び出されたとしても、それらは派生クラスの実装を呼び出しません。
                            </span>
                            <span>
                                <span class="src">
                                    Future modification to your class can
                                    quietly introduce this problem even if your class is
                                    not currently subclassed, causing much confusion.
                                </span>
                                現時点で派生クラスがなくとも、将来的にクラスが変更された場合に、地味にこの問題を引き起こし、混乱を招くかもしれません。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    There is no easy way for constructors to signal errors, short of
                                    crashing the program (not always appropriate) or using exceptions
                                    (which are <a href="#Exceptions">forbidden</a>).
                                </span>
                                コンストラクタには、簡単にエラーを伝える方法がありません。せいぜい、プログラムをクラッシュさせる(常にそれが適切とは限らない)方法や、例外を使う(ルール上<a href="#Exceptions">禁止</a>)方法くらいです。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    If the work fails, we now have an object whose initialization
                                    code failed, so it may be an unusual state requiring a <code>
                                        bool
                                        IsValid()
                                    </code> state checking mechanism (or similar) which is easy
                                    to forget to call.
                                </span>
                                コンストラクタの処理が失敗した場合、初期化に失敗したオブジェクトができてしまいます。<code>bool IsValid()</code>のような状態をチェックする仕組みを用意しても、その呼び出しは簡単に忘れられてしまいます。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    You cannot take the address of a constructor, so whatever work
                                    is done in the constructor cannot easily be handed off to, for
                                    example, another thread.
                                </span>
                                コンストラクタのアドレスを得ることはできません。このため、コンストラクタで行われる処理の内容を他のスレッドに渡したりするようなことは、簡単にはできません。
                            </span>
                        </li>
                    </ul>
                </div>


                <div class="decision">
                    <p>
                        <span>
                            <span class="src">
                                Constructors should never call virtual functions.
                            </span>
                            コンストラクタでは仮想関数を呼び出してはいけません。
                        </span>
                        <span>
                            <span class="src">
                                If appropriate
                                for your code
                                ,
                                terminating the program may be an appropriate error handling
                                response.
                            </span>
                            それが適切と考えるのであれば、プログラムを強制終了するのもエラー処理の1つのやり方です。
                        </span>
                        <span>
                            <span class="src">
                                Otherwise, consider a factory function
                                or <code>Init()</code> method.
                            </span>
                            さもなくば、ファクトリ関数や<code>Init()</code>メソッドの導入を検討しましょう。
                        </span>
                        <span>
                            <span class="src">
                                Avoid <code>Init()</code> methods on objects with
                                no other states that affect which public methods may be called
                                (semi-constructed objects of this form are particularly hard to work
                                with correctly).
                            </span>
                            どのpublicメソッドが呼びだされてもよいかという他の状態を持たないオブジェクトの<code>Init()</code>メソッドは避けてください(特に、中途半端に生成されたオブジェクトを正しく動作させるのは困難です)。
                        </span>
                    </p>
                </div>

            </div>

            <a id="Explicit_Constructors"></a>
            <h3 id="Implicit_Conversions"><span title="Implicit Conversions">暗黙的型変換</span></h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Do not define implicit conversions.
                        </span>
                        暗黙的型変換を新たに定義してはいけません。
                    </span>
                    <span>
                        <span class="src">
                            Use the <code>explicit</code>
                            keyword for conversion operators and single-argument
                            constructors.
                        </span>
                        型変換演算子や、1つの引数をとるコンストラクタにおいては<code>explicit</code>キーワードを使用してください。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        <span>
                            <span class="src">
                                Implicit conversions allow an
                                object of one type (called the <dfn>source type</dfn>) to
                                be used where a different type (called the <dfn>
                                    destination
                                    type
                                </dfn>) is expected, such as when passing an
                                <code>int</code> argument to a function that takes a
                                <code>double</code> parameter.
                            </span>
                            暗黙的型変換によって、ある型のオブジェクトを異なる型のオブジェクトとして扱えるようになります。たとえば、<code>double</code>型の仮引数をとる関数に<code>int</code>型の値を渡せます。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                In addition to the implicit conversions defined by the language,
                                users can define their own, by adding appropriate members to the
                                class definition of the source or destination type.
                            </span>
                            言語で元々定義されている暗黙的型変換に加えて、変換元の型か変換先の型のクラス定義に適切なメンバを加えることで、新たに暗黙的型変換を定義することができます。
                        </span>
                        <span>
                            <span class="src">
                                An implicit
                                conversion in the source type is defined by a type conversion operator
                                named after the destination type (e.g. <code>
                                    operator
                                    bool()
                                </code>).
                            </span>
                            変換元の型における暗黙的型変換は、変換先型の名前をつけた型変換演算子によって定義されます(例:<code>operator bool()</code>)。
                        </span>
                        <span>
                            <span class="src">
                                An implicit conversion in the destination
                                type is defined by a constructor that can take the source type as
                                its only argument (or only argument with no default value).
                            </span>
                            変換先の型における暗黙的型変換は、変換元の型の引数を1つだけとる(またはデフォルト値のない引数を1つだけとる)コンストラクタによって定義されます。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                The <code>explicit</code> keyword can be applied to a constructor
                                or (since C++11) a conversion operator, to ensure that it can only be
                                used when the destination type is explicit at the point of use,
                                e.g. with a cast.
                            </span>
                            <code>explicit</code>キーワードは、コンストラクタや(C++11では)型変換演算子につけることができます。これによって、型変換を、変換先の型が明示された場合にのみ行うよう限定することができます。
                        </span>
                        <span>
                            <span class="src">
                                This applies not only to implicit conversions, but to
                                C++11's list initialization syntax:
                            </span>
                            これは、暗黙的型変換だけではなく、以下に示すようなC++11のリスト初期化構文にも適用されます。
                        </span>
                    </p>
<pre>class Foo {
  explicit Foo(int x, double y);
  ...
};

void Func(Foo f);
</pre>
<pre class="badcode">Func({42, 3.14});  // Error
</pre>
                    <span>
                        <span class="src">
                            This kind of code isn't technically an implicit conversion, but the
                            language treats it as one as far as <code>explicit</code> is concerned.
                        </span>
                        このようなコードは何らテクニカルな暗黙的型変換はしていませんが、言語上<code>explicit</code>に関連していると見なして扱われます。
                    </span>
                </div>

                <div class="pros">
                    <ul>
                        <li>
                            <span>
                                <span class="src">
                                    Implicit conversions can make a type more usable and
                                    expressive by eliminating the need to explicitly name a type
                                    when it's obvious.
                                </span>
                                暗黙的型変換は、型の利便性を高め、型が明確であるときには型の名前を省略可能であるため表現上も優れています。
                            </span>
                        </li>
                        <li>
                            <span>
                                <span class="src">
                                    Implicit conversions can be a simpler alternative to
                                    overloading.
                                </span>
                                暗黙的型変換は単にオーバーロードの代替手段としても利用可能です。
                            </span>
                        </li>
                        <li>
                            <span>
                                <span class="src">
                                    List initialization syntax is a concise and expressive
                                    way of initializing objects.
                                </span>
                                リスト初期化子による構文は、簡潔で表現的に優れたオブジェクトの初期化方法です。
                            </span>
                        </li>
                    </ul>
                </div>

                <div class="cons">
                    <ul>
                        <li>
                            <span>
                                <span class="src">
                                    Implicit conversions can hide type-mismatch bugs, where the
                                    destination type does not match the user's expectation, or
                                    the user is unaware that any conversion will take place.
                                </span>
                                暗黙的型変換は、型の不一致によるバグを隠してしまうことがあります。たとえば、変換先の型がユーザの期待どおりにならなかったり、そもそもその場で型変換が行わることに気づかなかったりします。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Implicit conversions can make code harder to read, particularly
                                    in the presence of overloading, by making it less obvious what
                                    code is actually getting called.
                                </span>
                                暗黙的型変換は、コードの可読性を下げる場合があります。特に、関数にオーバーロードが存在する場合、どれが実際に呼び出されるのかをわかりにくくしてしまうことがあります。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Constructors that take a single argument may accidentally
                                    be usable as implicit type conversions, even if they are not
                                    intended to do so.
                                </span>
                                1つの引数をとるコンストラクタが、意図せず型変換のために呼び出されてしまうことがあります。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    When a single-argument constructor is not marked
                                    <code>explicit</code>, there's no reliable way to tell whether
                                    it's intended to define an implicit conversion, or the author
                                    simply forgot to mark it.
                                </span>
                                1つの引数をとるコンストラクタが<code>explicit</code>でマークされていなかったとき、それが意図した暗黙的型変換のために書かれているのか、単にコードの著者が<code>explicit</code>をつけるのを忘れてしまっただけなのか、信頼できる判断方法がありません。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    It's not always clear which type should provide the conversion,
                                    and if they both do, the code becomes ambiguous.
                                </span>
                                変換元の型と変換先の型との、どちらの型が型変換を提供すべきかが常に明確であるとは限りません。もし両方がも型変換機能を持っていた場合、コードが曖昧になってしまいます。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    List initialization can suffer from the same problems if
                                    the destination type is implicit, particularly if the
                                    list has only a single element.
                                </span>
                                リスト初期化子は、変換先の型が暗黙的型変換を持つとき同じ問題にぶつかります(特にリストに1要素しか持っていなかった場合)。
                            </span>
                        </li>
                    </ul>
                </div>

                <div class="decision">
                    <p>
                        <span>
                            <span class="src">
                                Type conversion operators, and constructors that are
                                callable with a single argument, must be marked
                                <code>explicit</code> in the class definition.
                            </span>
                            型変換演算子と1つの引数で呼び出せるコンストラクタは<code>explicit</code>でマークされていなくてはなりません。
                        </span>
                        <span>
                            <span class="src">
                                As an
                                exception, copy and move constructors should not be
                                <code>explicit</code>, since they do not perform type
                                conversion.
                            </span>
                            例外として、コピーコンストラクタとムーブコンストラクタは<code>explicit</code>でマークされているべきではありません。これらは型変換を行うものではないからです。
                        </span>
                        <span>
                            <span class="src">
                                Implicit conversions can sometimes be necessary and
                                appropriate for types that are designed to transparently wrap other
                                types.
                            </span>
                            また、ある型が他の型を透過的にラップするようデザインされている場合など、暗黙的型変換が必要かつ適切な時もあります。
                        </span>
                        <span>
                            <span class="src">
                                In that case, contact
                                your project leads to request
                                a waiver of this rule.
                            </span>
                            そのような場合においては、プロジェクトリーダーと相談し、このルールの適用から外してください。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Constructors that cannot be called with a single argument
                                should usually omit <code>explicit</code>.
                            </span>
                            通常、1つの引数では呼び出せないコンストラクタについては<code>explicit</code>を省略します。
                        </span>
                        <span>
                            <span class="src">
                                Constructors that
                                take a single <code>std::initializer_list</code> parameter should
                                also omit <code>explicit</code>, in order to support copy-initialization
                                (e.g. <code>MyType m = {1, 2};</code>).
                            </span>
                            また、1つの<code>std::initializer_list</code>型の引数をとるコンストラクタについも、コピーによる初期化(例: <code>MyType m = {1, 2};</code>)をサポートするために<code>explicit</code>を省略してください。
                        </span>
                    </p>
                </div>

            </div>

            <h3 id="Copyable_Movable_Types"><span title="Copyable and Movable Types">コピー可能な型・ムーブ可能な型</span></h3>
            <a id="Copy_Constructors"></a>
            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Support copying and/or moving if these operations are clear and meaningful
                            for your type.
                        </span>
                        コピーやムーブは、それの実装が明確でかつ意味のある場合に限って実装してください。
                    </span>
                    <span>
                        <span class="src">
                            Otherwise, disable the implicitly generated special functions
                            that perform copies and moves.
                        </span>
                        それ以外の場合には、暗黙的に自動生成されるコピー・ムーブ関数は無効にしてください。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        <span>
                            <span class="src">
                                A copyable type allows its objects to be initialized or assigned
                                from any other object of the same type, without changing the value of the source.
                            </span>
                            型をコピー可能にすることによって、他の同じ型のオブジェクトから、元となるオブジェクトを変更することなく、自分自身の初期化や自分自身への代入ができるようになります。
                        </span>
                        <span>
                            <span class="src">
                                For user-defined types, the copy behavior is defined by the copy
                                constructor and the copy-assignment operator.
                            </span>
                            ユーザ定義の型においては、コピーの挙動は、コピーコンストラクタやコピー代入演算子によって定義されます。
                        </span>
                        <span>
                            <span class="src">
                                <code>string</code> is an example of a copyable type.
                            </span>
                            コピー可能な型の一例として<code>string</code>があります。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                A movable type is one that can be initialized and assigned
                                from temporaries (all copyable types are therefore movable).
                            </span>
                            ムーブ可能な型は、一時オブジェクトからの初期化または代入が可能な型です(ゆえに、コピー可能な型は常にムーブ可能な型です)。
                        </span>
                        <span>
                            <span class="src">
                                <code>std::unique_ptr&lt;int&gt;</code> is an example of a movable but not
                                copyable type.
                            </span>
                            ムーブは可能ですがコピーは不可能な型の一例として<code>std::unique_ptr&lt;int&gt;</code>があります。
                        </span>
                        <span>
                            <span class="src">
                                For user-defined types, the move behavior is defined by the move
                                constructor and the move-assignment operator.
                            </span>
                            ユーザ定義の型においては、ムーブの挙動は、ムーブコンストラクタやムーブ代入演算子によって定義されます。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                The copy/move constructors can be implicitly invoked by the compiler
                                in some situations, e.g. when passing objects by value.
                            </span>
                            コピーコンストラクタやムーブコンストラクタは、オブジェクトの値渡しなどの際、コンパイラによって暗黙的に呼び出されます。
                        </span>
                    </p>
                </div>

                <div class="pros">
                    <p>
                        <span>
                            <span class="src">
                                Objects of copyable and movable types can be passed and returned by value,
                                which makes APIs simpler, safer, and more general.
                            </span>
                            コピー可能・ムーブ可能なオブジェクトは、値渡し・値戻しができるため、APIがシンプルかつ安全で、より一般的な形になります。
                        </span>
                        <span>
                            <span class="src">
                                Unlike when passing objects
                                by pointer or reference, there's no risk of confusion over ownership,
                                lifetime, mutability, and similar issues, and no need to specify them in the
                                contract.
                            </span>
                            この場合は、オブジェクトのポインタ渡し・参照渡しと違って、オブジェクトの所有権や生存時間、ミュータビリティなどに関する危険がなく、それらに関する前提条件も必要なくなります。
                        </span>
                        <span>
                            <span class="src">
                                It also prevents non-local interactions between the client and the
                                implementation, which makes them easier to understand, maintain, and optimize by
                                the compiler.
                            </span>
                            また、呼び出し元と実装をつないでしまうような局所的でない相互作用も自動的に防がれます。これによって、理解しやすく、メンテナンスしやすく、コンパイラによって最適化が掛かりやすくなります。
                        </span>
                        <span>
                            <span class="src">
                                Further, such objects can be used with generic APIs that
                                require pass-by-value, such as most containers, and they allow for additional
                                flexibility in e.g., type composition.
                            </span>
                            さらに、このようなオブジェクトは、多くのコンテナ型のような値渡しを要求するAPIに利用することができる他、型の合成などにおいて柔軟な扱い方ができるようにもなります。
                        </span>
                    </p>
                    <p>
                        <span>
                            <span class="src">
                                Copy/move constructors and assignment operators are usually
                                easier to define correctly than alternatives
                                like <code>Clone()</code>, <code>CopyFrom()</code> or <code>Swap()</code>,
                                because they can be generated by the compiler, either implicitly or
                                with <code>= default</code>.
                            </span>
                            コピー・ムーブを行うコンストラクタや代入演算子は、一般に、<code>Clone()</code>, <code>CopyFrom()</code>あるいは<code>Swap()</code>といった代替的な方法に比べて、正しく定義することが容易です。なぜならば、これらのコンストラクタや代入演算子は暗黙的に、または明示的に<code>= default</code>と記載することで、コンパイラに生成させることができるためです。
                        </span>
                        <span>
                            <span class="src">
                                They are concise, and ensure
                                that all data members are copied.
                            </span>
                            自動的に生成されるコンストラクタや代入演算子は、明瞭で、かつすべてのメンバーがコピーされることが保証されます。
                        </span>
                        <span>
                            <span class="src">
                                Copy and move
                                constructors are also generally more efficient, because they don't
                                require heap allocation or separate initialization and assignment
                                steps, and they're eligible for optimizations such as

                                <a href="http://en.cppreference.com/w/cpp/language/copy_elision">
                                    copy elision
                                </a>.
                            </span>
                            また、コピーコンストラクタやムーブコンストラクタは一般的に、より効率的に動作します。なぜならば、これらはヒープメモリは確保せず、初期化と割り当てをまとめて行い、<a href="http://en.cppreference.com/w/cpp/language/copy_elision">copy elision</a>のような適切な最適化が行われるためです。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Move operations allow the implicit and efficient transfer of
                                resources out of rvalue objects.
                            </span>
                            ムーブ操作によって、右辺値オブジェクトから暗黙的かつ効率的にリソースを取り出すことが可能になります。
                        </span>
                        <span>
                            <span class="src">
                                This allows a plainer coding style
                                in some cases.
                            </span>
                            これによって、よりわかりやすいコーディングスタイルを採用できる場合があります。
                        </span>
                    </p>
                </div>

                <div class="cons">
                    <p>
                        <span>
                            <span class="src">
                                Some types do not need to be copyable, and providing copy
                                operations for such types can be confusing, nonsensical, or outright
                                incorrect.
                            </span>
                            型によってはコピーができることを必要としない場合や、コピー操作を提供しようとすること自体が理屈的におかしい場合もあります。
                        </span>
                        <span>
                            <span class="src">
                                Types representing singleton objects (<code>Registerer</code>),
                                objects tied to a specific scope (<code>Cleanup</code>), or closely coupled to
                                object identity (<code>Mutex</code>) cannot be copied meaningfully.
                            </span>
                            たとえば、(<code>Registerer</code>のような)シングルトンのオブジェクトや、(<code>Cleanup</code>のような)そのスコープに紐付くオブジェクト、あるいは(<code>Mutex</code>のような)個別のオブジェクトと密接に繋がっているようなオブジェクトは、意味のあるコピーはできません。
                        </span>
                    </p>
                    <p>
                        <span>
                            <span class="src">
                                Copy operations for base class types that are to be used
                                polymorphically are hazardous, because use of them can lead to
                                <a href="https://en.wikipedia.org/wiki/Object_slicing">object slicing</a>.
                            </span>
                            ポリモーフィズムを使用しているような型の基底クラスに対するコピー操作は、<a href="https://en.wikipedia.org/wiki/Object_slicing">オブジェクトのスライシング</a>を引き起こす可能性があり危険です。
                        </span>
                        <span>
                            <span class="src">
                                Defaulted or carelessly-implemented copy operations can be incorrect, and the
                                resulting bugs can be confusing and difficult to diagnose.
                            </span>
                            デフォルト実装や雑に実装されたコピー操作は誤ったものとなり、結果的に困惑的な診断の難しいバグを招くことがあります。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Copy constructors are invoked implicitly, which makes the
                                invocation easy to miss.
                            </span>
                            コピーコンストラクタは暗黙的に呼び出されるため、呼び出しを見落としやすいです。
                        </span>
                        <span>
                            <span class="src">
                                This may cause confusion for programmers used to
                                languages where pass-by-reference is conventional or mandatory.
                            </span>
                            これは、参照渡しが慣習的なプログラミング言語に馴染んだプログラマにとっての混乱ポイントになるでしょう。
                        </span>
                        <span>
                            <span class="src">
                                It may also
                                encourage excessive copying, which can cause performance problems.
                            </span>
                            また、余計なコピーを助長し、パフォーマンス上の問題になることもあります。
                        </span>
                    </p>
                </div>

                <div class="decision">

                    <p>
                        <span>
                            <span class="src">
                                Provide the copy and move operations if their meaning is clear to a casual
                                user and the copying/moving does not incur unexpected costs.
                            </span>
                            カジュアルなユーザから見て、操作の意味が明確で、かつコストも十分想定できる場合、コピー操作やムーブ操作が可能なようにしてください。
                        </span>
                        <span>
                            <span class="src">
                                If you define a
                                copy or move constructor, define the corresponding assignment operator, and
                                vice-versa.
                            </span>
                            コピーコンストラクタやムーブコンストラクタを独自に定義する場合は、それに紐付く代入演算子も併せて実装してください(逆の場合も同様です)。
                        </span>
                        <span>
                            <span class="src">
                                If your type is copyable, do not define move operations unless they
                                are significantly more efficient than the corresponding copy operations.
                            </span>
                            型がコピー可能な場合は、コピーに比べて非常に効率的にムーブできる場合を除いて、ムーブ操作を定義しないでください。
                        </span>
                        <span>
                            <span class="src">
                                If your
                                type is not copyable, but the correctness of a move is obvious to users of the
                                type, you may make the type move-only by defining both of the move operations.
                            </span>
                            また、コピー可能ではないが、ムーブ操作の正当性が明らかなときは、それぞれのムーブ操作を定義することで、ムーブのみ可能な型とすることもできます。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                If your type provides copy operations, it is recommended that you design
                                your class so that the default implementation of those operations is correct.
                            </span>
                            型がコピー操作をサポートする場合、できるだけコンパイラによるデフォルト実装が正しい操作となるようにクラスをデザインしてください。
                        </span>
                        <span>
                            <span class="src">
                                Remember to review the correctness of any defaulted operations as you would any
                                other code, and to document that your class is copyable and/or cheaply movable
                                if that's an API guarantee.
                            </span>
                            また、他のコードと同様に、デフォルトで生成されるコピー操作の正当性についても、忘れずにレビューを行ってください。
                            また、クラスがコピー可能である、もしくは、ムーブのみ可能であることを忘れずにドキュメント化してください。
                        </span>
                    </p>
                    <span>
                        <span class="src">
<pre class="badcode">class Foo {
 public:
  Foo(Foo&amp;&amp; other) : field_(other.field) {}
  // Bad, defines only move constructor, but not operator=.

 private:
  Field field_;
};
</pre>
                        </span>
                        <pre class="badcode">class Foo {
 public:
  Foo(Foo&amp;&amp; other) : field_(other.field) {}
  // ダメ。ムーブコンストラクタだけが実装されていて、operator= がない。.

 private:
  Field field_;
};
</pre>
                    </span>

                    <p>
                        <span>
                            <span class="src">
                                Due to the risk of slicing, avoid providing an assignment
                                operator or public copy/move constructor for a class that's
                                intended to be derived from (and avoid deriving from a class
                                with such members).
                            </span>
                            スライシングのリスクがあるため、継承されることを目的としているクラスは、publicなコピー・ムーブコンストラクタ、コピー・ムーブ代入演算子を提供しないでください。また、それらの操作を提供しているクラスから派生することは避けてください。
                        </span>
                        <span>
                            <span class="src">
                                If your base class needs to be
                                copyable, provide a public virtual <code>Clone()</code>
                                method, and a protected copy constructor that derived classes
                                can use to implement it.
                            </span>
                            基底クラスをコピー可能としたい場合、public virtualな<code>Clone()</code>メソッドを提供するようにしてください。
                            また、protectedなコピーコンストラクタを提供し、派生クラスのコピーの実装がそれを利用できるようにしておいてください。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                If you do not want to support copy/move operations on your type,
                                explicitly disable them using <code>= delete</code> in
                                the <code>public:</code> section:
                            </span>
                            型にコピー操作・ムーブ操作をサポートさせたくないときは、以下の例のように、<code>public:</code>セクション内において<code>= delete</code>を使って、明示的にそれらを無効にしてください。
                        </span>
                    </p>
                    <span>
                        <span class="src">
<pre class="code">// MyClass is neither copyable nor movable.
MyClass(const MyClass&amp;) = delete;
MyClass&amp; operator=(const MyClass&amp;) = delete;
</pre>
                        </span><pre class="code">// MyClassは、コピーもムーブも不可
MyClass(const MyClass&amp;) = delete;
MyClass&amp; operator=(const MyClass&amp;) = delete;
</pre>
                    </span>

                    <p></p>

                </div>
            </div>

            <h3 id="Structs_vs._Classes"><span title="Structs vs. Classes">構造体かクラスか</span></h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Use a <code>struct</code> only for passive objects that
                            carry data; everything else is a <code>class</code>.
                        </span>
                        <code>struct</code>はデータを運ぶための受け身的なオブジェクトにのみ使用し、それ以外は<code>class</code>を使用してください。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <p>
                    <span>
                        <span class="src">
                            The <code>struct</code> and <code>class</code>
                            keywords behave almost identically in C++.
                        </span>
                        <code>struct</code>と<code>class</code>は、C++においてほとんど同じです。
                    </span>
                    <span>
                        <span class="src">
                            We add our own
                            semantic meanings to each keyword, so you should use the
                            appropriate keyword for the data-type you're
                            defining.
                        </span>
                        我々は、それぞれのキーワードに独自の意味づけをしています。そのため、定義されるデータの種類に応じて適切なキーワードを用いなくてはなりません。
                    </span>
                </p>

                <p>
                    <span>
                        <span class="src">
                            <code>structs</code> should be used for passive
                            objects that carry data, and may have associated
                            constants, but lack any functionality other than
                            access/setting the data members.
                        </span>
                        <code>struct</code>は、データを運ぶためだけの受け身的なオブジェクトに使います。<code>struct</code>は、関連する定数を持つことはできますが、それ以外はデータのGetterやSetterを除いて、何ら機能的なものを持ちません。
                    </span>
                    <span>
                        <span class="src">
                            The accessing/setting of
                            fields is done by directly accessing the fields rather
                            than through method invocations.
                        </span>
                        データの取得・設定は、メソッド呼び出しではなく、フィールドに直接アクセスして行います。
                    </span>
                    <span>
                        <span class="src">
                            Methods should not
                            provide behavior but should only be used to set up the
                            data members, e.g., constructor, destructor,
                            <code>Initialize()</code>, <code>Reset()</code>,
                            <code>Validate()</code>.
                        </span>
                        データメンバーを設定する以外のメソッドは持たせてはなりません。
                        たとえば、コンストラクタ、デストラクタ、<code>Initialize()</code>、<code>Reset()</code>、<code>Validate()</code>などです。
                    </span>
                </p>

                <p>
                    <span>
                        <span class="src">
                            If more functionality is required, a
                            <code>class</code> is more appropriate.
                        </span>
                        より機能的なものが要求される場合は、<code>class</code>の方が適切です。
                    </span>
                    <span>
                        <span class="src">
                            If in doubt, make
                            it a <code>class</code>.
                        </span>
                        迷ったら<code>class</code>にしましょう。
                    </span>
                </p>

                <p>
                    <span>
                        <span class="src">
                            For consistency with STL, you can use
                            <code>struct</code> instead of <code>class</code> for
                            functors and traits.
                        </span>
                        STLとの一貫性を持たせるため、ファンクタやtraitsについては、<code>struct</code>を使ってもかまいません。
                    </span>
                </p>

                <p>
                    <span>
                        <span class="src">
                            Note that member variables in structs and classes have
                            <a href="#Variable_Names">different naming rules</a>.
                        </span>
                        構造体とクラスでは、<a href="#Variable_Names">命名規則が異なる</a>ことに注意してください。
                    </span>
                </p>

            </div>

            <h3 id="Inheritance"><span title="Inheritance">継承</span></h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Composition is often more appropriate than inheritance.
                        </span>
                        しばしば、継承より抱合(コンポジション)の方が適切な場合もあります。
                    </span>
                    <span>
                        <span class="src">
                            When using inheritance, make it <code>public</code>.
                        </span>
                        継承を使うのであれば、必ず<code>public</code>にします。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        <span>
                            <span class="src">
                                When a sub-class
                                inherits from a base class, it includes the definitions
                                of all the data and operations that the parent base class
                                defines.
                            </span>
                            派生クラスが基底クラスから継承するとき、派生クラスは親となる基底クラスで定義されているすべてのデータと操作の定義を含むようになります。
                        </span>
                        <span>
                            <span class="src">
                                In practice, inheritance is used in two major
                                ways in C++: implementation inheritance, in which actual
                                code is inherited by the child, and
                                <a href="#Interfaces">interface inheritance</a>, in which
                                only method names are inherited.
                            </span>
                            実際には、C++の継承は2種類の方法があります。実際のコードが継承される「実装の継承」と、メソッド名だけが継承される「<a href="#Interfaces">インターフェースの継承</a>」です。
                        </span>
                    </p>
                </div>

                <div class="pros">
                    <p>
                        <span>
                            <span class="src">
                                Implementation inheritance reduces code size by re-using
                                the base class code as it specializes an existing type.
                            </span>
                            実装の継承は、基底クラスのコードを再利用するため、コードのサイズが小さくなります。
                        </span>
                        <span>
                            <span class="src">
                                Because inheritance is a compile-time declaration, you
                                and the compiler can understand the operation and detect
                                errors.
                            </span>
                            継承はコンパイル時の宣言であるため、コンパイラは操作を理解し、エラーを検出します。
                        </span>
                        <span>
                            <span class="src">
                                Interface inheritance can be used to
                                programmatically enforce that a class expose a particular
                                API.
                            </span>
                            インターフェースの継承は、プログラム的に、クラスが特定のAPIを公開することを強制するために使用します。
                        </span>
                        <span>
                            <span class="src">
                                Again, the compiler can detect errors, in this case,
                                when a class does not define a necessary method of the
                                API.
                            </span>
                            同様に、コンパイラは、クラスが必要なメソッドを定義していない場合に、それをエラーとして検出します。
                        </span>
                    </p>
                </div>

                <div class="cons">
                    <p>
                        <span>
                            <span class="src">
                                For implementation inheritance, because the code
                                implementing a sub-class is spread between the base and
                                the sub-class, it can be more difficult to understand an
                                implementation.
                            </span>
                            実装の継承においては、派生クラスの実装が基底クラスと派生クラスとの間に分離するため、実装を理解するのをより難しくするかもしれません。
                        </span>
                        <span>
                            <span class="src">
                                The sub-class cannot override functions
                                that are not virtual, so the sub-class cannot change
                                implementation.
                            </span>
                            派生クラスは、基底クラスでvirtualとして宣言されていないものをオーバーライドすることはできず、実装を変えることはできません。
                        </span>
                        <span>
                            <span class="src">
                                The base class may also define some data
                                members, so that specifies physical layout of the base
                                class.
                            </span>
                            また、基底クラスはデータメンバを定義しているかもしれず、それによって基底クラスの物理的なレイアウトも決まってしまいます。
                        </span>
                    </p>
                </div>

                <div class="decision">

                    <p>
                        <span>
                            <span class="src">
                                All inheritance should be <code>public</code>.
                            </span>
                            すべての継承は<code>public</code>で行います。
                        </span>
                        <span>
                            <span class="src">
                                If you
                                want to do private inheritance, you should be including
                                an instance of the base class as a member instead.
                            </span>
                            privateな継承を行いたい場合は、継承の代わりに基底クラスのインスタンスをメンバーとして持つようにしてください。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Do not overuse implementation inheritance.
                            </span>
                            実装の継承を使いすぎないでください。
                        </span>
                        <span>
                            <span class="src">
                                Composition
                                is often more appropriate.
                            </span>
                            抱合(コンポジション)の方が適切な場合もしばしばあります。
                        </span>
                        <span>
                            <span class="src">
                                Try to restrict use of
                                inheritance to the "is-a" case: <code>Bar</code>
                                subclasses <code>Foo</code> if it can reasonably be said
                                that <code>Bar</code> "is a kind of"
                                <code>Foo</code>.
                            </span>
                            継承は is-a 関係が成立する場合のみ使うようにしてください。
                            たとえば<code>Foo</code>を継承して<code>Bar</code>を作ってよいのは、理屈の上で「<code>Bar</code>は<code>Foo</code>の一種」といえる時だけです。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Make your destructor <code>virtual</code> if
                                necessary.
                            </span>
                            必要に応じてデストラクタは<code>virtual</code>にしてください。
                        </span>
                        <span>
                            <span class="src">
                                If your class has virtual methods, its
                                destructor should be virtual.
                            </span>
                            もし、クラスが仮想関数を持っているのであれば、デストラクタも仮想でなくてはなりません。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Limit the use of <code>protected</code> to those
                                member functions that might need to be accessed from
                                subclasses.
                            </span>
                            <code>protected</code>は、派生クラスからアクセスされるメンバ関数だけにとどめてください。
                        </span>
                        <span>
                            <span class="src">
                                Note that <a href="#Access_Control">
                                    data
                                    members should be private
                                </a>.
                            </span>
                            <a href="#Access_Control">データメンバはprivateとする</a>ようにしてください.
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Explicitly annotate overrides of virtual functions
                                or virtual destructors with an <code>override</code>
                                or (less frequently) <code>final</code> specifier.
                            </span>
                            オーバーライドする仮想関数や仮想デストラクタには、明示的に<code>override</code>あるいは<code>final</code>指定子をつけてください。
                        </span>
                        <span>
                            <span class="src">
                                Older (pre-C++11) code will use the
                                <code>virtual</code> keyword as an inferior
                                alternative annotation.
                            </span>
                            古い(C++11より前の)コードでは、劣っていますが代替として<code>virtual</code>キーワードをつけてください。
                        </span>
                        <span>
                            <span class="src">
                                For clarity, use exactly one of
                                <code>override</code>, <code>final</code>, or
                                <code>virtual</code> when declaring an override.
                            </span>
                            明快さのため、オーバーライドするときには、必ず<code>override</code>か<code>final</code>か
                            <code>virtual</code>のいずれかのキーワードを使用してください。
                        </span>
                        <span>
                            <span class="src">
                                Rationale: A function or destructor marked
                                <code>override</code> or <code>final</code> that is
                                not an override of a base class virtual function will
                                not compile, and this helps catch common errors.
                            </span>
                            <code>override</code>か<code>final</code>でマークされた関数やデスクトラクタは、基底クラスの仮想関数をオーバーライドしていないときにコンパイルできなくなるため、問題に気づきやすくなります。
                        </span>
                        <span>
                            <span class="src">
                                The
                                specifiers serve as documentation; if no specifier is
                                present, the reader has to check all ancestors of the
                                class in question to determine if the function or
                                destructor is virtual or not.
                            </span>
                            これらの指定子はドキュメントの役割も果たします。もし、指定子がない場合、コードの読者は関数やデストラクタが仮想なのかそうでないのかを解決するためには、すべての継承元をたどって調べなくてはならなくなります。
                        </span>
                    </p>
                </div>

            </div>

            <h3 id="Multiple_Inheritance"><span title="Multiple Inheritance">多重継承</span></h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Only very rarely is multiple implementation inheritance
                            actually useful.
                        </span>
                        実装の継承において、多重継承が有用なことはほとんどありません。
                    </span>
                    <span>
                        <span class="src">
                            We allow multiple inheritance only when at
                            most one of the base classes has an implementation; all
                            other base classes must be <a href="#Interfaces">
                                pure
                                interface
                            </a> classes tagged with the
                            <code>Interface</code> suffix.
                        </span>
                        多重継承の使用が認められるのは、基底クラスのうち実装を持つものが多くとも1つまでで、他の基底クラスはすべて
                        <code>Interface</code>接尾辞でタグ付けされた<a href="#Interfaces">純粋なインターフェース</a>クラスであるときにのみに限定されます。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        <span>
                            <span class="src">
                                Multiple inheritance allows a sub-class to have more than
                                one base class.
                            </span>
                            多重継承により、複数の基底クラスを持った派生クラスを作ることができます。
                        </span>
                        <span>
                            <span class="src">
                                We distinguish between base classes that are
                                <em>pure interfaces</em> and those that have an
                                <em>implementation</em>.
                            </span>
                            ここでは、基底クラスを<em>純粋インターフェース</em>と<em>実装</em>を持ったものに分類して考えます。
                        </span>
                    </p>
                </div>

                <div class="pros">
                    <p>
                        <span>
                            <span class="src">
                                Multiple implementation inheritance may let you re-use
                                even more code than single inheritance (see <a href="#Inheritance">Inheritance</a>).
                            </span>
                            実装の多重継承は、単一の継承よりもたくさんのコードを再利用できるかもしれません(参考:<a href="#Inheritance">継承</a>)。
                        </span>
                    </p>
                </div>

                <div class="cons">
                    <p>
                        <span>
                            <span class="src">
                                Only very rarely is multiple <em>implementation</em>
                                inheritance actually useful.
                            </span>
                            実際のところ、実装の多重継承が役に立つことはほとんどありません。
                        </span>
                        <span>
                            <span class="src">
                                When multiple implementation
                                inheritance seems like the solution, you can usually find
                                a different, more explicit, and cleaner solution.
                            </span>
                            多重継承が問題の答えに見えたとしても、たいていは、もっと明示的できれいな別の方法がきっとあるはずです。
                        </span>
                    </p>
                </div>

                <div class="decision">
                    <p>
                        <span>
                            <span class="src">
                                Multiple inheritance is allowed only when all
                                superclasses, with the possible exception of the first one,
                                are <a href="#Interfaces">pure interfaces</a>.
                            </span>
                            多重継承が認められるのは、1つめの基底クラスを除いて、他のすべての基底クラスが<a href="#Interfaces">純粋なインターフェース</a>であるときのみです。
                        </span>
                        <span>
                            <span class="src">
                                In order to
                                ensure that they remain pure interfaces, they must end with
                                the <code>Interface</code> suffix.
                            </span>
                            クラスが純粋インターフェースであることを保証するために、それらのクラスは<code>Interface</code>接尾辞を持っていなくてはなりません。
                        </span>
                    </p>
                </div>

                <div class="note">
                    <p>
                        <span>
                            <span class="src">
                                There is an <a href="#Windows_Code">exception</a> to
                                this rule on Windows.
                            </span>
                            このルールには<a href="#Windows_Code">Windowsに関する例外</a>があります。
                        </span>
                    </p>
                </div>

            </div>

            <h3 id="Interfaces"><span title="Interfaces">インターフェース</span></h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Classes that satisfy certain conditions are allowed, but
                            not required, to end with an <code>Interface</code> suffix.
                        </span>
                        いくつかの特定の条件を満たすクラスは、クラス名を<code>Interface</code>接尾辞で終わることができます(が、必須ではありません)。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        <span>
                            <span class="src">
                                A class is a pure interface if it meets the following
                                requirements:
                            </span>
                            クラスが次の要件を満たすとき、クラスは純粋なインターフェースであると言います。
                        </span>
                    </p>

                    <ul>
                        <li>
                            <span>
                                <span class="src">
                                    It has only public pure virtual ("<code>
                                        =
                                        0
                                    </code>") methods and static methods (but see below
                                    for destructor).
                                </span>
                                public な純粋仮想関数(<code> = 0</code>で宣言された関数)と、静的なメンバ関数(と次で説明するデストラクタ)しかもたない。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    It may not have non-static data members.
                                </span>
                                静的でないデータメンバを持たない。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    It need not have any constructors defined.
                                </span>
                                いかなるコンストラクタも定義されていない。
                            </span>
                            <span>
                                <span class="src">
                                    If a
                                    constructor is provided, it must take no arguments and
                                    it must be protected.
                                </span>
                                コンストラクタが定義されている場合は、引数をとらず、protectedでなくてはならない。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    If it is a subclass, it may only be derived from
                                    classes that satisfy these conditions and are tagged
                                    with the <code>Interface</code> suffix.
                                </span>
                                クラスが派生クラスである場合には、基底とするクラスが、これら同じ条件を満たしていて、かつ、<code>Interface</code>接尾辞でタグ付けされていなくてはならない。
                            </span>
                        </li>
                    </ul>

                    <p>
                        <span>
                            <span class="src">
                                An interface class can never be directly instantiated
                                because of the pure virtual method(s) it declares.
                            </span>
                            インターフェースクラスは、それ自身が純粋仮想関数を宣言しているため、直接インスタンス化されることはありません。
                        </span>
                        <span>
                            <span class="src">
                                To
                                make sure all implementations of the interface can be
                                destroyed correctly, the interface must also declare a
                                virtual destructor (in an exception to the first rule,
                                this should not be pure).
                            </span>
                            インターフェースの持つすべての実装が正しく破壊されることを保証するために、インターフェースは仮想デストラクタを宣言しなくてはなりません(これは、最初のルールに対する唯一の例外として、定義を持たなくてはなりません)。
                        </span>
                        <span>
                            <span class="src">
                                See Stroustrup, <cite>
                                    The C++
                                    Programming Language
                                </cite>, 3rd edition, section 12.4
                                for details.
                            </span>
                            詳細はStroustrup著 <cite>The C++ Programming Language</cite>, 3rd edition セクション 12.4 を参照してください。
                        </span>
                    </p>
                </div>

                <div class="pros">
                    <p>
                        <span>
                            <span class="src">
                                Tagging a class with the <code>Interface</code> suffix
                                lets others know that they must not add implemented
                                methods or non static data members.
                            </span>
                            クラスを<code>Interface</code>でタグ付けすることで、他のプログラマに対して、このクラスに実装や静的でないメンバ変数を追加してはならないということを伝えられます。
                        </span>
                        <span>
                            <span class="src">
                                This is particularly
                                important in the case of <a href="#Multiple_Inheritance">multiple inheritance</a>.
                            </span>
                            これは特に、<a href="#Multiple_Inheritance">多重継承</a>される場合において重要なことです。
                        </span>
                        <span>
                            <span class="src">
                                Additionally, the interface concept is already
                                well-understood by Java programmers.
                            </span>
                            加えて、インターフェースはJavaプログラマの間ではよく知られているコンセプトです。
                        </span>
                    </p>
                </div>

                <div class="cons">
                    <p>
                        <span>
                            <span class="src">
                                The <code>Interface</code> suffix lengthens the class
                                name, which can make it harder to read and understand.
                            </span>
                            <code>Interface</code>という接尾辞をつけると、クラス名が長くなり、読みにくく、理解にしくくなるかもしれません。
                        </span>
                        <span>
                            <span class="src">
                                Also, the interface property may be considered an
                                implementation detail that shouldn't be exposed to
                                clients.
                            </span>
                            また、インターフェースの性質は、クライアントに対して公開すべきでない実装の詳細であると考えることもできます。
                        </span>
                    </p>
                </div>

                <div class="decision">
                    <p>
                        <span>
                            <span class="src">
                                A class may end
                                with <code>Interface</code> only if it meets the above
                                requirements.
                            </span>
                            クラスが上記の要件を満たす場合は<code>Interface</code>接尾辞をつけることができます。
                        </span>
                        <span>
                            <span class="src">
                                We do not require the converse, however:
                                classes that meet the above requirements are not required
                                to end with <code>Interface</code>.
                            </span>
                            逆の要件はありません。つまり、上記の要件を満たすクラスが<code>Interface</code>接尾辞を持たなくてはならないということはありません。
                        </span>
                    </p>
                </div>

            </div>

            <h3 id="Operator_Overloading"><span title="Operator Overloading">演算子のオーバーロード</span></h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Overload operators judiciously.
                        </span>
                        演算子のオーバーロードは慎重に行わなくてはなりません。
                    </span>
                    <span>
                        <span class="src">
                            Do not create user-defined literals.
                        </span>
                        ユーザ定義のリテラルは作ってはいけません。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        <span>
                            <span class="src">
                                C++ permits user code to
                                <a href="http://en.cppreference.com/w/cpp/language/operators">
                                    declare
                                    overloaded versions of the built-in operators
                                </a> using the
                                <code>operator</code> keyword, so long as one of the parameters
                                is a user-defined type.
                            </span>
                            C++では、<code>operator</code>キーワードを使うことで、ユーザ定義の型を引数とした<a href="http://en.cppreference.com/w/cpp/language/operators">組み込み演算子のオーバーロードを宣言</a>することができます。
                        </span>
                        <span>
                            <span class="src">
                                The <code>operator</code> keyword also
                                permits user code to define new kinds of literals using
                                <code>operator""</code>, and to define type-conversion functions
                                such as <code>operator bool()</code>.
                            </span>
                            また、<code>operator</code>キーワードは、<code>operator""</code>を用いることで新しいリテラルを定義することもできます。<code>operator bool()</code>など、型変換を定義することもできます。
                        </span>
                    </p>
                </div>

                <div class="pros">
                    <p>
                        <span>
                            <span class="src">
                                Operator overloading can make code more concise and
                                intuitive by enabling user-defined types to behave the same
                                as built-in types.
                            </span>
                            演算子のオーバーロードは、ユーザ定義の型に組み込み型と同様の振る舞いをさせることができるようになるため、コードを簡潔で直感的にすることができます。
                        </span>
                        <span>
                            <span class="src">
                                Overloaded operators are the idiomatic names
                                for certain operations (e.g. <code>==</code>, <code>&lt;</code>,
                                <code>=</code>, and <code>&lt;&lt;</code>), and adhering to
                                those conventions can make user-defined types more readable
                                and enable them to interoperate with libraries that expect
                                those names.
                            </span>
                            オーバーロードされた演算子は、決まった操作に対して慣例に沿った名前を与えます(<code>==</code>や<code>&lt;</code>、<code>=</code>、<code>&lt;&lt;</code>など)。これらの慣例に従うことは、ユーザ定義の型に対する可読性を向上させ、それらの名前を期待しているライブラリとの相互運用性を高めることができます。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                User-defined literals are a very concise notation for
                                creating objects of user-defined types.
                            </span>
                            ユーザ定義のリテラルは、ユーザ定義のオブジェクトを生成する非常に賢明な記載方法です。
                        </span>
                    </p>
                </div>

                <div class="cons">
                    <ul>
                        <li>
                            <span>
                                <span class="src">
                                    Providing a correct, consistent, and unsurprising
                                    set of operator overloads requires some care, and failure
                                    to do so can lead to confusion and bugs.
                                </span>
                                正しい、一貫性を持った、よくある形の演算子のセットを提供するためには、細かな注意が必要となり、失敗すると、混乱やバグを引き起こしかねません。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Overuse of operators can lead to obfuscated code,
                                    particularly if the overloaded operator's semantics
                                    don't follow convention.
                                </span>
                                演算子の過剰な使用、特に、慣例に従わないような意味を演算子に持たせた場合、コードがわかりにくくなります。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    The hazards of function overloading apply just as
                                    much to operator overloading, if not more so.
                                </span>
                                関数のオーバーロードを行う場合と同様の危険性が、演算子のオーバーロードを行う場合にも当てはまります。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Operator overloads can fool our intuition into
                                    thinking that expensive operations are cheap, built-in
                                    operations.
                                </span>
                                演算子のオーバーロードは、本来高コストな処理を組み込み演算子のように低コストに見せかけてしまうことができます。このことは私たちの直感に反します。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Finding the call sites for overloaded operators may
                                    requre a search tool that's aware of C++ syntax, rather
                                    than e.g. grep.
                                </span>
                                オーバーロードされた演算子の呼び出し元を検索しようとする場合、grepでは要をなさず、C++の文法を理解するツールを使用する必要があります。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    If you get the argument type of an overloaded operator
                                    wrong, you may get a different overload rather than a
                                    compiler error.
                                </span>
                                オーバーロードされた演算子の引数の型を間違えたとき、単にコンパイルエラーになるのであればまだよいのですが、エラーにならず別の演算子の呼び出しに解決されてしまうかもしれません。
                            </span>
                            <span>
                                <span class="src">
                                    For example, <code>foo &lt; bar</code>
                                    may do one thing, while <code>&amp;foo &lt; &amp;bar</code>
                                    does something totally different.
                                </span>
                                たとえば、<code>foo &lt; bar</code>と<code>&amp;foo &lt; &amp;bar</code>はまったく意味の異なる演算です。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Certain operator overloads are inherently hazardous.
                                </span>
                                演算子の中には、オーバーロードすること自体に潜在的な危険性をはらんでいるものがあります。
                            </span>
                            <span>
                                <span class="src">
                                    Overloading unary <code>&amp;</code> can cause the same
                                    code to have different meanings depending on whether
                                    the overload declaration is visible.
                                </span>
                                単項演算子<code>&amp;</code>のオーバーロードは、その宣言が見えているかどうかで、意味が変わってしまうことになります。
                            </span>
                            <span>
                                <span class="src">
                                    Overloads of
                                    <code>&amp;&amp;</code>, <code>||</code>, and <code>,</code>
                                    (comma) cannot match the evaluation-order semantics of the
                                    built-in operators.
                                </span>
                                また、<code>&amp;&amp;</code>, <code>||</code>, and <code>,</code>(カンマ演算子)をオーバーロードした場合、組み込み演算子で定められている式の評価順序と一致させることはできません。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Operators are often defined outside the class,
                                    so there's a risk of different files introducing
                                    different definitions of the same operator.
                                </span>
                                オペレータはしばしばクラスの外で定義されますが、その場合、異なるファイルにある異なる定義を引き込んでしまう危険性があります。
                            </span>
                            <span>
                                <span class="src">
                                    If both
                                    definitions are linked into the same binary, this results
                                    in undefined behavior, which can manifest as subtle
                                    run-time bugs.
                                </span>
                                同じバイナリ内でそれらの実装の異なるオペレーターの両方がリンクされてしまった場合、未定義の動作を引き起こし、細かいバグを引き起こすことになるでしょう。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    User-defined literals allow the creation of new
                                    syntactic forms that are unfamiliar even to experienced C++
                                    programmers.
                                </span>
                                ユーザ定義のリテラルは、文法的に新しい形式を生み出しますが、それらは十分経験を積んだC++プログラマにとってさえ親しみの薄いものです。
                            </span>
                        </li>
                    </ul>
                </div>

                <div class="decision">
                    <p>
                        <span>
                            <span class="src">
                                Define overloaded operators only if their meaning is
                                obvious, unsurprising, and consistent with the corresponding
                                built-in operators.
                            </span>
                            演算子のオーバーロードを定義できるのは、意味が明らかであり、動作を予測可能であり、かつ、組み込み演算子との一貫性が保てる場合のみに限定します。
                        </span>
                        <span>
                            <span class="src">
                                For example, use <code>|</code> as a
                                bitwise- or logical-or, not as a shell-style pipe.
                            </span>
                            たとえば、<code>|</code>は、ビット和か論理和の意味でのみ使い、シェルでいうパイプのような意味では使いません。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Define operators only on your own types.
                            </span>
                            演算子は自分の型に対するもののみ定義してください。
                        </span>
                        <span>
                            <span class="src">
                                More precisely,
                                define them in the same headers, .cc files, and namespaces
                                as the types they operate on.
                            </span>
                            より厳密には、それらは型と同じヘッダか.ccファイル、そして型と同じ名前空間の中で定義してください。
                        </span>
                        <span>
                            <span class="src">
                                That way, the operators are available
                                wherever the type is, minimizing the risk of multiple
                                definitions.
                            </span>
                            そうすることで、型が利用可能なところでは演算子も利用できるようになり、演算子の多重定義に関するリスクを最小限にとどめることができます。
                        </span>
                        <span>
                            <span class="src">
                                If possible, avoid defining operators as templates,
                                because they must satisfy this rule for any possible template
                                arguments.
                            </span>
                            可能であれば、演算子をテンプレートとして定義するのは避けてください。テンプレートとして宣言された演算子は、取り得る限りすべてのテンプレート引数において、ここで述べているルールを満たさなくてはなりません。
                        </span>
                        <span>
                            <span class="src">
                                If you define an operator, also define
                                any related operators that make sense, and make sure they
                                are defined consistently.
                            </span>
                            ある演算子を定義する場合、関連するオペレータも定義し、必ず一貫性を持たせるようにしてください。
                        </span>
                        <span>
                            <span class="src">
                                For example, if you overload
                                <code>&lt;</code>, overload all the comparison operators,
                                and make sure <code>&lt;</code> and <code>&gt;</code> never
                                return true for the same arguments.
                            </span>
                            たとえば、<code>&lt;</code>をオーバーロードしたのであれば、すべての比較演算子をオーバーロードし、ある引数の組に対する比較演算<code>&lt;</code>と<code>&gt;</code>の結果が両方ともtrueになるようなことがないようにしてください。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Prefer to define non-modifying binary operators as
                                non-member functions.
                            </span>
                            引数に対して変更を伴わない二項演算子は、非メンバ関数として定義されることが好ましいです。
                        </span>
                        <span>
                            <span class="src">
                                If a binary operator is defined as a
                                class member, implicit conversions will apply to the
                                right-hand argument, but not the left-hand one.
                            </span>
                            仮に二項演算子がクラスのメンバとして定義された場合、演算子の右辺については暗黙的型変換を適用できますが、左辺には適用できなくなってしまいます。
                        </span>
                        <span>
                            <span class="src">
                                It will
                                confuse your users if <code>a &lt; b</code> compiles but
                                <code>b &lt; a</code> doesn't.
                            </span>
                            <code>a &lt; b</code>はコンパイルできるけど<code>b &lt; a</code>はコンパイルできないのような状況は、ユーザを混乱させることになります。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Don't go out of your way to avoid defining operator
                                overloads.
                            </span>
                            演算子のオーバーロードをわざわざ避けるようなことはしないでください。
                        </span>
                        <span>
                            <span class="src">
                                For example, prefer to define <code>==</code>,
                                <code>=</code>, and <code>&lt;&lt;</code>, rather than
                                <code>Equals()</code>, <code>CopyFrom()</code>, and
                                <code>PrintTo()</code>.
                            </span>
                            <code>Equals()</code>や<code>CopyFrom()</code>、<code>PrintTo()</code>などを実装するよりも、<code>==</code>、<code>=</code>、<code>&lt;&lt;</code>を定義するようにしましょう。
                        </span>
                        <span>
                            <span class="src">
                                Conversely, don't define
                                operator overloads just because other libraries expect
                                them.
                            </span>
                            逆に、他のライブラリを使いたいがためだけに演算子をオーバーロードすることは避けてください。
                        </span>
                        <span>
                            <span class="src">
                                For example, if your type doesn't have a natural
                                ordering, but you want to store it in a <code>std::set</code>,
                                use a custom comparator rather than overloading
                                <code>&lt;</code>.
                            </span>
                            たとえば、値同士の順序をつけられないのに、<code>std::set</code>に入れたいがためだけに<code>&lt;</code>をオーバーロードしてはいけません。このような型を<code>std::set</code>に入れたい場合は、カスタムの比較子(comparator)を使うようにします。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Do not overload <code>&amp;&amp;</code>, <code>||</code>,
                                <code>,</code> (comma), or unary <code>&amp;</code>.
                            </span>
                            演算子<code>&amp;&amp;</code>と<code>||</code>と<code>,</code> (カンマ演算子)、単項演算子<code>&amp;</code>はオーバーロードをしてはいけません。
                        </span>
                        <span>
                            <span class="src">
                                Do not overload
                                <code>operator""</code>, i.e. do not introduce user-defined
                                literals.
                            </span>
                            また、<code>operator""</code>のオーバーロードもしてはいけません。つまり、ユーザ定義リテラルを導入してはいけません。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Type conversion operators are covered in the section on
                                <a href="#Implicit_Conversions">implicit conversions</a>.
                            </span>
                            型変換演算子については<a href="#Implicit_Conversions">暗黙的型変換</a>のセクションでカバーします。
                        </span>
                        <span>
                            <span class="src">
                                The <code>=</code> operator is covered in the section on
                                <a href="#Copy_Constructors">copy constructors</a>.
                            </span>
                            <code>=</code>演算子は<a href="#Copy_Constructors">コピーコンストラクタ</a>のセクションでカバーします。
                        </span>
                        <span>
                            <span class="src">
                                Overloading
                                <code>&lt;&lt;</code> for use with streams is covered in the
                                section on <a href="#Streams">streams</a>.
                            </span>
                            <code>&lt;&lt;</code>をストリーム用途で使うオーバーロードについては、<a href="#Streams">ストリーム</a>でカバーします。
                        </span>
                        <span>
                            <span class="src">
                                See also the rules on
                                <a href="#Function_Overloading">function overloading</a>, which
                                apply to operator overloading as well.
                            </span>
                            そのほか、演算子のオーバーロードは<a href="#Function_Overloading">関数のオーバーロード</a>にあるルールも同様に適用されますので、あわせてそちらも参照してください。
                        </span>
                    </p>
                </div>

            </div>

            <h3 id="Access_Control"><span title="Access Control">アクセス制限</span></h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Make data members <code>private</code>, unless they are
                            <code>static const</code> (and follow the <a href="#Constant_Names">
                                naming convention for constants
                            </a>).
                        </span>
                        データメンバーは<code>private</code>としてください。
                        ただし、<code>static const</code>であるもの(<a href="#Constant_Names">定数に関する命名規則</a>も参照)を除きます。
                    </span>
                    <span>
                        <span class="src">
                            For technical
                            reasons, we allow data members of a test fixture class to
                            be <code>protected</code> when using
                            <a href="https://github.com/google/googletest">
                                Google
                                Test
                            </a>).
                        </span>
                        技術的な理由により、<a href="https://github.com/google/googletest">Google Test</a>を使う場合のテスト用のクラスのデータメンバは<code>protected</code>であってもよいとします。
                    </span>
                </p>
            </div>

            <h3 id="Declaration_Order"><span title="Declaration Order">宣言の順序</span></h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Group similar declarations together, placing public parts
                            earlier.
                        </span>
                        似ている宣言は1つにまとめ、public部分の先の方に置きます。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <p>
                    <span>
                        <span class="src">
                            A class definition should usually start with a
                            <code>public:</code> section, followed by
                            <code>protected:</code>, then <code>private:</code>.
                        </span>
                        クラスの定義は、通常は<code>public:</code>セクションから始め、<code>protected:</code>、<code>private:</code>と続けます。
                    </span>
                    <span>
                        <span class="src">
                            Omit
                            sections that would be empty.
                        </span>
                        空になるセクションは省略してください。
                    </span>
                </p>

                <p>
                    <span>
                        <span class="src">
                            Within each section, generally prefer grouping similar
                            kinds of declarations together, and generally prefer the
                            following order: types (including <code>typedef</code>,
                            <code>using</code>, and nested structs and classes),
                            constants, factory functions, constructors, assignment
                            operators, destructor, all other methods, data members.
                        </span>
                        各セクションにおいて、似た宣言は1カ所にまとるようにしましょう。また、順序は、型(<code>typedef</code>、<code>using</code>、内部構造体・クラスを含む)、定数、ファクトリ関数、コンストラクタ、代入演算子、デストラクタ、それ以外のすべてのメソッド、データメンバ の順となるようにしましょう。
                    </span>
                </p>

                <p>
                    <span>
                        <span class="src">
                            Do not put large method definitions inline in the
                            class definition.
                        </span>
                        クラス定義の中では、大きなメソッドの定義をインラインで行わないでください。
                    </span>
                    <span>
                        <span class="src">
                            Usually, only trivial or
                            performance-critical, and very short, methods may be
                            defined inline.
                        </span>
                        通常は、ささいな関数、パフォーマンス的に重要な関数、非常に短い関数のみがインラインで定義されます。
                    </span>
                    <span>
                        <span class="src">
                            See <a href="#Inline_Functions">
                                Inline
                                Functions
                            </a> for more details.
                        </span>
                        詳細は<a href="#Inline_Functions">インライン関数</a>で述べます。
                    </span>
                </p>

            </div>

            <h2 id="Functions"><span title="Functions">関数</span></h2>

            <h3 id="Function_Parameter_Ordering"><span title="Parameter Ordering">引数の順序</span></h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            When defining a function, parameter order is: inputs, then
                            outputs.
                        </span>
                        関数を定義するときの引数の順序は入力が先、出力が後とします。
                    </span>
                </p>
            </div>

            <div class="stylebody">
                <p>
                    <span>
                        <span class="src">
                            Parameters to C/C++ functions are either input to the
                            function, output from the function, or both.
                        </span>
                        C/C++の関数に渡される引数は、関数への入力であるか、関数への出力であるか、あるいはその両方です。
                    </span>
                    <span>
                        <span class="src">
                            Input
                            parameters are usually values or <code>const</code>
                            references, while output and input/output parameters will
                            be pointers to non-<code>const</code>.
                        </span>
                        入力となる引数は、通常は、値渡しか、<code>const</code>参照渡しです。一方で出力となる引数、あるいは入力と出力の両方となる引数は、非<code>const</code>なポインタとなります。
                    </span>
                    <span>
                        <span class="src">
                            When ordering
                            function parameters, put all input-only parameters before
                            any output parameters.
                        </span>
                        引数の順番を決めるときは、入力のみに使われる引数を、いかなる出力の引数よりも前に配置します。
                    </span>
                    <span>
                        <span class="src">
                            In particular, do not add new
                            parameters to the end of the function just because they
                            are new; place new input-only parameters before the
                            output parameters.
                        </span>
                        特に、新しい引数を追加するときは、新しいからという理由だけで関数の最後に追加してはいけません。新しく追加する引数が入力のための引数であるのならば、それは出力引数の前に配置します。
                    </span>
                </p>

                <p>
                    <span>
                        <span class="src">
                            This is not a hard-and-fast rule.
                        </span>
                        これは絶対のルールではありません。
                    </span>
                    <span>
                        <span class="src">
                            Parameters that are
                            both input and output (often classes/structs) muddy the
                            waters, and, as always, consistency with related
                            functions may require you to bend the rule.
                        </span>
                        入力と出力の両方の役割を持つ引数(大抵はクラスや構造体)が存在する場合は、明確な線引きはできません。また、関連する関数との一貫性を保つためにはこのルールを曲げなくてはならないかもしれません。
                    </span>
                </p>

            </div>

            <h3 id="Write_Short_Functions"><span title="Write Short Functions">関数は短く</span></h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Prefer small and focused functions.
                        </span>
                        関数は、短く、焦点を絞ったものにしましょう。
                    </span>
                </p>
            </div>

            <div class="stylebody">
                <p>
                    <span>
                        <span class="src">
                            We recognize that long functions are sometimes
                            appropriate, so no hard limit is placed on functions
                            length.
                        </span>
                        時には長い関数の方が適切なこともあるため、関数の長さに関する固定の限界値は定めません。
                    </span>
                    <span>
                        <span class="src">
                            If a function exceeds about 40 lines, think about
                            whether it can be broken up without harming the structure
                            of the program.
                        </span>
                        だいたい40行程度を超えるようであれば、プログラムの構造を破壊することなく関数を分割できないか考えてみてください。
                    </span>
                </p>

                <p>
                    <span>
                        <span class="src">
                            Even if your long function works perfectly now,
                            someone modifying it in a few months may add new
                            behavior.
                        </span>
                        長い関数が、現時点では完璧に動いていたとしても、1～2ヶ月後に誰かがそれを変更し、新しい動作を足すかもしれません。
                    </span>
                    <span>
                        <span class="src">
                            This could result in bugs that are hard to
                            find.
                        </span>
                        その結果として見つけるのが困難なバグを引き起こすかもしれません。
                    </span>
                    <span>
                        <span class="src">
                            Keeping your functions short and simple makes it
                            easier for other people to read and modify your code.
                        </span>
                        関数を短くシンプルであるように保つことで、コードをより読みやすく、より変更しやすくできるのです。
                    </span>
                </p>

                <p>
                    <span>
                        <span class="src">
                            You could find long and complicated functions when
                            working with
                            some code.
                        </span>
                        作業をしていると、長い複雑なコードに出くわすこともあるでしょう。
                    </span>
                    <span>
                        <span class="src">
                            Do not be
                            intimidated by modifying existing code: if working with
                            such a function proves to be difficult, you find that
                            errors are hard to debug, or you want to use a piece of
                            it in several different contexts, consider breaking up
                            the function into smaller and more manageable pieces.
                        </span>
                        既存のコードを変更することにおびえてはいけません。
                        そのコードを使って仕事を進めることが困難であることがわかった場合、エラーのデバッグが難しいことがわかった場合、あるいは別の文脈においてその関数の一部分だけを切り出して使いたくなった場合、関数をより小さく扱いやすい複数の断片に分割することを検討してください。
                    </span>
                </p>

            </div>

            <h3 id="Reference_Arguments"><span title="Reference Arguments">参照渡し</span></h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            All parameters passed by reference must be labeled
                            <code>const</code>.
                            参照渡しされる引数は必ず<code>const</code>でなくてはなりません。
                        </span>
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        <span>
                            <span class="src">
                                In C, if a
                                function needs to modify a variable, the parameter must
                                use a pointer, eg <code>int foo(int *pval)</code>.
                            </span>
                            C言語において、関数が変数を変更する必要があるときは、引数にポインタを使わなくてはなりません(例: <code>int foo(int *pval)</code>)。
                        </span>
                        <span>
                            <span class="src">
                                In
                                C++, the function can alternatively declare a reference
                                parameter: <code>int foo(int &amp;val)</code>.
                            </span>
                            C++においては、他の方法として、参照渡しを使って関数を宣言することもできます(例:<code>int foo(int &amp;val)</code>)。
                        </span>
                    </p>
                </div>

                <div class="pros">
                    <p>
                        <span>
                            <span class="src">
                                Defining a parameter as reference avoids ugly code like
                                <code>(*pval)++</code>.
                            </span>
                            引数を参照にすることで、<code>(*pval)++</code>のような醜いコードを避けられます。
                        </span>
                        <span>
                            <span class="src">
                                Necessary for some applications
                                like copy constructors.
                            </span>
                            参照渡しは、コピーコンストラクタなど、それを必要する場面があります。
                        </span>
                        <span>
                            <span class="src">
                                Makes it clear, unlike with
                                pointers, that a null pointer is not a possible
                                value.
                            </span>
                            参照渡しは、ポインタと違って、ヌルポインタが渡せないことが明確になります。
                        </span>
                    </p>
                </div>

                <div class="cons">
                    <p>
                        <span>
                            <span class="src">
                                References can be confusing, as they have value syntax
                                but pointer semantics.
                            </span>
                            参照は、値型と同じ文法のまま、ポインタと同じような意味を持つため、混乱しやすいです。
                        </span>
                    </p>
                </div>

                <div class="decision">
                    <p>
                        <span>
                            <span class="src">
                                Within function parameter lists all references must be
                                <code>const</code>:
                            </span>
                            関数の引数リストにおいては、以下の例のように、すべての参照は<code>const</code>でなくてはなりません。
                        </span>
                    </p>

<pre>void Foo(const string &amp;in, string *out);
</pre>

                    <p>
                        <span>
                            <span class="src">
                                In fact it is a very strong convention in Google code
                                that input arguments are values or <code>const</code>
                                references while output arguments are pointers.
                            </span>
                            実際、入力引数が値渡しか<code>const</code>参照であり、出力引数がポインタであるということは、Googleのコードにおいて非常に強いしきたりになっています。
                        </span>
                        <span>
                            <span class="src">
                                Input
                                parameters may be <code>const</code> pointers, but we
                                never allow non-<code>const</code> reference parameters
                                except when required by convention, e.g.,
                                <code>swap()</code>.
                            </span>
                            入力引数に<code>const</code>ポインタが使われることはありますが、非<code>const</code>な参照は、<code>swap()</code>のような習慣的な要求がある場合を除いて、認められることはありません。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                However, there are some instances where using
                                <code>const T*</code> is preferable to <code>
                                    const
                                    T&amp;
                                </code> for input parameters.
                            </span>
                            入力引数に<code>const T&amp;</code>より<code>const T*</code> を使う方がよい場面もあります。
                        </span>
                        <span>
                            <span class="src">
                                For example:
                            </span>
                            たとえば、
                        </span>
                    </p>

                    <ul>
                        <li>
                            <span>
                                <span class="src">
                                    You want to pass in a null pointer.
                                </span>
                                ヌルポインタを渡したいとき や
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    The function saves a pointer or reference to the
                                    input.
                                </span>
                                関数が入力にポインタか参照を保存したいとき です。
                            </span>
                        </li>
                    </ul>

                    <p>
                        <span>
                            <span class="src">
                                Remember that most of the time input
                                parameters are going to be specified as <code>
                                    const
                                    T&amp;
                                </code>.
                                ほとんどの場合、入力引数は<code>const T&amp;</code>のように特殊化されます。
                            </span>
                        </span>
                        <span>
                            <span class="src">
                                Using <code>const T*</code> instead
                                communicates to the reader that the input is somehow
                                treated differently.
                            </span>
                            <code>const T*</code>という表現を使うことは、コードの読者に、ここでは入力に対して何かしら普段と違う扱い方をしますよと伝えていることになります。
                        </span>
                        <span>
                            <span class="src">
                                So if you choose <code>
                                    const
                                    T*
                                </code> rather than <code>const T&amp;</code>, do so
                                for a concrete reason; otherwise it will likely confuse
                                readers by making them look for an explanation that
                                doesn't exist.
                            </span>
                            あなたが、<code>const T&amp;</code>ではなく、<code>const T*</code>を選ぶときは具体的な理由が必要です。さもなくば、コードの読者が、(ポインタを使っている)ありもしない理由を探そうとしてしまうかもしれず、混乱を招くかもしれません。
                        </span>
                    </p>
                </div>

            </div>

            <h3 id="Function_Overloading"><span title="Function Overloading">関数のオーバーロード</span></h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Use overloaded functions (including constructors) only if a
                            reader looking at a call site can get a good idea of what
                            is happening without having to first figure out exactly
                            which overload is being called.
                        </span>
                        コンストラクタを含む関数のオーバーロードは、コードの読者が、その呼び出し元を読んだときに、具体的にどのオーバーロードが呼び出されるか正確に把握していなくとも、何が起こるか理解できるであろう場合にのみ使用できます。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        <span>
                            <span class="src">
                                You may write a function that takes a <code>
                                    const
                                    string&amp;
                                </code> and overload it with another that
                                takes <code>const char*</code>.
                            </span>
                            <code>const string&amp;</code>を引数にとる関数と、<code>const char*</code>を引数にとるオーバーロードとを書くことができます。
                        </span>
                    </p>

<pre>class MyClass {
 public:
  void Analyze(const string &amp;text);
  void Analyze(const char *text, size_t textlen);
};
</pre>
                </div>

                <div class="pros">
                    <p>
                        <span>
                            <span class="src">
                                Overloading can make code more intuitive by allowing an
                                identically-named function to take different arguments.
                            </span>
                            オーバーロードによって、同一名の関数に異なる引数をとらせることができるため、コードがより直感的になります。
                        </span>
                        <span>
                            <span class="src">
                                It may be necessary for templatized code, and it can be
                                convenient for Visitors.
                            </span>
                            この機能は、テンプレート化されたコードにおいて必要とされ、また、ビジターパターンにおいても有用となるでしょう。
                        </span>
                    </p>
                </div>

                <div class="cons">
                    <p>
                        <span>
                            <span class="src">
                                If a function is overloaded by the argument types alone,
                                a reader may have to understand C++'s complex matching
                                rules in order to tell what's going on.
                            </span>
                            ある関数が引数の型だけでオーバーロードされている場合、コードの読者がそこで実際に起きることを知るためには、C++の複雑なマッチングルールについて理解していなくてはなりません。
                        </span>
                        <span>
                            <span class="src">
                                Also many people
                                are confused by the semantics of inheritance if a derived
                                class overrides only some of the variants of a
                                function.
                            </span>
                            また、複数のオーバーロードを持つ仮想関数を、派生先で部分的にオーバーライドした場合の挙動は、多くの人を困惑させています。
                        </span>
                    </p>
                </div>

                <div class="decision">
                    <p>
                        <span>
                            <span class="src">
                                If you want to overload a function, consider qualifying
                                the name with some information about the arguments, e.g.,
                                <code>AppendString()</code>, <code>AppendInt()</code>
                                rather than just <code>Append()</code>.
                            </span>
                            関数をオーバーロードしたくなったら、まずは名前に引数の情報をつける(たとえば、<code>Append()</code>の代わりに、<code>AppendString()</code>や<code>AppendInt()</code>とする)やり方を検討してください。
                        </span>
                        <span>
                            <span class="src">
                                If you are
                                overloading a function to support variable number of
                                arguments of the same type, consider making it take a
                                <code>std::vector</code> so that the user can use an
                                <a href="#Braced_Initializer_List">
                                    initializer list
                                </a> to specify the arguments.
                            </span>
                            また、型は同一でも、その型の引数をいくつとるかによってオーバーロードを定義したいときは、<code>std::vector</code>を引数にとるようにするやり方を検討してください。その方法ならば、ユーザは<a href="#Braced_Initializer_List">初期化子リスト</a>の形で引数を渡せます。
                        </span>
                    </p>
                </div>

            </div>

            <h3 id="Default_Arguments"><span title="Default Arguments">引数のデフォルト値</span></h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Default arguments are allowed on non-virtual functions
                            when the default is guaranteed to always have the same
                            value.
                        </span>
                        引数にデフォルトの値を与えられるのは、その関数が仮想関数ではなく、かつ、値が常に同じ値になることを保証できる場合に限ります。
                    </span>
                    <span>
                        <span class="src">
                            Follow the same restrictions as for <a href="#Function_Overloading">function overloading</a>, and
                            prefer overloaded functions if the readability gained with
                            default arguments doesn't outweigh the downsides below.
                        </span>
                        <a href="#Function_Overloading">関数のオーバーロード</a>と同様の制限に従ってください。また、引数にデフォルト値を与えることによって得られる可読性よりも、以下に述べるマイナス面の方が勝る場合、代わりに関数のオーバーロードを使いましょう。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <div class="pros">
                    <p>
                        <span>
                            <span class="src">
                                Often you have a function that uses default values, but
                                occasionally you want to override the defaults.
                            </span>
                            普段はデフォルトの値で使っている関数でも、時々別の値に変えて呼び出したくなることがあります。
                        </span>
                        <span>
                            <span class="src">
                                Default
                                parameters allow an easy way to do this without having to
                                define many functions for the rare exceptions.
                            </span>
                            引数にデフォルト値を与えることは、このような"時々"のための関数をたくさん定義することなく、簡単にやりたいことを実現するための手段の一つです。
                        </span>
                        <span>
                            <span class="src">
                                Compared
                                to overloading the function, default arguments have a
                                cleaner syntax, with less boilerplate and a clearer
                                distinction between 'required' and 'optional'
                                arguments.
                            </span>
                            関数のオーバーロードと比較して、このやり方は、文法的にきれいで、より少ない例で済み、さらに、引数が必須か任意かをより明確に区別できるようにもなります。
                        </span>
                    </p>
                </div>

                <div class="cons">
                    <p>
                        <span>
                            <span class="src">
                                Defaulted arguments are another way to achieve the
                                semantics of overloaded functions, so all the <a href="#Function_Overloading">
                                    reasons not to overload
                                    functions
                                </a> apply.
                            </span>
                            引数にデフォルト値を与える方法は、関数のオーバーロードでできることを実現する別の方法でもあるため、すべての<a href="#Function_Overloading">関数をオーバーロードしない理由</a>を適用します。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                The defaults for arguments in a virtual function call are
                                determined by the static type of the target object, and
                                there's no guarantee that all overrides of a given function
                                declare the same defaults.
                            </span>
                            仮想関数呼び出しにおける引数のデフォルト値は、オブジェクトの静的な型に基づいて決定されますが、その関数のすべてのオーバーライドが、同じデフォルト値とともに宣言されている保証はどこにもありません。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Default parameters are re-evaluated at each call site,
                                which can bloat the generated code.
                            </span>
                            引数のデフォルト値は、呼び出されるごとに評価されるため、生成されるコードの量がふくれます。
                        </span>
                        <span>
                            <span class="src">
                                Readers may also expect
                                the default's value to be fixed at the declaration instead
                                of varying at each call.
                            </span>
                            また、コードの読者は、関数が呼び出されるたびにデフォルト値が変わるのではなく、宣言時点で決まった値に固定されていることを期待するかもしれません。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Function pointers are confusing in the presence of
                                default arguments, since the function signature often
                                doesn't match the call signature.
                            </span>
                            関数ポインタを引数のデフォルト値として与えると混乱の元になります。関数のシグネチャはしばしば、呼び出す際のシグネチャと一致しないことがあるからです。
                        </span>
                        <span>
                            <span class="src">
                                Adding
                                function overloads avoids these problems.
                            </span>
                            関数のオーバーロードであれば、これらの問題は回避することができます。
                        </span>
                    </p>
                </div>

                <div class="decision">
                    <p>
                        <span>
                            <span class="src">
                                Default arguments are banned on virtual functions, where
                                they don't work properly, and in cases where the specified
                                default might not evaluate to the same value depending on
                                when it was evaluated.
                            </span>
                            仮想関数における引数にデフォルト値を与えても、それらは意図した通りに動作しないため禁止とします。また、デフォルト値が評価のタイミングによって必ず同じ値にならない場合についても禁止とします。
                        </span>
                        <span>
                            <span class="src">
                                (For example, don't write <code>
                                    void
                                    f(int n = counter++);
                                </code>.)
                            </span>
                            (たとえば、次のように書いてはいけません: <code>void f(int n = counter++);</code>)
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                In some other cases, default arguments can improve the
                                readability of their function declarations enough to
                                overcome the downsides above, so they are allowed.
                            </span>
                            その他のいくつかの場合において、引数にデフォルト値を与えることで、ここまで述べた悪い点を差し引いても十分に関数宣言の可読性を高めることができる場合があります。このとき、それらの使用が認められます。
                        </span>
                        <span>
                            <span class="src">
                                When in
                                doubt, use overloads.
                            </span>
                            迷ったときは関数のオーバーロードを選択します。
                        </span>
                    </p>
                </div>

            </div>

            <h3 id="trailing_return"><span title="Trailing Return Type Syntax">戻り値の型を後置する関数宣言構文</span></h3>
            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Use trailing return types only where using the ordinary syntax (leading
                            return types) is impractical or much less readable.
                        </span>
                        戻り値の型を後置する関数宣言構文は、普通の構文(戻り値の型から始まる構文)を使うことができない場合か、普通の構文では可読性に劣ってしまう場合にのみ使用します。
                    </span>
                </p>
            </div>

            <div class="definition">
                <p>
                    <span>
                        <span class="src">
                            C++ allows two different forms of function declarations.
                        </span>
                        C++では、2種類の異なる関数宣言の構文が認められています。
                    </span>
                    <span>
                        <span class="src">
                            In the older
                            form, the return type appears before the function name. For example:
                        </span>
                        古い形では、次の例のように、戻り値の型が関数名より先にきます。
                    </span>
                </p>
<pre>int foo(int x);
</pre>
                <p>
                    <span>
                        <span class="src">
                            The new form, introduced in C++11, uses the <code>auto</code>
                            keyword before the function name and a trailing return type after
                            the argument list.
                        </span>
                        C++で導入された新しい形は、<code>auto</code>キーワードを関数名の前に置き、戻り値の型を引数リストの後に置きます。
                    </span>
                    <span>
                        <span class="src">
                            For example, the declaration above could
                            equivalently be written:
                        </span>
                        例として、先ほどの宣言と等価な宣言は次のようになります。
                    </span>
                </p>
<pre>auto foo(int x) -&gt; int;
</pre>
                <p>
                    <span>
                        <span class="src">
                            The trailing return type is in the function's scope.
                        </span>
                        この戻り値の型は関数内スコープとなります。
                    </span>
                    <span>
                        <span class="src">
                            This doesn't
                            make a difference for a simple case like <code>int</code> but it matters
                            for more complicated cases, like types declared in class scope or
                            types written in terms of the function parameters.
                        </span>
                        <code>int</code>のように単純な場合はこれらに違いはありませんが、型がより複雑な場合にはこれは重要となってきます。
                        たとえば、型がクラススコープで宣言されている場合や、型が関数の引数によって決まったりする場合です。
                    </span>
                </p>
            </div>

            <div class="stylebody">
                <div class="pros">
                    <p>
                        <span>
                            <span class="src">
                                Trailing return types are the only way to explicitly specify the
                                return type of a <a href="#Lambda_expressions">lambda expression</a>.
                            </span>
                            戻り値の型を後置する構文は、<a href="#Lambda_expressions">ラムダ式</a>の戻り値の型を明示できる唯一の方法です。
                        </span>
                        <span>
                            <span class="src">
                                In some cases the compiler is able to deduce a lambda's return type,
                                but not in all cases.
                            </span>
                            コンパイラはラムダ式の戻り値の型を推論できる場合がありますが、常にそれができるわけではありません。
                        </span>
                        <span>
                            <span class="src">
                                Even when the compiler can deduce it automatically,
                                sometimes specifying it explicitly would be clearer for readers.
                            </span>
                            コンパイラが自動的に型を推論できる場合であっても、型を明示することでコードの可読性を向上させる場合もあります。
                        </span>
                    </p>
                    <p>
                        <span>
                            <span class="src">
                                Sometimes it's easier and more readable to specify a return type
                                after the function's parameter list has already appeared.
                            </span>
                            時に、戻り値の型を関数の引数の後ろに明示することで、より簡単で可読性が高くなることがあります。
                        </span>
                        <span>
                            <span class="src">
                                This is
                                particularly true when the return type depends on template parameters.
                            </span>
                            特に、戻り値の型がテンプレートパラメータによって決まる場合にはこのことが言えます。
                        </span>
                        <span>
                            <span class="src">
                                For example:
                            </span>
                            次の例を見てください。
                        </span>
                    </p>
                    <pre>template &lt;class T, class U&gt; auto add(T t, U u) -&gt; decltype(t + u);</pre>
                    <span>
                        <span class="src">
                            versus
                        </span>
                        対
                    </span>
                    <pre>template &lt;class T, class U&gt; decltype(declval&lt;T&amp;&gt;() + declval&lt;U&amp;&gt;()) add(T t, U u);</pre>
                </div>

                <div class="cons">
                    <p>
                        <span>
                            <span class="src">
                                Trailing return type syntax is relatively new and it has no
                                analogue in C++-like languages like C and Java, so some readers may
                                find it unfamiliar.
                            </span>
                            戻り値の型を後置する構文は、比較的新しく、C++系言語(C言語やJavaなど)には類似の構文がありません。このため、コードの読者にとってなじみが薄いかもしれません。
                        </span>
                    </p>
                    <p>
                        <span>
                            <span class="src">
                                Existing code bases have an enormous number of function
                                declarations that aren't going to get changed to use the new syntax,
                                so the realistic choices are using the old syntax only or using a mixture
                                of the two.
                            </span>
                            既存のコードベースには既に膨大な数の関数宣言があり、それらが新しい構文に替わることはないでしょう。このため、現実的には、古い構文と新しい構文との両方を混合させて使っていくという道を選択することになります。
                        </span>
                        <span>
                            <span class="src">
                                Using a single version is better for uniformity of style.
                            </span>
                            スタイルの一様性のためには、1種類だけを使うことが好ましいです。
                        </span>
                    </p>
                </div>

                <div class="decision">
                    <p>
                        <span>
                            <span class="src">
                                In most cases, continue to use the older style of function
                                declaration where the return type goes before the function name.
                            </span>
                            ほとんどの場合において、旧来からある、戻り値の型が関数名より先に来る関数宣言の構文を使い続けてください。
                        </span>
                        <span>
                            <span class="src">
                                Use the new trailing-return-type form only in cases where it's
                                required (such as lambdas) or where, by putting the type after the
                                function's parameter list, it allows you to write the type in a much
                                more readable way.
                            </span>
                            新しい構文を使用してよいのは、それがどうしても必要な場合(ラムダ式のような)と、引数のリストの後ろに戻り値の型を置くことで可読性を大きく向上させられる場合に限定します。
                        </span>
                        <span>
                            <span class="src">
                                The latter case should be rare; it's mostly an
                                issue in fairly complicated template code, which is
                                <a href="#Template_metaprogramming">discouraged in most cases</a>.
                            </span>
                            後者の状況はまれです。というのも、大抵、複雑すぎるテンプレートのコードが問題なのであって、<a href="#Template_metaprogramming">それらのほとんどは解消できる</a>からです。
                        </span>
                    </p>
                </div>
            </div>

            <h2 id="Google-Specific_Magic"><span title="Google-Specific Magic">Google特有のマジック</span></h2>



            <p>
                <span>
                    <span class="src">
                        There are various tricks and utilities that
                        we use to make C++ code more robust, and various ways we use
                        C++ that may differ from what you see elsewhere.
                    </span>
                    我々はC++のコードをより堅牢にするためのトリックやユーティリティを使用しています。
                    我々が使用する様々な手法は、一般的に見られるC++の使い方とは異なっているかもしれません。
                </span>
            </p>



            <h3 id="Ownership_and_Smart_Pointers"><span title="Ownership and Smart Pointers">スマートポインタの所有権</span></h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Prefer to have single, fixed owners for dynamically
                            allocated objects.
                        </span>
                        動的に確保されるオブジェクトの所有者は、単一かつ固定されるようにしましょう。
                    </span>
                    <span>
                        <span class="src">
                            Prefer to transfer ownership with smart
                            pointers.
                        </span>
                        オブジェクトの所有権を移すときは、スマートポインタを使用しましょう。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        <span>
                            <span class="src">
                                "Ownership" is a bookkeeping technique for managing
                                dynamically allocated memory (and other resources).
                            </span>
                            "所有権"は、動的に確保されるメモリ(や他のリソース)を管理するための帳簿的なテクニックの一つです。
                        </span>
                        <span>
                            <span class="src">
                                The
                                owner of a dynamically allocated object is an object or
                                function that is responsible for ensuring that it is
                                deleted when no longer needed.
                            </span>
                            動的に確保されるオブジェクトの所有者は、1つのオブジェクトか関数であり、オブジェクトが不要になったときにそれを解放する責任を負います。
                        </span>
                        <span>
                            <span class="src">
                                Ownership can sometimes be
                                shared, in which case the last owner is typically
                                responsible for deleting it.
                            </span>
                            所有権は時には共有されることもあります。その場合、一般的に最後の所有者が解放の責任を負います。
                        </span>
                        <span>
                            <span class="src">
                                Even when ownership is not
                                shared, it can be transferred from one piece of code to
                                another.
                            </span>
                            所有権は、共有まではされない場合でも、あるコードから他のコードへと移されることがあります。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                "Smart" pointers are classes that act like pointers,
                                e.g. by overloading the <code>*</code> and
                                <code>-&gt;</code> operators.
                            </span>
                            "スマート"ポインタとは、ポインタのように振る舞うクラスです(たとえば演算子<code>*</code>と<code>-&gt;</code>をオーバーロードしています)。
                        </span>
                        <span>
                            <span class="src">
                                Some smart pointer types
                                can be used to automate ownership bookkeeping, to ensure
                                these responsibilities are met.
                            </span>
                            いくつかのスマートポインタは、このような解放の責任を確実にするための所有権管理を自動的に行うために使われるものがあります。
                        </span>
                        <span>
                            <span class="src">
                                <a href="http://en.cppreference.com/w/cpp/memory/unique_ptr">
                                    <code>std::unique_ptr</code>
                                </a> is a smart pointer type
                                introduced in C++11, which expresses exclusive ownership
                                of a dynamically allocated object; the object is deleted
                                when the <code>std::unique_ptr</code> goes out of scope.
                            </span>
                            <a href="http://en.cppreference.com/w/cpp/memory/unique_ptr"><code>std::unique_ptr</code></a>は、スマートポインタの一種で、C++11で導入されました。このスマートポインタは、動的に確保されたオブジェクトに対する排他的な所有権を表します。<code>std::unique_ptr</code>によって所有されるオブジェクトは、<code>std::unique_ptr</code>がスコープの外に出たときにdeleteされます。
                        </span>
                        <span>
                            <span class="src">
                                It cannot be copied, but can be <em>moved</em> to
                                represent ownership transfer.
                            </span>
                            <code>std::unique_ptr</code>をコピーすることはできませんが、担当する所有権を<em>移動</em>させることはできます。
                        </span>
                        <span>
                            <span class="src">
                                <a href="http://en.cppreference.com/w/cpp/memory/shared_ptr">
                                    <code>std::shared_ptr</code>
                                </a> is a smart pointer type
                                that expresses shared ownership of
                                a dynamically allocated object.
                            </span>
                            <a href="http://en.cppreference.com/w/cpp/memory/shared_ptr"><code>std::shared_ptr</code></a>は、動的に確保されたオブジェクトの所有権を他者と共有することを表すために使われるスマートポインタです。
                        </span>

                        <span>
                            <span class="src">
                                <code>std::shared_ptr</code>s
                                can be copied; ownership of the object is shared among
                                all copies, and the object is deleted when the last
                                <code>std::shared_ptr</code> is destroyed.
                            </span>
                            <code>std::shared_ptr</code>はコピーすることができます。オブジェクトの所有権はすべてのコピーの間で共有され、オブジェクトは最後の<code>std::shared_ptr</code>が破壊されるときにdeleteされます。
                        </span>
                    </p>
                </div>

                <div class="pros">
                    <ul>
                        <li>
                            <span>
                                <span class="src">
                                    It's virtually impossible to manage dynamically
                                    allocated memory without some sort of ownership
                                    logic.
                                </span>
                                所有権の概念がなければ、動的に確保されるメモリを管理するのは実質的に不可能です。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Transferring ownership of an object can be cheaper
                                    than copying it (if copying it is even possible).
                                </span>
                                所有権を移すだけであれば、オブジェクトをコピーするよりも低コストとなるでしょう。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Transferring ownership can be simpler than
                                    'borrowing' a pointer or reference, because it reduces
                                    the need to coordinate the lifetime of the object
                                    between the two users.
                                </span>
                                オブジェクトの所有権を移すことは、参照やポインタを「借りてくる」よりも単純です。なぜならば、そのオブジェクトを扱う二者間での、オブジェクトの生存期間に関する認識合わせの必要性を減らすからです。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Smart pointers can improve readability by making
                                    ownership logic explicit, self-documenting, and
                                    unambiguous.
                                </span>
                                スマートポインタは、所有権を明示化し、それ自体にドキュメントの意味合いを持たせられるため、可読性が向上します。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Smart pointers can eliminate manual ownership
                                    bookkeeping, simplifying the code and ruling out large
                                    classes of errors.
                                </span>
                                スマートポインタは手作業による所有権管理をなくし、コードを単純化し、エラーのうち大きな分類を除外することができます。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    For const objects, shared ownership can be a simple
                                    and efficient alternative to deep copying.
                                </span>
                                constなオブジェクトについていえば、所有権を共有することは、単純かつ効率的なディープコピーの代替手段となります。
                            </span>
                        </li>
                    </ul>
                </div>

                <div class="cons">
                    <ul>
                        <li>
                            <span>
                                <span class="src">
                                    Ownership must be represented and transferred via
                                    pointers (whether smart or plain).
                                </span>
                                所有権は、スマートポインタであろうと生のポインタであろうと、何らかのポインタによって扱われ、ポインタ間で受け渡しが行われます。
                            </span>
                            <span>
                                <span class="src">
                                    Pointer semantics
                                    are more complicated than value semantics, especially
                                    in APIs: you have to worry not just about ownership,
                                    but also aliasing, lifetime, and mutability, among
                                    other issues.
                                </span>
                                ポインタの概念は値を直接扱うよりも複雑で、特にAPIの層では、所有権だけではなく、エイリアシング、ライフタイム、ミュータビリティ、などについても気にしなくてはなりません。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    The performance costs of value semantics are often
                                    overestimated, so the performance benefits of ownership
                                    transfer might not justify the readability and
                                    complexity costs.
                                </span>
                                値を直接扱うときのパフォーマンスコストはしばしば想定よりも高く見積もられがちです。所有権を移す方法を選択することで得られるパフォーマンス上のメリットは、それによる可読性の低下や複雑化のコストに見合わないかもしれません。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    APIs that transfer ownership force their clients
                                    into a single memory management model.
                                </span>
                                所有権を移すAPIは、その使用者にシングルメモリマネジメントモデルを強制します。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Code using smart pointers is less explicit about
                                    where the resource releases take place.
                                </span>
                                スマートポインタ使っているコードは、リソースがいつどこで解放されるかの明示性が低下します。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    <code>std::unique_ptr</code> expresses ownership
                                    transfer using C++11's move semantics, which are
                                    relatively new and may confuse some programmers.
                                </span>
                                <code>std::unique_ptr</code> は、C+11のムーブのセマンティクスを使って所有権を移します。ムーブの概念は比較的新しいため、プログラマを混乱させるかもしれません。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Shared ownership can be a tempting alternative to
                                    careful ownership design, obfuscating the design of a
                                    system.
                                </span>
                                所有権に関するデザインを注意深く行うのに比べて、単純に所有権を共有させて済ませてしまうことは、魅惑的な代替手段に見える場合があります。そして、それはシステムのデザインを曖昧にしてしまうことに繋がります。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Shared ownership requires explicit bookkeeping at
                                    run-time, which can be costly.
                                </span>
                                所有権を共有させると、実行時に明示的な所有権を管理を行うことになり、このためのコストが高くつく場合があります。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    In some cases (e.g. cyclic references), objects
                                    with shared ownership may never be deleted.
                                </span>
                                たとえば循環参照のように、所有権を共有されたオブジェクトが決してdeleteされない状態に陥ることがあります。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Smart pointers are not perfect substitutes for
                                    plain pointers.
                                </span>
                                スマートポインタは生のポインタに対する完璧な代替手段ではありません。
                            </span>
                        </li>
                    </ul>
                </div>

                <div class="decision">
                    <p>
                        <span>
                            <span class="src">
                                If dynamic allocation is necessary, prefer to keep
                                ownership with the code that allocated it.
                            </span>
                            動的なオブジェクトの確保が必要な場合、その所有権はそれを確保したコードが持つようにしましょう。
                        </span>
                        <span>
                            <span class="src">
                                If other code
                                needs access to the object, consider passing it a copy,
                                or passing a pointer or reference without transferring
                                ownership.
                            </span>
                            他のコードがそのオブジェクトにアクセスする必要がある場合は、単にオブジェクトのコピーを渡すか、所有権の移動なしにポインタや参照を渡す方法を検討してください。
                        </span>
                        <span>
                            <span class="src">
                                Prefer to use <code>std::unique_ptr</code> to
                                make ownership transfer explicit.
                            </span>
                            所有権の移動を明示的に行うためには、<code>std::unique_ptr</code>を使うようにしましょう。
                        </span>
                        <span>
                            <span class="src">
                                For example:
                            </span>
                            以下に例を示します。
                        </span>
                    </p>

<pre>std::unique_ptr&lt;Foo&gt; FooFactory();
void FooConsumer(std::unique_ptr&lt;Foo&gt; ptr);
</pre>

                    <p>
                        <span>
                            <span class="src">
                                Do not design your code to use shared ownership
                                without a very good reason.
                            </span>
                           非常に良い理由がない限り、オブジェクトの所有権を共有させるデザインにしてはいけません。
                        </span>
                        <span>
                            <span class="src">
                                One such reason is to avoid
                                expensive copy operations, but you should only do this if
                                the performance benefits are significant, and the
                                underlying object is immutable (i.e.
                                <code>std::shared_ptr&lt;const Foo&gt;</code>).
                            </span>
                            そのような理由としては、高価なコピーを避けるためといったものがあげられますが、所有権の共有は、パフォーマンス上の利益が大きく、かつ対象のオブジェクトが不変である場合にのみ行ってください(言い換えると、<code>std::shared_ptr&lt;const Foo&gt;</code>)。
                        </span>
                        <span>
                            <span class="src">
                                If you
                                do use shared ownership, prefer to use
                                <code>std::shared_ptr</code>.
                            </span>
                            所有権を共有したい場合、<code>std::shared_ptr</code>を使いましょう。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Never use <code>std::auto_ptr</code>.
                            </span>
                            <code>std::auto_ptr</code>を使ってはなりません。
                        </span>
                        <span>
                            <span class="src">
                                Instead, use
                                <code>std::unique_ptr</code>.
                            </span>
                            代わりに、<code>std::unique_ptr</code>を使いましょう。
                        </span>
                    </p>
                </div>

            </div>

            <h3 id="cpplint"><span title="cpplint">cpplint</span></h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Use <code>cpplint.py</code>
                            to detect style errors.
                        </span>
                        スタイルに関する問題を検出するため、<code>cpplint.py</code>を使ってください。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <p>
                    <span>
                        <span class="src">
                            <code>cpplint.py</code>
                            is a tool that reads a source file and identifies many
                            style errors.
                        </span>
                        <code>cpplint.py</code>は、ソースファイルを読み、スタイルに関するたくさんのエラーを識別してくれるツールです。
                    </span>
                    <span>
                        <span class="src">
                            It is not perfect, and has both false
                            positives and false negatives, but it is still a valuable
                            tool.
                        </span>
                        このツールは完璧ではなく、誤診もありますが、それでも価値があります。
                    </span>
                    <span>
                        <span class="src">
                            False positives can be ignored by putting <code>
                                //
                                NOLINT
                            </code> at the end of the line or
                            <code>// NOLINTNEXTLINE</code> in the previous line.
                        </span>
                        偽陽性の診断される場合は、行末に<code>// NOLINT</code>を書くか、前の行に<code>// NOLINTNEXTLINE</code>を記載すれば、無視されます。
                    </span>
                </p>



                <p>
                    <span>
                        <span class="src">
                            Some projects have instructions on
                            how to run <code>cpplint.py</code> from their project
                            tools.
                        </span>
                        いくつかのプロジェクトにおいては、プロジェクトのツールから<code>cpplint.py</code>を起動するやり方が用意されています。
                    </span>
                    <span>
                        <span class="src">
                            If the project you are contributing to does not,
                            you can download
                            <a href="https://raw.githubusercontent.com/google/styleguide/gh-pages/cpplint/cpplint.py">
                                <code>cpplint.py</code>
                            </a> separately.
                        </span>
                        あなたのプロジェクトでそのような環境が用意されていない場合は<a href="https://raw.githubusercontent.com/google/styleguide/gh-pages/cpplint/cpplint.py"><code>cpplint.py</code></a>から個別にダウンロードすることができます。
                    </span>
                </p>

            </div>



            <h2 id="Other_C++_Features">Other C++ Features</h2>

            <h3 id="Rvalue_references">Rvalue References</h3>

            <div class="summary">
                <p>
                    Use rvalue references only to define move constructors and move assignment
                    operators, or for perfect forwarding.
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        Rvalue references
                        are a type of reference that can only bind to temporary
                        objects. The syntax is similar to traditional reference
                        syntax. For example, <code>
                            void f(string&amp;&amp;
                            s);
                        </code> declares a function whose argument is an
                        rvalue reference to a string.
                    </p>
                </div>

                <div class="pros">
                    <ul>
                        <li>
                            Defining a move constructor (a constructor taking
                            an rvalue reference to the class type) makes it
                            possible to move a value instead of copying it. If
                            <code>v1</code> is a <code>std::vector&lt;string&gt;</code>,
                            for example, then <code>auto v2(std::move(v1))</code>
                            will probably just result in some simple pointer
                            manipulation instead of copying a large amount of data.
                            In some cases this can result in a major performance
                            improvement.
                        </li>

                        <li>
                            Rvalue references make it possible to write a
                            generic function wrapper that forwards its arguments to
                            another function, and works whether or not its
                            arguments are temporary objects. (This is sometimes called
                            "perfect forwarding".)
                        </li>

                        <li>
                            Rvalue references make it possible to implement
                            types that are movable but not copyable, which can be
                            useful for types that have no sensible definition of
                            copying but where you might still want to pass them as
                            function arguments, put them in containers, etc.
                        </li>

                        <li>
                            <code>std::move</code> is necessary to make
                            effective use of some standard-library types, such as
                            <code>std::unique_ptr</code>.
                        </li>
                    </ul>
                </div>

                <div class="cons">
                    <ul>
                        <li>
                            Rvalue references are a relatively new feature
                            (introduced as part of C++11), and not yet widely
                            understood. Rules like reference collapsing, and
                            automatic synthesis of move constructors, are
                            complicated.
                        </li>
                    </ul>
                </div>

                <div class="decision">
                    <p>
                        Use rvalue references only to define move constructors and move assignment
                        operators (as described in <a href="#Copyable_Movable_Types">
                            Copyable and
                            Movable Types
                        </a>) and, in conjunction with <code><a href="http://en.cppreference.com/w/cpp/utility/forward">std::forward</a></code>,
                        to support perfect forwarding.  You may use <code>std::move</code> to express
                        moving a value from one object to another rather than copying it.
                    </p>
                </div>

            </div>

            <h3 id="Friends">Friends</h3>

            <div class="summary">
                <p>
                    We allow use of <code>friend</code> classes and functions,
                    within reason.
                </p>
            </div>

            <div class="stylebody">

                <p>
                    Friends should usually be defined in the same file so
                    that the reader does not have to look in another file to
                    find uses of the private members of a class. A common use
                    of <code>friend</code> is to have a
                    <code>FooBuilder</code> class be a friend of
                    <code>Foo</code> so that it can construct the inner state
                    of <code>Foo</code> correctly, without exposing this
                    state to the world. In some cases it may be useful to
                    make a unittest class a friend of the class it tests.
                </p>

                <p>
                    Friends extend, but do not break, the encapsulation
                    boundary of a class. In some cases this is better than
                    making a member public when you want to give only one
                    other class access to it. However, most classes should
                    interact with other classes solely through their public
                    members.
                </p>

            </div>

            <h3 id="Exceptions">Exceptions</h3>

            <div class="summary">
                <p>We do not use C++ exceptions.</p>
            </div>

            <div class="stylebody">

                <div class="pros">
                    <ul>
                        <li>
                            Exceptions allow higher levels of an application to
                            decide how to handle "can't happen" failures in deeply
                            nested functions, without the obscuring and error-prone
                            bookkeeping of error codes.
                        </li>



                        <li>
                            Exceptions are used by most other
                            modern languages. Using them in C++ would make it more
                            consistent with Python, Java, and the C++ that others
                            are familiar with.
                        </li>

                        <li>
                            Some third-party C++ libraries use exceptions, and
                            turning them off internally makes it harder to
                            integrate with those libraries.
                        </li>

                        <li>
                            Exceptions are the only way for a constructor to
                            fail. We can simulate this with a factory function or
                            an <code>Init()</code> method, but these require heap
                            allocation or a new "invalid" state, respectively.
                        </li>

                        <li>
                            Exceptions are really handy in testing
                            frameworks.
                        </li>
                    </ul>
                </div>

                <div class="cons">
                    <ul>
                        <li>
                            When you add a <code>throw</code> statement to an
                            existing function, you must examine all of its
                            transitive callers. Either they must make at least the
                            basic exception safety guarantee, or they must never
                            catch the exception and be happy with the program
                            terminating as a result. For instance, if
                            <code>f()</code> calls <code>g()</code> calls
                            <code>h()</code>, and <code>h</code> throws an
                            exception that <code>f</code> catches, <code>g</code>
                            has to be careful or it may not clean up properly.
                        </li>

                        <li>
                            More generally, exceptions make the control flow of
                            programs difficult to evaluate by looking at code:
                            functions may return in places you don't expect. This
                            causes maintainability and debugging difficulties. You
                            can minimize this cost via some rules on how and where
                            exceptions can be used, but at the cost of more that a
                            developer needs to know and understand.
                        </li>

                        <li>
                            Exception safety requires both RAII and different
                            coding practices. Lots of supporting machinery is
                            needed to make writing correct exception-safe code
                            easy. Further, to avoid requiring readers to understand
                            the entire call graph, exception-safe code must isolate
                            logic that writes to persistent state into a "commit"
                            phase. This will have both benefits and costs (perhaps
                            where you're forced to obfuscate code to isolate the
                            commit). Allowing exceptions would force us to always
                            pay those costs even when they're not worth it.
                        </li>

                        <li>
                            Turning on exceptions adds data to each binary
                            produced, increasing compile time (probably slightly)
                            and possibly increasing address space pressure.
                        </li>

                        <li>
                            The availability of exceptions may encourage
                            developers to throw them when they are not appropriate
                            or recover from them when it's not safe to do so. For
                            example, invalid user input should not cause exceptions
                            to be thrown. We would need to make the style guide
                            even longer to document these restrictions!
                        </li>
                    </ul>
                </div>

                <div class="decision">
                    <p>
                        On their face, the benefits of using exceptions
                        outweigh the costs, especially in new projects. However,
                        for existing code, the introduction of exceptions has
                        implications on all dependent code. If exceptions can be
                        propagated beyond a new project, it also becomes
                        problematic to integrate the new project into existing
                        exception-free code. Because most existing C++ code at
                        Google is not prepared to deal with exceptions, it is
                        comparatively difficult to adopt new code that generates
                        exceptions.
                    </p>

                    <p>
                        Given that Google's existing code is not
                        exception-tolerant, the costs of using exceptions are
                        somewhat greater than the costs in a new project. The
                        conversion process would be slow and error-prone. We
                        don't believe that the available alternatives to
                        exceptions, such as error codes and assertions, introduce
                        a significant burden.
                    </p>

                    <p>
                        Our advice against using exceptions is not predicated
                        on philosophical or moral grounds, but practical ones.
                        Because we'd like to use our open-source
                        projects at Google and it's difficult to do so if those
                        projects use exceptions, we need to advise against
                        exceptions in Google open-source projects as well.
                        Things would probably be different if we had to do it all
                        over again from scratch.
                    </p>

                    <p>
                        This prohibition also applies to the exception-related
                        features added in C++11, such as <code>noexcept</code>,
                        <code>std::exception_ptr</code>, and
                        <code>std::nested_exception</code>.
                    </p>

                    <p>
                        There is an <a href="#Windows_Code">exception</a> to
                        this rule (no pun intended) for Windows code.
                    </p>
                </div>

            </div>

            <h3 id="Run-Time_Type_Information__RTTI_">
                Run-Time Type
                Information (RTTI)
            </h3>

            <div class="summary">
                <p>Avoid using Run Time Type Information (RTTI).</p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        RTTI allows a
                        programmer to query the C++ class of an object at run
                        time. This is done by use of <code>typeid</code> or
                        <code>dynamic_cast</code>.
                    </p>
                </div>

                <div class="cons">
                    <p>
                        Querying the type of an object at run-time frequently
                        means a design problem. Needing to know the type of an
                        object at runtime is often an indication that the design
                        of your class hierarchy is flawed.
                    </p>

                    <p>
                        Undisciplined use of RTTI makes code hard to maintain.
                        It can lead to type-based decision trees or switch
                        statements scattered throughout the code, all of which
                        must be examined when making further changes.
                    </p>
                </div>

                <div class="pros">
                    <p>
                        The standard alternatives to RTTI (described below)
                        require modification or redesign of the class hierarchy
                        in question. Sometimes such modifications are infeasible
                        or undesirable, particularly in widely-used or mature
                        code.
                    </p>

                    <p>
                        RTTI can be useful in some unit tests. For example, it
                        is useful in tests of factory classes where the test has
                        to verify that a newly created object has the expected
                        dynamic type. It is also useful in managing the
                        relationship between objects and their mocks.
                    </p>

                    <p>
                        RTTI is useful when considering multiple abstract
                        objects. Consider
                    </p>

<pre>bool Base::Equal(Base* other) = 0;
bool Derived::Equal(Base* other) {
  Derived* that = dynamic_cast&lt;Derived*&gt;(other);
  if (that == NULL)
    return false;
  ...
}
</pre>
                </div>

                <div class="decision">
                    <p>
                        RTTI has legitimate uses but is prone to abuse, so you
                        must be careful when using it. You may use it freely in
                        unittests, but avoid it when possible in other code. In
                        particular, think twice before using RTTI in new code. If
                        you find yourself needing to write code that behaves
                        differently based on the class of an object, consider one
                        of the following alternatives to querying the type:
                    </p>

                    <ul>
                        <li>
                            Virtual methods are the preferred way of executing
                            different code paths depending on a specific subclass
                            type. This puts the work within the object itself.
                        </li>

                        <li>
                            If the work belongs outside the object and instead
                            in some processing code, consider a double-dispatch
                            solution, such as the Visitor design pattern. This
                            allows a facility outside the object itself to
                            determine the type of class using the built-in type
                            system.
                        </li>
                    </ul>

                    <p>
                        When the logic of a program guarantees that a given
                        instance of a base class is in fact an instance of a
                        particular derived class, then a
                        <code>dynamic_cast</code> may be used freely on the
                        object.  Usually one
                        can use a <code>static_cast</code> as an alternative in
                        such situations.
                    </p>

                    <p>
                        Decision trees based on type are a strong indication
                        that your code is on the wrong track.
                    </p>

<pre class="badcode">if (typeid(*data) == typeid(D1)) {
  ...
} else if (typeid(*data) == typeid(D2)) {
  ...
} else if (typeid(*data) == typeid(D3)) {
...
</pre>

                    <p>
                        Code such as this usually breaks when additional
                        subclasses are added to the class hierarchy. Moreover,
                        when properties of a subclass change, it is difficult to
                        find and modify all the affected code segments.
                    </p>

                    <p>
                        Do not hand-implement an RTTI-like workaround. The
                        arguments against RTTI apply just as much to workarounds
                        like class hierarchies with type tags. Moreover,
                        workarounds disguise your true intent.
                    </p>
                </div>

            </div>

            <h3 id="Casting">Casting</h3>

            <div class="summary">
                <p>
                    Use C++-style casts
                    like <code>static_cast&lt;float&gt;(double_value)</code>, or brace
                    initialization for conversion of arithmetic types like
                    <code>int64 y = int64{1} &lt;&lt; 42</code>. Do not use
                    cast formats like
                    <code>int y = (int)x</code> or <code>int y = int(x)</code> (but the latter
                    is okay when invoking a constructor of a class type).
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        C++ introduced a
                        different cast system from C that distinguishes the types
                        of cast operations.
                    </p>
                </div>

                <div class="pros">
                    <p>
                        The problem with C casts is the ambiguity of the operation;
                        sometimes you are doing a <em>conversion</em>
                        (e.g., <code>(int)3.5</code>) and sometimes you are doing
                        a <em>cast</em> (e.g., <code>(int)"hello"</code>). Brace
                        initialization and C++ casts can often help avoid this
                        ambiguity. Additionally, C++ casts are more visible when searching for
                        them.
                    </p>
                </div>

                <div class="cons">
                    <p>The C++-style cast syntax is verbose and cumbersome.</p>
                </div>

                <div class="decision">
                    <p>
                        Do not use C-style casts. Instead, use these C++-style casts when
                        explicit type conversion is necessary.
                    </p>

                    <ul>
                        <li>
                            Use brace initialization to convert arithmetic types
                            (e.g. <code>int64{x}</code>).  This is the safest approach because code
                            will not compile if conversion can result in information loss.  The
                            syntax is also concise.
                        </li>



                        <li>
                            Use <code>static_cast</code> as the equivalent of a C-style cast
                            that does value conversion, when you need to
                            explicitly up-cast a pointer from a class to its superclass, or when
                            you need to explicitly cast a pointer from a superclass to a
                            subclass.  In this last case, you must be sure your object is
                            actually an instance of the subclass.
                        </li>



                        <li>
                            Use <code>const_cast</code> to remove the
                            <code>const</code> qualifier (see <a href="#Use_of_const">const</a>).
                        </li>

                        <li>
                            Use <code>reinterpret_cast</code> to do unsafe
                            conversions of pointer types to and from integer and
                            other pointer types. Use this only if you know what you
                            are doing and you understand the aliasing issues.
                        </li>


                    </ul>

                    <p>
                        See the <a href="#Run-Time_Type_Information__RTTI_">
                            RTTI section
                        </a> for guidance on the use of
                        <code>dynamic_cast</code>.
                    </p>
                </div>

            </div>

            <h3 id="Streams">Streams</h3>

            <div class="summary">
                <p>
                    Use streams where appropriate, and stick to "simple"
                    usages.
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        Streams are the standard I/O abstraction in C++, as
                        exemplified by the standard header <code>&lt;iostream&gt;</code>.
                        They are widely used in Google code, but only for debug logging
                        and test diagnostics.
                    </p>
                </div>

                <div class="pros">
                    <p>
                        The <code>&lt;&lt;</code> and <code>&gt;&gt;</code>
                        stream operators provide an API for formatted I/O that
                        is easily learned, portable, reusable, and extensible.
                        <code>printf</code>, by contrast, doesn't even support
                        <code>string</code>, to say nothing of user-defined types,
                        and is very difficult to use portably.
                        <code>printf</code> also obliges you to choose among the
                        numerous slightly different versions of that function,
                        and navigate the dozens of conversion specifiers.
                    </p>

                    <p>
                        Streams provide first-class support for console I/O
                        via <code>std::cin</code>, <code>std::cout</code>,
                        <code>std::cerr</code>, and <code>std::clog</code>.
                        The C APIs do as well, but are hampered by the need to
                        manually buffer the input.
                    </p>
                </div>

                <div class="cons">
                    <ul>
                        <li>
                            Stream formatting can be configured by mutating the
                            state of the stream. Such mutations are persistent, so
                            the behavior of your code can be affected by the entire
                            previous history of the stream, unless you go out of your
                            way to restore it to a known state every time other code
                            might have touched it. User code can not only modify the
                            built-in state, it can add new state variables and behaviors
                            through a registration system.
                        </li>

                        <li>
                            It is difficult to precisely control stream output, due
                            to the above issues, the way code and data are mixed in
                            streaming code, and the use of operator overloading (which
                            may select a different overload than you expect).
                        </li>

                        <li>
                            The practice of building up output through chains
                            of <code>&lt;&lt;</code> operators interferes with
                            internationalization, because it bakes word order into the
                            code, and streams' support for localization is <a href="http://www.boost.org/doc/libs/1_48_0/libs/locale/doc/html/rationale.html#rationale_why">
                                flawed
                            </a>.
                        </li>





                        <li>
                            The streams API is subtle and complex, so programmers must
                            develop experience with it in order to use it effectively.
                            However, streams were historically banned in Google code (except
                            for logging and diagnostics), so Google engineers tend not to
                            have that experience. Consequently, streams-based code is likely
                            to be less readable and maintainable by Googlers than code based
                            on more familiar abstractions.
                        </li>

                        <li>
                            Resolving the many overloads of <code>&lt;&lt;</code> is
                            extremely costly for the compiler. When used pervasively in a
                            large code base, it can consume as much as 20% of the parsing
                            and semantic analysis time.
                        </li>
                    </ul>
                </div>

                <div class="decision">
                    <p>
                        Use streams only when they are the best tool for the job.
                        This is typically the case when the I/O is ad-hoc, local,
                        human-readable, and targeted at other developers rather than
                        end-users. Be consistent with the code around you, and with the
                        codebase as a whole; if there's an established tool for
                        your problem, use that tool instead.
                    </p>

                    <p>
                        Avoid using streams for I/O that faces external users or
                        handles untrusted data. Instead, find and use the appropriate
                        templating libraries to handle issues like internationalization,
                        localization, and security hardening.
                    </p>

                    <p>
                        If you do use streams, avoid the stateful parts of the
                        streams API (other than error state), such as <code>imbue()</code>,
                        <code>xalloc()</code>, and <code>register_callback()</code>.
                        Use explicit formatting functions  rather than
                        stream manipulators or formatting flags to control formatting
                        details such as number base, precision, or padding.
                    </p>

                    <p>
                        Overload <code>&lt;&lt;</code> as a streaming operator
                        for your type only if your type represents a value, and
                        <code>&lt;&lt;</code> writes out a human-readable string
                        representation of that value. Avoid exposing implementation
                        details in the output of <code>&lt;&lt;</code>; if you need to print
                        object internals for debugging, use named functions instead
                        (a method named <code>DebugString()</code> is the most common
                        convention).
                    </p>
                </div>

            </div>

            <h3 id="Preincrement_and_Predecrement">Preincrement and Predecrement</h3>

            <div class="summary">
                <p>
                    Use prefix form (<code>++i</code>) of the increment and
                    decrement operators with iterators and other template
                    objects.
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        When a variable
                        is incremented (<code>++i</code> or <code>i++</code>) or
                        decremented (<code>--i</code> or <code>i--</code>) and
                        the value of the expression is not used, one must decide
                        whether to preincrement (decrement) or postincrement
                        (decrement).
                    </p>
                </div>

                <div class="pros">
                    <p>
                        When the return value is ignored, the "pre" form
                        (<code>++i</code>) is never less efficient than the
                        "post" form (<code>i++</code>), and is often more
                        efficient. This is because post-increment (or decrement)
                        requires a copy of <code>i</code> to be made, which is
                        the value of the expression. If <code>i</code> is an
                        iterator or other non-scalar type, copying <code>i</code>
                        could be expensive. Since the two types of increment
                        behave the same when the value is ignored, why not just
                        always pre-increment?
                    </p>
                </div>

                <div class="cons">
                    <p>
                        The tradition developed, in C, of using post-increment
                        when the expression value is not used, especially in
                        <code>for</code> loops. Some find post-increment easier
                        to read, since the "subject" (<code>i</code>) precedes
                        the "verb" (<code>++</code>), just like in English.
                    </p>
                </div>

                <div class="decision">
                    <p>
                        For simple scalar
                        (non-object) values there is no reason to prefer one form
                        and we allow either. For iterators and other template
                        types, use pre-increment.
                    </p>
                </div>

            </div>

            <h3 id="Use_of_const">Use of const</h3>

            <div class="summary">
                <p>
                    Use <code>const</code> whenever it makes sense. With C++11,
                    <code>constexpr</code> is a better choice for some uses of
                    const.
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        Declared variables and parameters can be preceded
                        by the keyword <code>const</code> to indicate the variables
                        are not changed (e.g., <code>const int foo</code>). Class
                        functions can have the <code>const</code> qualifier to
                        indicate the function does not change the state of the
                        class member variables (e.g., <code>
                            class Foo { int
                            Bar(char c) const; };
                        </code>).
                    </p>
                </div>

                <div class="pros">
                    <p>
                        Easier for people to understand how variables are being
                        used. Allows the compiler to do better type checking,
                        and, conceivably, generate better code. Helps people
                        convince themselves of program correctness because they
                        know the functions they call are limited in how they can
                        modify your variables. Helps people know what functions
                        are safe to use without locks in multi-threaded
                        programs.
                    </p>
                </div>

                <div class="cons">
                    <p>
                        <code>const</code> is viral: if you pass a
                        <code>const</code> variable to a function, that function
                        must have <code>const</code> in its prototype (or the
                        variable will need a <code>const_cast</code>). This can
                        be a particular problem when calling library
                        functions.
                    </p>
                </div>

                <div class="decision">
                    <p>
                        <code>const</code> variables, data members, methods
                        and arguments add a level of compile-time type checking;
                        it is better to detect errors as soon as possible.
                        Therefore we strongly recommend that you use
                        <code>const</code> whenever it makes sense to do so:
                    </p>

                    <ul>
                        <li>
                            If a function guarantees that it will not modify an argument
                            passed by reference or by pointer, the corresponding function parameter
                            should be a reference-to-const (<code>const T&amp;</code>) or
                            pointer-to-const (<code>const T*</code>), respectively.
                        </li>

                        <li>
                            Declare methods to be <code>const</code> whenever
                            possible. Accessors should almost always be
                            <code>const</code>. Other methods should be const if
                            they do not modify any data members, do not call any
                            non-<code>const</code> methods, and do not return a
                            non-<code>const</code> pointer or
                            non-<code>const</code> reference to a data member.
                        </li>

                        <li>
                            Consider making data members <code>const</code>
                            whenever they do not need to be modified after
                            construction.
                        </li>
                    </ul>

                    <p>
                        The <code>mutable</code> keyword is allowed but is
                        unsafe when used with threads, so thread safety should be
                        carefully considered first.
                    </p>
                </div>

                <div class="stylepoint_subsection">
                    <h4>Where to put the const</h4>

                    <p>
                        Some people favor the form <code>int const *foo</code>
                        to <code>const int* foo</code>. They argue that this is
                        more readable because it's more consistent: it keeps the
                        rule that <code>const</code> always follows the object
                        it's describing. However, this consistency argument
                        doesn't apply in codebases with few deeply-nested pointer
                        expressions since most <code>const</code> expressions
                        have only one <code>const</code>, and it applies to the
                        underlying value. In such cases, there's no consistency
                        to maintain. Putting the <code>const</code> first is
                        arguably more readable, since it follows English in
                        putting the "adjective" (<code>const</code>) before the
                        "noun" (<code>int</code>).
                    </p>

                    <p>
                        That said, while we encourage putting
                        <code>const</code> first, we do not require it. But be
                        consistent with the code around you!
                    </p>
                </div>

            </div>

            <h3 id="Use_of_constexpr">Use of constexpr</h3>

            <div class="summary">
                <p>
                    In C++11, use <code>constexpr</code> to define true
                    constants or to ensure constant initialization.
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        Some variables can be declared <code>constexpr</code>
                        to indicate the variables are true constants, i.e. fixed at
                        compilation/link time. Some functions and constructors
                        can be declared <code>constexpr</code> which enables them
                        to be used in defining a <code>constexpr</code>
                        variable.
                    </p>
                </div>

                <div class="pros">
                    <p>
                        Use of <code>constexpr</code> enables definition of
                        constants with floating-point expressions rather than
                        just literals; definition of constants of user-defined
                        types; and definition of constants with function
                        calls.
                    </p>
                </div>

                <div class="cons">
                    <p>
                        Prematurely marking something as constexpr may cause
                        migration problems if later on it has to be downgraded.
                        Current restrictions on what is allowed in constexpr
                        functions and constructors may invite obscure workarounds
                        in these definitions.
                    </p>
                </div>

                <div class="decision">
                    <p>
                        <code>constexpr</code> definitions enable a more
                        robust specification of the constant parts of an
                        interface. Use <code>constexpr</code> to specify true
                        constants and the functions that support their
                        definitions. Avoid complexifying function definitions to
                        enable their use with <code>constexpr</code>. Do not use
                        <code>constexpr</code> to force inlining.
                    </p>
                </div>

            </div>

            <h3 id="Integer_Types">Integer Types</h3>

            <div class="summary">
                <p>
                    Of the built-in C++ integer types, the only one used
                    is
                    <code>int</code>. If a program needs a variable of a
                    different size, use
                    a precise-width integer type from
                    <code>&lt;stdint.h&gt;</code>, such as
                    <code>int16_t</code>. If your variable represents a
                    value that could ever be greater than or equal to 2^31
                    (2GiB), use a 64-bit type such as
                    <code>int64_t</code>.
                    Keep in mind that even if your value won't ever be too large
                    for an <code>int</code>, it may be used in intermediate
                    calculations which may require a larger type. When in doubt,
                    choose a larger type.
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        C++ does not specify the sizes of its integer types.
                        Typically people assume that <code>short</code> is 16 bits,
                        <code>int</code> is 32 bits, <code>long</code> is 32 bits
                        and <code>long long</code> is 64 bits.
                    </p>
                </div>

                <div class="pros">
                    <p>Uniformity of declaration.</p>
                </div>

                <div class="cons">
                    <p>
                        The sizes of integral types in C++ can vary based on
                        compiler and architecture.
                    </p>
                </div>

                <div class="decision">

                    <p>
                        <code>&lt;stdint.h&gt;</code> defines types
                        like <code>int16_t</code>, <code>uint32_t</code>,
                        <code>int64_t</code>, etc. You should always use
                        those in preference to <code>short</code>, <code>
                            unsigned
                            long long
                        </code> and the like, when you need a guarantee
                        on the size of an integer. Of the C integer types, only
                        <code>int</code> should be used. When appropriate, you
                        are welcome to use standard types like
                        <code>size_t</code> and <code>ptrdiff_t</code>.
                    </p>

                    <p>
                        We use <code>int</code> very often, for integers we
                        know are not going to be too big, e.g., loop counters.
                        Use plain old <code>int</code> for such things. You
                        should assume that an <code>int</code> is

                        at least 32 bits, but don't
                        assume that it has more than 32 bits. If you need a 64-bit
                        integer type, use
                        <code>int64_t</code>
                        or
                        <code>uint64_t</code>.
                    </p>

                    <p>
                        For integers we know can be "big",
                        use
                        <code>int64_t</code>.
                    </p>

                    <p>
                        You should not use the unsigned integer types such as
                        <code>uint32_t</code>, unless there is a valid
                        reason such as representing a bit pattern rather than a
                        number, or you need defined overflow modulo 2^N. In
                        particular, do not use unsigned types to say a number
                        will never be negative. Instead, use
                        assertions for this.
                    </p>



                    <p>
                        If your code is a container that returns a size, be
                        sure to use a type that will accommodate any possible
                        usage of your container. When in doubt, use a larger type
                        rather than a smaller type.
                    </p>

                    <p>
                        Use care when converting integer types. Integer
                        conversions and promotions can cause non-intuitive
                        behavior.
                    </p>
                </div>

                <div class="stylepoint_subsection">

                    <h4>On Unsigned Integers</h4>

                    <p>
                        Some people, including some textbook authors,
                        recommend using unsigned types to represent numbers that
                        are never negative. This is intended as a form of
                        self-documentation. However, in C, the advantages of such
                        documentation are outweighed by the real bugs it can
                        introduce. Consider:
                    </p>

<pre>for (unsigned int i = foo.Length()-1; i &gt;= 0; --i) ...
</pre>

                    <p>
                        This code will never terminate! Sometimes gcc will
                        notice this bug and warn you, but often it will not.
                        Equally bad bugs can occur when comparing signed and
                        unsigned variables. Basically, C's type-promotion scheme
                        causes unsigned types to behave differently than one
                        might expect.
                    </p>

                    <p>
                        So, document that a variable is non-negative using
                        assertions. Don't use an unsigned
                        type.
                    </p>
                </div>

            </div>

            <h3 id="64-bit_Portability">64-bit Portability</h3>

            <div class="summary">
                <p>
                    Code should be 64-bit and 32-bit friendly. Bear in mind
                    problems of printing, comparisons, and structure alignment.
                </p>
            </div>

            <div class="stylebody">

                <ul>
                    <li>
                        <p>
                            <code>printf()</code> specifiers for some types
                            are not cleanly portable between 32-bit and 64-bit
                            systems. C99 defines some portable format specifiers.
                            Unfortunately, MSVC 7.1 does not understand some of
                            these specifiers and the standard is missing a few,
                            so we
                            have to define our own ugly versions in some cases
                            (in the style of the standard include file
                            <code>inttypes.h</code>):
                        </p>

                        <div>
                            <pre>// printf macros for size_t, in the style of inttypes.h
#ifdef _LP64
#define __PRIS_PREFIX "z"
#else
#define __PRIS_PREFIX
#endif

// Use these macros after a % in a printf format string
// to get correct 32/64 bit behavior, like this:
// size_t size = records.size();
// printf("%" PRIuS "\n", size);

#define PRIdS __PRIS_PREFIX "d"
#define PRIxS __PRIS_PREFIX "x"
#define PRIuS __PRIS_PREFIX "u"
#define PRIXS __PRIS_PREFIX "X"
#define PRIoS __PRIS_PREFIX "o"
  </pre>
                        </div>

                        <table border="1" summary="portable printf specifiers">
                            <tbody>
                                <tr align="center">
                                    <th>Type</th>
                                    <th>DO NOT use</th>
                                    <th>DO use</th>
                                    <th>Notes</th>
                                </tr>

                                <tr align="center">
                                    <td><code>void *</code> (or any pointer)</td>
                                    <td><code>%lx</code></td>
                                    <td><code>%p</code></td>
                                    <td></td>
                                </tr>



                                <tr align="center">
                                    <td><code>int64_t</code></td>
                                    <td><code>%qd</code>, <code>%lld</code></td>
                                    <td><code>%" PRId64 "</code></td>
                                    <td></td>
                                </tr>



                                <tr align="center">
                                    <td><code>uint64_t</code></td>
                                    <td>
                                        <code>%qu</code>, <code>%llu</code>,
                                        <code>%llx</code>
                                    </td>
                                    <td>
                                        <code>%" PRIu64 "</code>,
                                        <code>%" PRIx64 "</code>
                                    </td>
                                    <td></td>
                                </tr>



                                <tr align="center">
                                    <td><code>size_t</code></td>
                                    <td><code>%u</code></td>
                                    <td><code>%" PRIuS "</code>, <code>%" PRIxS "</code></td>
                                    <td>
                                        C99 specifies <code>%zu</code>
                                    </td>
                                </tr>

                                <tr align="center">
                                    <td><code>ptrdiff_t</code></td>
                                    <td><code>%d</code></td>
                                    <td><code>%" PRIdS "</code></td>
                                    <td>
                                        C99 specifies <code>%td</code>
                                    </td>
                                </tr>


                            </tbody>
                        </table>

                        <p>
                            Note that the <code>PRI*</code> macros expand to
                            independent strings which are concatenated by the
                            compiler. Hence if you are using a non-constant
                            format string, you need to insert the value of the
                            macro into the format, rather than the name. Note also
                            that spaces are required around the macro identifier to
                            separate it from the string literal. It is
                            still possible, as usual, to include length
                            specifiers, etc., after the <code>%</code> when using
                            the <code>PRI*</code> macros. So, e.g.
                            <code>printf("x = %30" PRIuS "\n", x)</code> would
                            expand on 32-bit Linux to <code>
                                printf("x = %30" "u"
                                "\n", x)
                            </code>, which the compiler will treat as
                            <code>printf("x = %30u\n", x)</code>.
                        </p>


                    </li>

                    <li>
                        Remember that <code>sizeof(void *)</code> !=
                        <code>sizeof(int)</code>. Use <code>intptr_t</code> if
                        you want a pointer-sized integer.
                    </li>

                    <li>
                        You may need to be careful with structure
                        alignments, particularly for structures being stored on
                        disk. Any class/structure with a
                        <code>int64_t</code>/<code>uint64_t</code>
                        member will by default end up being 8-byte aligned on a
                        64-bit system. If you have such structures being shared
                        on disk between 32-bit and 64-bit code, you will need
                        to ensure that they are packed the same on both
                        architectures.
                        Most compilers offer a way to
                        alter structure alignment. For gcc, you can use
                        <code>__attribute__((packed))</code>. MSVC offers
                        <code>#pragma pack()</code> and
                        <code>__declspec(align())</code>.
                    </li>

                    <li>
                        <p>
                            Use the <code>LL</code> or <code>ULL</code>
                            suffixes as needed to create 64-bit constants. For
                            example:
                        </p>


<pre>int64_t my_value = 0x123456789LL;
uint64_t my_mask = 3ULL &lt;&lt; 48;
</pre>
                    </li>
                </ul>

            </div>

            <h3 id="Preprocessor_Macros">Preprocessor Macros</h3>

            <div class="summary">
                <p>
                    Avoid defining macros, especially in headers; prefer
                    inline functions, enums, and <code>const</code> variables.
                    Name macros with a project-specific prefix. Do not use
                    macros to define pieces of a C++ API.
                </p>
            </div>

            <div class="stylebody">

                <p>
                    Macros mean that the code you see is not the same as
                    the code the compiler sees. This can introduce unexpected
                    behavior, especially since macros have global scope.
                </p>

                <p>
                    The problems introduced by macros are especially severe
                    when they are used to define pieces of a C++ API,
                    and still more so for public APIs. Every error message from
                    the compiler when developers incorrectly use that interface
                    now must explain how the macros formed the interface.
                    Refactoring and analysis tools have a dramatically harder
                    time updating the interface. As a consequence, we
                    specifically disallow using macros in this way.
                    For example, avoid patterns like:
                </p>

<pre class="badcode">class WOMBAT_TYPE(Foo) {
  // ...

 public:
  EXPAND_PUBLIC_WOMBAT_API(Foo)

  EXPAND_WOMBAT_COMPARISONS(Foo, ==, &lt;)
};
</pre>

                <p>
                    Luckily, macros are not nearly as necessary in C++ as
                    they are in C. Instead of using a macro to inline
                    performance-critical code, use an inline function.
                    Instead of using a macro to store a constant, use a
                    <code>const</code> variable. Instead of using a macro to
                    "abbreviate" a long variable name, use a reference.
                    Instead of using a macro to conditionally compile code
                    ... well, don't do that at all (except, of course, for
                    the <code>#define</code> guards to prevent double
                    inclusion of header files). It makes testing much more
                    difficult.
                </p>

                <p>
                    Macros can do things these other techniques cannot,
                    and you do see them in the codebase, especially in the
                    lower-level libraries. And some of their special features
                    (like stringifying, concatenation, and so forth) are not
                    available through the language proper. But before using a
                    macro, consider carefully whether there's a non-macro way
                    to achieve the same result. If you need to use a macro to
                    define an interface, contact
                    your project leads to request
                    a waiver of this rule.
                </p>

                <p>
                    The following usage pattern will avoid many problems
                    with macros; if you use macros, follow it whenever
                    possible:
                </p>

                <ul>
                    <li>Don't define macros in a <code>.h</code> file.</li>

                    <li>
                        <code>#define</code> macros right before you use
                        them, and <code>#undef</code> them right after.
                    </li>

                    <li>
                        Do not just <code>#undef</code> an existing macro
                        before replacing it with your own; instead, pick a name
                        that's likely to be unique.
                    </li>

                    <li>
                        Try not to use macros that expand to unbalanced C++
                        constructs, or at least document that behavior
                        well.
                    </li>

                    <li>
                        Prefer not using <code>##</code> to generate
                        function/class/variable names.
                    </li>
                </ul>

                <p>
                    Exporting macros from headers (i.e. defining them in a header
                    without <code>#undef</code>ing them before the end of the header)
                    is extremely strongly discouraged. If you do export a macro from a
                    header, it must have a globally unique name. To achieve this, it
                    must be named with a prefix consisting of your project's namespace
                    name (but upper case).
                </p>

            </div>

            <h3 id="0_and_nullptr/NULL">0 and nullptr/NULL</h3>

            <div class="summary">
                <p>
                    Use <code>0</code> for integers, <code>0.0</code> for
                    reals, <code>nullptr</code> (or <code>NULL</code>) for
                    pointers, and <code>'\0'</code> for chars.
                </p>
            </div>

            <div class="stylebody">

                <p>
                    Use <code>0</code> for integers and <code>0.0</code>
                    for reals. This is not controversial.
                </p>

                <p>
                    For
                    pointers (address values), there is a choice between
                    <code>0</code>, <code>NULL</code>, and
                    <code>nullptr</code>. For projects that allow C++11
                    features, use <code>nullptr</code>. For C++03 projects,
                    we prefer <code>NULL</code> because it looks like a
                    pointer. In fact, some C++ compilers provide special
                    definitions of <code>NULL</code> which enable them to
                    give useful warnings, particularly in situations where
                    <code>sizeof(NULL)</code> is not equal to
                    <code>sizeof(0)</code>.
                </p>

                <p>
                    Use <code>'\0'</code> for chars. This is the correct
                    type and also makes code more readable.
                </p>

            </div>

            <h3 id="sizeof">sizeof</h3>

            <div class="summary">
                <p>
                    Prefer <code>sizeof(<var>varname</var>)</code> to
                    <code>sizeof(<var>type</var>)</code>.
                </p>
            </div>

            <div class="stylebody">

                <p>
                    Use <code>sizeof(<var>varname</var>)</code> when you
                    take the size of a particular variable.
                    <code>sizeof(<var>varname</var>)</code> will update
                    appropriately if someone changes the variable type either
                    now or later. You may use
                    <code>sizeof(<var>type</var>)</code> for code unrelated
                    to any particular variable, such as code that manages an
                    external or internal data format where a variable of an
                    appropriate C++ type is not convenient.
                </p>

<pre>Struct data;
memset(&amp;data, 0, sizeof(data));
</pre>

<pre class="badcode">memset(&amp;data, 0, sizeof(Struct));
</pre>

<pre>if (raw_size &lt; sizeof(int)) {
  LOG(ERROR) &lt;&lt; "compressed record not big enough for count: " &lt;&lt; raw_size;
  return false;
}
</pre>

            </div>

            <h3 id="auto">auto</h3>

            <div class="summary">
                <p>
                    Use <code>auto</code> to avoid type names that are noisy, obvious,
                    or unimportant - cases where the type doesn't aid in clarity for the
                    reader. Continue to use manifest type declarations when it helps
                    readability.
                </p>
            </div>

            <div class="stylebody">

                <div class="pros">
                    <p>
                    </p><ul>
                        <li>
                            C++ type names can be long and cumbersome, especially when they
                            involve templates or namespaces.
                        </li>
                        <li>
                            When a C++ type name is repeated within a single declaration or a
                            small code region, the repetition may not be aiding readability.
                        </li>
                        <li>
                            It is sometimes safer to let the type be specified by the type of
                            the initialization expression, since that avoids the possibility of
                            unintended copies or type conversions.
                        </li>
                    </ul>
                </div>
                <div class="cons">

                    <p>
                        Sometimes code is clearer when types are manifest,
                        especially when a variable's initialization depends on
                        things that were declared far away. In expressions
                        like:
                    </p>

<pre class="badcode">auto foo = x.add_foo();
auto i = y.Find(key);
</pre>

                    <p>
                        it may not be obvious what the resulting types are if the type
                        of <code>y</code> isn't very well known, or if <code>y</code> was
                        declared many lines earlier.
                    </p>

                    <p>
                        Programmers have to understand the difference between
                        <code>auto</code> and <code>const auto&amp;</code> or
                        they'll get copies when they didn't mean to.
                    </p>

                    <p>
                        If an <code>auto</code> variable is used as part of an
                        interface, e.g. as a constant in a header, then a
                        programmer might change its type while only intending to
                        change its value, leading to a more radical API change
                        than intended.
                    </p>
                </div>

                <div class="decision">

                    <p>
                        <code>auto</code> is permitted when it increases readability,
                        particularly as described below. Never initialize an <code>auto</code>-typed
                        variable with a braced initializer list.
                    </p>

                    <p>
                        Specific cases where <code>auto</code> is allowed or encouraged:
                    </p><ul>
                        <li>
                            (Encouraged) For iterators and other long/cluttery type names, particularly
                            when the type is clear from context (calls
                            to <code>find</code>, <code>begin</code>, or <code>end</code> for
                            instance).
                        </li>
                        <li>
                            (Allowed) When the type is clear from local context (in the same expression
                            or within a few lines).  Initialization of a pointer or smart pointer
                            with calls
                            to <code>new</code>
                            commonly falls into this category, as does use of <code>auto</code> in
                            a range-based loop over a container whose type is spelled out
                            nearby.
                        </li>
                        <li>
                            (Allowed) When the type doesn't matter because it isn't being used for
                            anything other than equality comparison.
                        </li>
                        <li>
                            (Encouraged) When iterating over a map with a range-based loop
                            (because it is often assumed that the correct type
                            is <code>std::pair&lt;KeyType, ValueType&gt;</code> whereas it is actually
                            <code>std::pair&lt;const KeyType, ValueType&gt;</code>). This is
                            particularly well paired with local <code>key</code>
                            and <code>value</code> aliases for <code>.first</code>
                            and <code>.second</code> (often const-ref).
<pre class="code">for (const auto&amp; item : some_map) {
  const KeyType&amp; key = item.first;
  const ValType&amp; value = item.second;
  // The rest of the loop can now just refer to key and value,
  // a reader can see the types in question, and we've avoided
  // the too-common case of extra copies in this iteration.
}
</pre>
                        </li>
                    </ul>

                </div>

            </div>

            <h3 id="Braced_Initializer_List">Braced Initializer List</h3>

            <div class="summary">
                <p>You may use braced initializer lists.</p>
            </div>

            <div class="stylebody">

                <p>
                    In C++03, aggregate types (arrays and structs with no
                    constructor) could be initialized with braced initializer lists.
                </p>

<pre>struct Point { int x; int y; };
Point p = {1, 2};
</pre>

                <p>
                    In C++11, this syntax was generalized, and any object type can now
                    be created with a braced initializer list, known as a
                    <i>braced-init-list</i> in the C++ grammar. Here are a few examples
                    of its use.
                </p>

<pre>// Vector takes a braced-init-list of elements.
std::vector&lt;string&gt; v{"foo", "bar"};

// Basically the same, ignoring some small technicalities.
// You may choose to use either form.
std::vector&lt;string&gt; v = {"foo", "bar"};

// Usable with 'new' expressions.
auto p = new vector&lt;string&gt;{"foo", "bar"};

// A map can take a list of pairs. Nested braced-init-lists work.
std::map&lt;int, string&gt; m = {{1, "one"}, {2, "2"}};

// A braced-init-list can be implicitly converted to a return type.
std::vector&lt;int&gt; test_function() { return {1, 2, 3}; }

// Iterate over a braced-init-list.
for (int i : {-1, -2, -3}) {}

// Call a function using a braced-init-list.
void TestFunction2(std::vector&lt;int&gt; v) {}
TestFunction2({1, 2, 3});
</pre>

                <p>
                    A user-defined type can also define a constructor and/or assignment operator
                    that take <code>std::initializer_list&lt;T&gt;</code>, which is automatically
                    created from <i>braced-init-list</i>:
                </p>

<pre>class MyType {
 public:
  // std::initializer_list references the underlying init list.
  // It should be passed by value.
  MyType(std::initializer_list&lt;int&gt; init_list) {
    for (int i : init_list) append(i);
  }
  MyType&amp; operator=(std::initializer_list&lt;int&gt; init_list) {
    clear();
    for (int i : init_list) append(i);
  }
};
MyType m{2, 3, 5, 7};
</pre>

                <p>
                    Finally, brace initialization can also call ordinary
                    constructors of data types, even if they do not have
                    <code>std::initializer_list&lt;T&gt;</code> constructors.
                </p>

<pre>double d{1.23};
// Calls ordinary constructor as long as MyOtherType has no
// std::initializer_list constructor.
class MyOtherType {
 public:
  explicit MyOtherType(string);
  MyOtherType(int, string);
};
MyOtherType m = {1, "b"};
// If the constructor is explicit, you can't use the "= {}" form.
MyOtherType m{"b"};
</pre>

                <p>
                    Never assign a <i>braced-init-list</i> to an auto
                    local variable. In the single element case, what this
                    means can be confusing.
                </p>

<pre class="badcode">auto d = {1.23};        // d is a std::initializer_list&lt;double&gt;
</pre>

<pre>auto d = double{1.23};  // Good -- d is a double, not a std::initializer_list.
</pre>

                <p>See <a href="#Braced_Initializer_List_Format">Braced_Initializer_List_Format</a> for formatting.</p>

            </div>

            <h3 id="Lambda_expressions">Lambda expressions</h3>

            <div class="summary">
                <p>
                    Use lambda expressions where appropriate. Prefer explicit captures
                    when the lambda will escape the current scope.
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">

                    <p>
                        Lambda expressions are a concise way of creating anonymous
                        function objects. They're often useful when passing
                        functions as arguments. For example:
                    </p>

<pre>std::sort(v.begin(), v.end(), [](int x, int y) {
  return Weight(x) &lt; Weight(y);
});
</pre>

                    <p>
                        They further allow capturing variables from the enclosing scope either
                        explicitly by name, or implicitly using a default capture. Explicit captures
                        require each variable to be listed, as
                        either a value or reference capture:
                    </p>

<pre>int weight = 3;
int sum = 0;
// Captures `weight` by value and `sum` by reference.
std::for_each(v.begin(), v.end(), [weight, &amp;sum](int x) {
  sum += weight * x;
});
</pre>


                    Default captures implicitly capture any variable referenced in the
                    lambda body, including <code>this</code> if any members are used:

<pre>const std::vector&lt;int&gt; lookup_table = ...;
std::vector&lt;int&gt; indices = ...;
// Captures `lookup_table` by reference, sorts `indices` by the value
// of the associated element in `lookup_table`.
std::sort(indices.begin(), indices.end(), [&amp;](int a, int b) {
  return lookup_table[a] &lt; lookup_table[b];
});
</pre>

                    <p>
                        Lambdas were introduced in C++11 along with a set of utilities
                        for working with function objects, such as the polymorphic
                        wrapper <code>std::function</code>.
                    </p>
                </div>

                <div class="pros">
                    <ul>
                        <li>
                            Lambdas are much more concise than other ways of
                            defining function objects to be passed to STL
                            algorithms, which can be a readability
                            improvement.
                        </li>

                        <li>
                            Appropriate use of default captures can remove
                            redundancy and highlight important exceptions from
                            the default.
                        </li>

                        <li>
                            Lambdas, <code>std::function</code>, and
                            <code>std::bind</code> can be used in combination as a
                            general purpose callback mechanism; they make it easy
                            to write functions that take bound functions as
                            arguments.
                        </li>
                    </ul>
                </div>

                <div class="cons">
                    <ul>
                        <li>
                            Variable capture in lambdas can be a source of dangling-pointer
                            bugs, particularly if a lambda escapes the current scope.
                        </li>

                        <li>
                            Default captures by value can be misleading because they do not prevent
                            dangling-pointer bugs. Capturing a pointer by value doesn't cause a deep
                            copy, so it often has the same lifetime issues as capture by reference.
                            This is especially confusing when capturing 'this' by value, since the use
                            of 'this' is often implicit.
                        </li>

                        <li>
                            It's possible for use of lambdas to get out of
                            hand; very long nested anonymous functions can make
                            code harder to understand.
                        </li>

                    </ul>
                </div>

                <div class="decision">
                    <ul>
                        <li>
                            Use lambda expressions where appropriate, with formatting as
                            described <a href="#Formatting_Lambda_Expressions">below</a>.
                        </li>
                        <li>
                            Prefer explicit captures if the lambda may escape the current scope.
                            For example, instead of:
<pre class="badcode">{
  Foo foo;
  ...
  executor-&gt;Schedule([&amp;] { Frobnicate(foo); })
  ...
}
// BAD! The fact that the lambda makes use of a reference to `foo` and
// possibly `this` (if `Frobnicate` is a member function) may not be
// apparent on a cursory inspection. If the lambda is invoked after
// the function returns, that would be bad, because both `foo`
// and the enclosing object could have been destroyed.
</pre>
                            prefer to write:
<pre>{
  Foo foo;
  ...
  executor-&gt;Schedule([&amp;foo] { Frobnicate(foo); })
  ...
}
// BETTER - The compile will fail if `Frobnicate` is a member
// function, and it's clearer that `foo` is dangerously captured by
// reference.
</pre>
                        </li>
                        <li>
                            Use default capture by reference ([&amp;]) only when the
                            lifetime of the lambda is obviously shorter than any potential
                            captures.
                        </li>
                        <li>
                            Use default capture by value ([=]) only as a means of binding a
                            few variables for a short lambda, where the set of captured
                            variables is obvious at a glance. Prefer not to write long or
                            complex lambdas with default capture by value.
                        </li>
                        <li>
                            Keep unnamed lambdas short.  If a lambda body is more than
                            maybe five lines long, prefer to give the lambda a name, or to
                            use a named function instead of a lambda.
                        </li>
                        <li>
                            Specify the return type of the lambda explicitly if that will
                            make it more obvious to readers, as with
                            <a href="#auto"><code>auto</code></a>.
                        </li>

                    </ul>
                </div>

            </div>

            <h3 id="Template_metaprogramming">Template metaprogramming</h3>
            <div class="summary">
                <p>Avoid complicated template programming.</p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        Template metaprogramming refers to a family of techniques that
                        exploit the fact that the C++ template instantiation mechanism is
                        Turing complete and can be used to perform arbitrary compile-time
                        computation in the type domain.
                    </p>
                </div>

                <div class="pros">
                    <p>
                        Template metaprogramming allows extremely flexible interfaces that
                        are type safe and high performance. Facilities like

                        <a href="https://code.google.com/p/googletest/">Google Test</a>,
                        <code>std::tuple</code>, <code>std::function</code>, and
                        Boost.Spirit would be impossible without it.
                    </p>
                </div>

                <div class="cons">
                    <p>
                        The techniques used in template metaprogramming are often obscure
                        to anyone but language experts. Code that uses templates in
                        complicated ways is often unreadable, and is hard to debug or
                        maintain.
                    </p>

                    <p>
                        Template metaprogramming often leads to extremely poor compiler
                        time error messages: even if an interface is simple, the complicated
                        implementation details become visible when the user does something
                        wrong.
                    </p>

                    <p>
                        Template metaprogramming interferes with large scale refactoring by
                        making the job of refactoring tools harder. First, the template code
                        is expanded in multiple contexts, and it's hard to verify that the
                        transformation makes sense in all of them. Second, some refactoring
                        tools work with an AST that only represents the structure of the code
                        after template expansion. It can be difficult to automatically work
                        back to the original source construct that needs to be
                        rewritten.
                    </p>
                </div>

                <div class="decision">
                    <p>
                        Template metaprogramming sometimes allows cleaner and easier-to-use
                        interfaces than would be possible without it, but it's also often a
                        temptation to be overly clever. It's best used in a small number of
                        low level components where the extra maintenance burden is spread out
                        over a large number of uses.
                    </p>

                    <p>
                        Think twice before using template metaprogramming or other
                        complicated template techniques; think about whether the average
                        member of your team will be able to understand your code well enough
                        to maintain it after you switch to another project, or whether a
                        non-C++ programmer or someone casually browsing the code base will be
                        able to understand the error messages or trace the flow of a function
                        they want to call.  If you're using recursive template instantiations
                        or type lists or metafunctions or expression templates, or relying on
                        SFINAE or on the <code>sizeof</code> trick for detecting function
                        overload resolution, then there's a good chance you've gone too
                        far.
                    </p>

                    <p>
                        If you use template metaprogramming, you should expect to put
                        considerable effort into minimizing and isolating the complexity. You
                        should hide metaprogramming as an implementation detail whenever
                        possible, so that user-facing headers are readable, and you should
                        make sure that tricky code is especially well commented. You should
                        carefully document how the code is used, and you should say something
                        about what the "generated" code looks like. Pay extra attention to the
                        error messages that the compiler emits when users make mistakes.  The
                        error messages are part of your user interface, and your code should
                        be tweaked as necessary so that the error messages are understandable
                        and actionable from a user point of view.
                    </p>

                </div>
            </div>


            <h3 id="Boost">Boost</h3>

            <div class="summary">
                <p>
                    Use only approved libraries from the Boost library
                    collection.
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        The
                        <a href="https://www.boost.org/">
                            Boost library collection
                        </a> is a popular collection of
                        peer-reviewed, free, open-source C++ libraries.
                    </p>
                </div>

                <div class="pros">
                    <p>
                        Boost code is generally very high-quality, is widely
                        portable, and fills many important gaps in the C++
                        standard library, such as type traits and better binders.
                    </p>
                </div>

                <div class="cons">
                    <p>
                        Some Boost libraries encourage coding practices which can
                        hamper readability, such as metaprogramming and other
                        advanced template techniques, and an excessively
                        "functional" style of programming.
                    </p>
                </div>

                <div class="decision">



                    <div>
                        <p>
                            In order to maintain a high level of readability for
                            all contributors who might read and maintain code, we
                            only allow an approved subset of Boost features.
                            Currently, the following libraries are permitted:
                        </p>

                        <ul>
                            <li>
                                <a href="https://www.boost.org/libs/utility/call_traits.htm">
                                    Call Traits
                                </a> from <code>boost/call_traits.hpp</code>
                            </li>

                            <li>
                                <a href="https://www.boost.org/libs/utility/compressed_pair.htm">
                                    Compressed Pair
                                </a> from  <code>boost/compressed_pair.hpp</code>
                            </li>

                            <li>
                                <a href="https://www.boost.org/libs/graph/">
                                    The Boost Graph Library (BGL)
                                </a> from <code>boost/graph</code>,
                                except serialization (<code>adj_list_serialize.hpp</code>) and
                                parallel/distributed algorithms and data structures
                                (<code>boost/graph/parallel/*</code> and
                                <code>boost/graph/distributed/*</code>).
                            </li>

                            <li>
                                <a href="https://www.boost.org/libs/property_map/">
                                    Property Map
                                </a> from <code>boost/property_map</code>, except
                                parallel/distributed property maps (<code>boost/property_map/parallel/*</code>).
                            </li>

                            <li>
                                <a href="https://www.boost.org/libs/iterator/">
                                    Iterator
                                </a> from <code>boost/iterator</code>
                            </li>

                            <li>
                                The part of <a href="https://www.boost.org/libs/polygon/">
                                    Polygon
                                </a> that deals with Voronoi diagram
                                construction and doesn't depend on the rest of
                                Polygon:
                                <code>boost/polygon/voronoi_builder.hpp</code>,
                                <code>boost/polygon/voronoi_diagram.hpp</code>, and
                                <code>boost/polygon/voronoi_geometry_type.hpp</code>
                            </li>

                            <li>
                                <a href="https://www.boost.org/libs/bimap/">
                                    Bimap
                                </a> from <code>boost/bimap</code>
                            </li>

                            <li>
                                <a href="https://www.boost.org/libs/math/doc/html/dist.html">
                                    Statistical Distributions and Functions
                                </a> from
                                <code>boost/math/distributions</code>
                            </li>

                            <li>
                                <a href="https://www.boost.org/libs/math/doc/html/special.html">
                                    Special Functions
                                </a> from <code>boost/math/special_functions</code>
                            </li>

                            <li>
                                <a href="https://www.boost.org/libs/multi_index/">
                                    Multi-index
                                </a> from <code>boost/multi_index</code>
                            </li>

                            <li>
                                <a href="https://www.boost.org/libs/heap/">
                                    Heap
                                </a> from <code>boost/heap</code>
                            </li>

                            <li>
                                The flat containers from
                                <a href="https://www.boost.org/libs/container/">Container</a>:
                                <code>boost/container/flat_map</code>, and
                                <code>boost/container/flat_set</code>
                            </li>

                            <li>
                                <a href="https://www.boost.org/libs/intrusive/">Intrusive</a>
                                from <code>boost/intrusive</code>.
                            </li>

                            <li>
                                <a href="https://www.boost.org/libs/sort/">
                                    The
                                    <code>boost/sort</code> library
                                </a>.
                            </li>

                            <li>
                                <a href="https://www.boost.org/libs/preprocessor/">Preprocessor</a>
                                from <code>boost/preprocessor</code>.
                            </li>
                        </ul>

                        <p>
                            We are actively considering adding other Boost
                            features to the list, so this list may be expanded in
                            the future.
                        </p>
                    </div>

                    <p>
                        The following libraries are permitted, but their use
                        is discouraged because they've been superseded by
                        standard libraries in C++11:
                    </p>

                    <ul>
                        <li>
                            <a href="https://www.boost.org/libs/array/">
                                Array
                            </a> from <code>boost/array.hpp</code>: use
                            <a href="http://en.cppreference.com/w/cpp/container/array">
                                <code>std::array</code>
                            </a> instead.
                        </li>

                        <li>
                            <a href="https://www.boost.org/libs/ptr_container/">
                                Pointer Container
                            </a> from <code>boost/ptr_container</code>: use containers of
                            <a href="http://en.cppreference.com/w/cpp/memory/unique_ptr">
                                <code>std::unique_ptr</code>
                            </a> instead.
                        </li>
                    </ul>
                </div>

            </div>



            <h3 id="std_hash">std::hash</h3>

            <div class="summary">
                <p>Do not define specializations of <code>std::hash</code>.</p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        <code>std::hash&lt;T&gt;</code> is the function object that the
                        C++11 hash containers use to hash keys of type <code>T</code>,
                        unless the user explicitly specifies a different hash function. For
                        example, <code>std::unordered_map&lt;int, string&gt;</code> is a hash
                        map that uses <code>std::hash&lt;int&gt;</code> to hash its keys,
                        whereas <code>std::unordered_map&lt;int, string, MyIntHash&gt;</code>
                        uses <code>MyIntHash</code>.
                    </p>

                    <p>
                        <code>std::hash</code> is defined for all integral, floating-point,
                        pointer, and <code>enum</code> types, as well as some standard library
                        types such as <code>string</code> and <code>unique_ptr</code>. Users
                        can enable it to work for their own types by defining specializations
                        of it for those types.
                    </p>
                </div>

                <div class="pros">
                    <p>
                        <code>std::hash</code> is easy to use, and simplifies the code
                        since you don't have to name it explicitly. Specializing
                        <code>std::hash</code> is the standard way of specifying how to
                        hash a type, so it's what outside resources will teach, and what
                        new engineers will expect.
                    </p>
                </div>

                <div class="cons">
                    <p>
                        <code>std::hash</code> is hard to specialize. It requires a lot
                        of boilerplate code, and more importantly, it combines responsibility
                        for identifying the hash inputs with responsibility for executing the
                        hashing algorithm itself. The type author has to be responsible for
                        the former, but the latter requires expertise that a type author
                        usually doesn't have, and shouldn't need. The stakes here are high
                        because low-quality hash functions can be security vulnerabilities,
                        due to the emergence of
                        <a href="https://emboss.github.io/blog/2012/12/14/breaking-murmur-hash-flooding-dos-reloaded/">
                            hash flooding attacks
                        </a>.
                    </p>

                    <p>
                        Even for experts, <code>std::hash</code> specializations are
                        inordinately difficult to implement correctly for compound types,
                        because the implementation cannot recursively call <code>std::hash</code>
                        on data members. High-quality hash algorithms maintain large
                        amounts of internal state, and reducing that state to the
                        <code>size_t</code> bytes that <code>std::hash</code>
                        returns is usually the slowest part of the computation, so it
                        should not be done more than once.
                    </p>

                    <p>
                        Due to exactly that issue, <code>std::hash</code> does not work
                        with <code>std::pair</code> or <code>std::tuple</code>, and the
                        language does not allow us to extend it to support them.
                    </p>
                </div>

                <div class="decision">
                    <p>
                        You can use <code>std::hash</code> with the types that it supports
                        "out of the box", but do not specialize it to support additional types.
                        If you need a hash table with a key type that <code>std::hash</code>
                        does not support, consider using legacy hash containers (e.g.
                        <code>hash_map</code>) for now; they use a different default hasher,
                        which is unaffected by this prohibition.
                    </p>

                    <p>
                        If you want to use the standard hash containers anyway, you will
                        need to specify a custom hasher for the key type, e.g.
                    </p>
<pre>std::unordered_map&lt;MyKeyType, Value, MyKeyTypeHasher&gt; my_map;
</pre><p>
                        Consult with the type's owners to see if there is an existing hasher
                        that you can use; otherwise work with them to provide one,
                        or roll your own.
                    </p>

                    <p>
                        We are planning to provide a hash function that can work with any type,
                        using a new customization mechanism that doesn't have the drawbacks of
                        <code>std::hash</code>.
                    </p>
                </div>

            </div>

            <h3 id="C++11">C++11</h3>

            <div class="summary">
                <p>
                    Use libraries and language extensions from C++11 when appropriate.
                    Consider portability to other environments
                    before using C++11 features in your
                    project.
                </p>

            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        C++11 contains <a href="https://en.wikipedia.org/wiki/C%2B%2B11">
                            significant changes
                        </a> both to the language and
                        libraries.
                    </p>
                </div>

                <div class="pros">
                    <p>
                        C++11 was the official standard until august 2014, and
                        is supported by most C++ compilers. It standardizes
                        some common C++ extensions that we use already, allows
                        shorthands for some operations, and has some performance
                        and safety improvements.
                    </p>
                </div>

                <div class="cons">
                    <p>
                        The C++11 standard is substantially more complex than
                        its predecessor (1,300 pages versus 800 pages), and is
                        unfamiliar to many developers. The long-term effects of
                        some features on code readability and maintenance are
                        unknown. We cannot predict when its various features will
                        be implemented uniformly by tools that may be of
                        interest, particularly in the case of projects that are
                        forced to use older versions of tools.
                    </p>

                    <p>
                        As with <a href="#Boost">Boost</a>, some C++11
                        extensions encourage coding practices that hamper
                        readability&#8212;for example by removing
                        checked redundancy (such as type names) that may be
                        helpful to readers, or by encouraging template
                        metaprogramming. Other extensions duplicate functionality
                        available through existing mechanisms, which may lead to confusion
                        and conversion costs.
                    </p>


                </div>

                <div class="decision">

                    <p>
                        C++11 features may be used unless specified otherwise.
                        In addition to what's described in the rest of the style
                        guide, the following C++11 features may not be used:
                    </p>

                    <ul>








                        <li>
                            Compile-time rational numbers
                            (<code>&lt;ratio&gt;</code>), because of concerns that
                            it's tied to a more template-heavy interface
                            style.
                        </li>

                        <li>
                            The <code>&lt;cfenv&gt;</code> and
                            <code>&lt;fenv.h&gt;</code> headers, because many
                            compilers do not support those features reliably.
                        </li>

                        <li>
                            Ref-qualifiers on member functions, such as <code>
                                void X::Foo()
                                &amp;
                            </code> or <code>void X::Foo() &amp;&amp;</code>, because of concerns
                            that they're an overly obscure feature.
                        </li>




                    </ul>
                </div>

            </div>

            <h3 id="Nonstandard_Extensions">Nonstandard Extensions</h3>

            <div class="summary">
                <p>Nonstandard extensions to C++ may not be used unless otherwise specified.</p>
            </div>
            <div class="stylebody">
                <div class="definition">
                    <p>
                        Compilers support various extensions that are not part of standard C++. Such
                        extensions include GCC's <code>__attribute__</code>, intrinsic functions such
                        as <code>__builtin_prefetch</code>, designated initializers (e.g.
                        <code>Foo f = {.field = 3}</code>), inline assembly, <code>__COUNTER__</code>,
                        <code>__PRETTY_FUNCTION__</code>, compound statement expressions (e.g.
                        <code>foo = ({ int x; Bar(&amp;x); x })</code>, variable-length arrays and
                        <code>alloca()</code>, and the <code>a?:b</code> syntax.
                    </p>
                </div>

                <div class="pros">
                    <ul>
                        <li>
                            Nonstandard extensions may provide useful features that do not exist
                            in standard C++. For example, some people think that designated
                            initializers are more readable than standard C++ features like
                            constructors.
                        </li>
                        <li>
                            Important performance guidance to the compiler can only be specified
                            using extensions.
                        </li>
                    </ul>
                </div>

                <div class="cons">
                    <ul>
                        <li>
                            Nonstandard extensions do not work in all compilers. Use of nonstandard
                            extensions reduces portability of code.
                        </li>
                        <li>
                            Even if they are supported in all targeted compilers, the extensions
                            are often not well-specified, and there may be subtle behavior differences
                            between compilers.
                        </li>
                        <li>
                            Nonstandard extensions add to the language features that a reader must
                            know to understand the code.
                        </li>
                    </ul>
                </div>

                <div class="decision">
                    <p>
                        Do not use nonstandard extensions. You may use portability wrappers that
                        are implemented using nonstandard extensions, so long as those wrappers

                        are provided by a designated project-wide
                        portability header.
                    </p>
                </div>
            </div>

            <h3 id="Aliases">Aliases</h3>

            <div class="summary">
                <p>Public aliases are for the benefit of an API's user, and should be clearly documented.</p>
            </div>
            <div class="stylebody">
                <div class="definition">
                    <p>There are several ways to create names that are aliases of other entities:</p>
<pre>typedef Foo Bar;
using Bar = Foo;
using other_namespace::Foo;
</pre>

                    <p>
                        Like other declarations, aliases declared in a header file are part of that
                        header's public API unless they're in a function definition, in the private portion of a class,
                        or in an explicitly-marked internal namespace. Aliases in such areas or in .cc files are
                        implementation details (because client code can't refer to them), and are not restricted by this
                        rule.
                    </p>
                </div>

                <div class="pros">
                    <ul>
                        <li>Aliases can improve readability by simplifying a long or complicated name.</li>
                        <li>
                            Aliases can reduce duplication by naming in one place a type used repeatedly in an API,
                            which <em>might</em> make it easier to change the type later.
                        </li>
                    </ul>
                </div>

                <div class="cons">
                    <ul>
                        <li>
                            When placed in a header where client code can refer to them, aliases increase the
                            number of entities in that header's API, increasing its complexity.
                        </li>
                        <li>
                            Clients can easily rely on unintended details of public aliases, making
                            changes difficult.
                        </li>
                        <li>
                            It can be tempting to create a public alias that is only intended for use
                            in the implementation, without considering its impact on the API, or on maintainability.
                        </li>
                        <li>Aliases can create risk of name collisions</li>
                        <li>Aliases can reduce readability by giving a familiar construct an unfamiliar name</li>
                        <li>
                            Type aliases can create an unclear API contract:
                            it is unclear whether the alias is guaranteed to be identical to the type it aliases,
                            to have the same API, or only to be usable in specified narrow ways
                        </li>
                    </ul>
                </div>

                <div class="decision">
                    <p>
                        Don't put an alias in your public API just to save typing in the implementation;
                        do so only if you intend it to be used by your clients.
                    </p>
                    <p>
                        When defining a public alias, document the intent of
                        the new name, including whether it is guaranteed to always be the same as the type
                        it's currently aliased to, or whether a more limited compatibility is
                        intended. This lets the user know whether they can treat the types as
                        substitutable or whether more specific rules must be followed, and can help the
                        implementation retain some degree of freedom to change the alias.
                    </p>
                    <p>
                        Don't put namespace aliases in your public API. (See also <a href="#Namespaces">Namespaces</a>).
                    </p>

                    <p>For example, these aliases document how they are intended to be used in client code:</p>
<pre>namespace a {
// Used to store field measurements. DataPoint may change from Bar* to some internal type.
// Client code should treat it as an opaque pointer.
using DataPoint = foo::bar::Bar*;

// A set of measurements. Just an alias for user convenience.
using TimeSeries = std::unordered_set&lt;DataPoint, std::hash&lt;DataPoint&gt;, DataPointComparator&gt;;
}  // namespace a
</pre>

                    <p>These aliases don't document intended use, and half of them aren't meant for client use:</p>

<pre class="badcode">namespace a {
// Bad: none of these say how they should be used.
using DataPoint = foo::bar::Bar*;
using std::unordered_set;  // Bad: just for local convenience
using std::hash;           // Bad: just for local convenience
typedef unordered_set&lt;DataPoint, hash&lt;DataPoint&gt;, DataPointComparator&gt; TimeSeries;
}  // namespace a
</pre>

                    <p>
                        However, local convenience aliases are fine in function definitions, private sections of
                        classes, explicitly marked internal namespaces, and in .cc files:
                    </p>

<pre>// In a .cc file
using std::unordered_set;
</pre>

                </div>
            </div>

            <h2 id="Naming">Naming</h2>

            <p>
                The most important consistency rules are those that govern
                naming. The style of a name immediately informs us what sort of
                thing the named entity is: a type, a variable, a function, a
                constant, a macro, etc., without requiring us to search for the
                declaration of that entity. The pattern-matching engine in our
                brains relies a great deal on these naming rules.
            </p>

            <p>
                Naming rules are pretty arbitrary, but
                we feel that
                consistency is more important than individual preferences in this
                area, so regardless of whether you find them sensible or not,
                the rules are the rules.
            </p>

            <h3 id="General_Naming_Rules">General Naming Rules</h3>

            <div class="summary">
                <p>Names should be descriptive; avoid abbreviation.</p>
            </div>

            <div class="stylebody">
                <p>
                    Give as descriptive a name as possible, within reason.
                    Do not worry about saving horizontal space as it is far
                    more important to make your code immediately
                    understandable by a new reader. Do not use abbreviations
                    that are ambiguous or unfamiliar to readers outside your
                    project, and do not abbreviate by deleting letters within
                    a word.
                </p>

<pre>int price_count_reader;    // No abbreviation.
int num_errors;            // "num" is a widespread convention.
int num_dns_connections;   // Most people know what "DNS" stands for.
</pre>

<pre class="badcode">int n;                     // Meaningless.
int nerr;                  // Ambiguous abbreviation.
int n_comp_conns;          // Ambiguous abbreviation.
int wgc_connections;       // Only your group knows what this stands for.
int pc_reader;             // Lots of things can be abbreviated "pc".
int cstmr_id;              // Deletes internal letters.
</pre>

                <p>
                    Note that certain universally-known abbreviations are OK, such as
                    <code>i</code> for an iteration variable and <code>T</code> for a
                    template parameter.
                </p>

                <p>
                    Template parameters should follow the naming style for their
                    category: type template parameters should follow the rules for
                    <a href="#Type_Names">type names</a>, and non-type template
                    parameters should follow the rules for <a href="#Variable_Names">
                        variable names
                    </a>.

                </p>
            </div>

            <h3 id="File_Names">File Names</h3>

            <div class="summary">
                <p>
                    Filenames should be all lowercase and can include
                    underscores (<code>_</code>) or dashes (<code>-</code>).
                    Follow the convention that your

                    project uses. If there is no consistent
                    local pattern to follow, prefer "_".
                </p>
            </div>

            <div class="stylebody">

                <p>Examples of acceptable file names:</p>

                <ul>
                    <li><code>my_useful_class.cc</code></li>
                    <li><code>my-useful-class.cc</code></li>
                    <li><code>myusefulclass.cc</code></li>
                    <li><code>myusefulclass_test.cc // _unittest and _regtest are deprecated.</code></li>
                </ul>

                <p>
                    C++ files should end in <code>.cc</code> and header files should end in
                    <code>.h</code>. Files that rely on being textually included at specific points
                    should end in <code>.inc</code> (see also the section on
                    <a href="#Self_contained_Headers">self-contained headers</a>).
                </p>

                <p>
                    Do not use filenames that already exist in
                    <code>/usr/include</code>, such as <code>db.h</code>.
                </p>

                <p>
                    In general, make your filenames very specific. For
                    example, use <code>http_server_logs.h</code> rather than
                    <code>logs.h</code>. A very common case is to have a pair
                    of files called, e.g., <code>foo_bar.h</code> and
                    <code>foo_bar.cc</code>, defining a class called
                    <code>FooBar</code>.
                </p>

                <p>
                    Inline functions must be in a <code>.h</code> file. If
                    your inline functions are very short, they should go
                    directly into your <code>.h</code> file.
                </p>

            </div>

            <h3 id="Type_Names">Type Names</h3>

            <div class="summary">
                <p>
                    Type names start with a capital letter and have a capital
                    letter for each new word, with no underscores:
                    <code>MyExcitingClass</code>, <code>MyExcitingEnum</code>.
                </p>
            </div>

            <div class="stylebody">

                <p>
                    The names of all types &#8212; classes, structs, type aliases,
                    enums, and type template parameters &#8212; have the same naming convention.
                    Type names should start with a capital letter and have a capital letter
                    for each new word. No underscores. For example:
                </p>

<pre>// classes and structs
class UrlTable { ...
class UrlTableTester { ...
struct UrlTableProperties { ...

// typedefs
typedef hash_map&lt;UrlTableProperties *, string&gt; PropertiesMap;

// using aliases
using PropertiesMap = hash_map&lt;UrlTableProperties *, string&gt;;

// enums
enum UrlTableErrors { ...
</pre>

            </div>

            <h3 id="Variable_Names">Variable Names</h3>

            <div class="summary">
                <p>
                    The names of variables (including function parameters) and data members are
                    all lowercase, with underscores between words. Data members of classes (but not
                    structs) additionally have trailing underscores. For instance:
                    <code>a_local_variable</code>, <code>a_struct_data_member</code>,
                    <code>a_class_data_member_</code>.
                </p>
            </div>

            <div class="stylebody">

                <h4 class="stylepoint_subsection">Common Variable names</h4>

                <p>For example:</p>

<pre>string table_name;  // OK - uses underscore.
string tablename;   // OK - all lowercase.
</pre>

<pre class="badcode">string tableName;   // Bad - mixed case.
</pre>

                <h4 class="stylepoint_subsection">Class Data Members</h4>

                <p>
                    Data members of classes, both static and non-static, are
                    named like ordinary nonmember variables, but with a
                    trailing underscore.
                </p>

<pre>class TableInfo {
  ...
 private:
  string table_name_;  // OK - underscore at end.
  string tablename_;   // OK.
  static Pool&lt;TableInfo&gt;* pool_;  // OK.
};
</pre>

                <h4 class="stylepoint_subsection">Struct Data Members</h4>

                <p>
                    Data members of structs, both static and non-static,
                    are named like ordinary nonmember variables. They do not have
                    the trailing underscores that data members in classes have.
                </p>

<pre>struct UrlTableProperties {
  string name;
  int num_entries;
  static Pool&lt;UrlTableProperties&gt;* pool;
};
</pre>


                <p>
                    See <a href="#Structs_vs._Classes">
                        Structs vs.
                        Classes
                    </a> for a discussion of when to use a struct
                    versus a class.
                </p>

            </div>

            <h3 id="Constant_Names">Constant Names</h3>

            <div class="summary">
                <p>
                    Variables declared constexpr or const, and whose value is fixed for
                    the duration of the program, are named with a leading "k" followed
                    by mixed case.  For example:
                </p>
            </div>

<pre>const int kDaysInAWeek = 7;
</pre>

            <div class="stylebody">

                <p>
                    All such variables with static storage duration (i.e. statics and globals,
                    see <a href="http://en.cppreference.com/w/cpp/language/storage_duration#Storage_duration">
                        Storage Duration
                    </a> for details) should be named this way.  This
                    convention is optional for variables of other storage classes, e.g. automatic
                    variables, otherwise the usual variable naming rules apply.
                </p><p>

                </p>
            </div>

            <h3 id="Function_Names">Function Names</h3>

            <div class="summary">
                <p>
                    Regular functions have mixed case; accessors and mutators may be named
                    like variables.
                </p>
            </div>

            <div class="stylebody">

                <p>
                    Ordinarily, functions should start with a capital letter and have a
                    capital letter for each new word
                    (a.k.a. "<a href="https://en.wikipedia.org/wiki/Camel_case">
                        Camel
                        Case
                    </a>" or "Pascal case"). Such names should not have
                    underscores. Prefer to capitalize acronyms as single words
                    (i.e. <code>StartRpc()</code>, not <code>StartRPC()</code>).
                </p>

<pre>AddTableEntry()
DeleteUrl()
OpenFileOrDie()
</pre>

                <p>
                    (The same naming rule applies to class- and namespace-scope
                    constants that are exposed as part of an API and that are intended to look
                    like functions, because the fact that they're
                    objects rather than functions is an unimportant implementation detail.)
                </p>

                <p>
                    Accessors and mutators (get and set functions) may be named like
                    variables. These often correspond to actual member variables, but this is
                    not required. For example, <code>int count()</code> and <code>
                        void
                        set_count(int count)
                    </code>.
                </p>

            </div>

            <h3 id="Namespace_Names">Namespace Names</h3>

            <div class="summary">
                Namespace names are all lower-case. Top-level namespace names are
                based on the project name
                . Avoid collisions
                between nested namespaces and well-known top-level namespaces.
            </div>

            <div class="stylebody">
                <p>
                    The name of a top-level namespace should usually be the
                    name of the project or team whose code is contained in that
                    namespace. The code in that namespace should usually be in
                    a directory whose basename matches the namespace name (or
                    subdirectories thereof).
                </p>





                <p>
                    Keep in mind that the <a href="#General_Naming_Rules">
                        rule
                        against abbreviated names
                    </a> applies to namespaces just as much
                    as variable names. Code inside the namespace seldom needs to
                    mention the namespace name, so there's usually no particular need
                    for abbreviation anyway.
                </p>

                <p>
                    Avoid nested namespaces that match well-known top-level
                    namespaces. Collisions between namespace names can lead to surprising
                    build breaks because of name lookup rules. In particular, do not
                    create any nested <code>std</code> namespaces. Prefer unique project
                    identifiers
                    (<code>websearch::index</code>, <code>websearch::index_util</code>)
                    over collision-prone names like <code>websearch::util</code>.
                </p>

                <p>
                    For <code>internal</code> namespaces, be wary of other code being
                    added to the same <code>internal</code> namespace causing a collision
                    (internal helpers within a team tend to be related and may lead to
                    collisions). In such a situation, using the filename to make a unique
                    internal name is helpful
                    (<code>websearch::index::frobber_internal</code> for use
                    in <code>frobber.h</code>)
                </p>

            </div>

            <h3 id="Enumerator_Names">Enumerator Names</h3>

            <div class="summary">
                <p>
                    Enumerators (for both scoped and unscoped enums) should be named <i>either</i> like
                    <a href="#Constant_Names">constants</a> or like
                    <a href="#Macro_Names">macros</a>: either <code>kEnumName</code> or
                    <code>ENUM_NAME</code>.
                </p>
            </div>

            <div class="stylebody">

                <p>
                    Preferably, the individual enumerators should be named
                    like <a href="#Constant_Names">constants</a>. However, it
                    is also acceptable to name them like
                    <a href="#Macro_Names">macros</a>.  The enumeration name,
                    <code>UrlTableErrors</code> (and
                    <code>AlternateUrlTableErrors</code>), is a type, and
                    therefore mixed case.
                </p>

<pre>enum UrlTableErrors {
  kOK = 0,
  kErrorOutOfMemory,
  kErrorMalformedInput,
};
enum AlternateUrlTableErrors {
  OK = 0,
  OUT_OF_MEMORY = 1,
  MALFORMED_INPUT = 2,
};
</pre>

                <p>
                    Until January 2009, the style was to name enum values
                    like <a href="#Macro_Names">macros</a>. This caused
                    problems with name collisions between enum values and
                    macros. Hence, the change to prefer constant-style naming
                    was put in place. New code should prefer constant-style
                    naming if possible. However, there is no reason to change
                    old code to use constant-style names, unless the old
                    names are actually causing a compile-time problem.
                </p>



            </div>

            <h3 id="Macro_Names">Macro Names</h3>

            <div class="summary">
                <p>
                    You're not really going to <a href="#Preprocessor_Macros">
                        define a macro
                    </a>, are you? If you do, they're like this:
                    <code>MY_MACRO_THAT_SCARES_SMALL_CHILDREN</code>.
                </p>
            </div>

            <div class="stylebody">

                <p>
                    Please see the <a href="#Preprocessor_Macros">
                        description
                        of macros
                    </a>; in general macros should <em>not</em> be used.
                    However, if they are absolutely needed, then they should be
                    named with all capitals and underscores.
                </p>

<pre>#define ROUND(x) ...
#define PI_ROUNDED 3.0
</pre>

            </div>

            <h3 id="Exceptions_to_Naming_Rules">Exceptions to Naming Rules</h3>

            <div class="summary">
                <p>
                    If you are naming something that is analogous to an
                    existing C or C++ entity then you can follow the existing
                    naming convention scheme.
                </p>
            </div>

            <div class="stylebody">

                <dl>
                    <dt><code>bigopen()</code></dt>
                    <dd>function name, follows form of <code>open()</code></dd>

                    <dt><code>uint</code></dt>
                    <dd><code>typedef</code></dd>

                    <dt><code>bigpos</code></dt>
                    <dd>
                        <code>struct</code> or <code>class</code>, follows
                        form of <code>pos</code>
                    </dd>

                    <dt><code>sparse_hash_map</code></dt>
                    <dd>STL-like entity; follows STL naming conventions</dd>

                    <dt><code>LONGLONG_MAX</code></dt>
                    <dd>a constant, as in <code>INT_MAX</code></dd>
                </dl>

            </div>

            <h2 id="Comments">Comments</h2>

            <p>
                Though a pain to write, comments are absolutely vital to
                keeping our code readable. The following rules describe what
                you should comment and where. But remember: while comments are
                very important, the best code is self-documenting. Giving
                sensible names to types and variables is much better than using
                obscure names that you must then explain through comments.
            </p>

            <p>
                When writing your comments, write for your audience: the
                next
                contributor who will need to
                understand your code. Be generous &#8212; the next
                one may be you!
            </p>

            <h3 id="Comment_Style">Comment Style</h3>

            <div class="summary">
                <p>
                    Use either the <code>//</code> or <code>/* */</code>
                    syntax, as long as you are consistent.
                </p>
            </div>

            <div class="stylebody">

                <p>
                    You can use either the <code>//</code> or the <code>
                        /*
                        */
                    </code> syntax; however, <code>//</code> is
                    <em>much</em> more common. Be consistent with how you
                    comment and what style you use where.
                </p>

            </div>

            <h3 id="File_Comments">File Comments</h3>

            <div class="summary">
                <p>Start each file with license boilerplate.</p>

                <p>
                    File comments describe the contents of a file. If a file declares,
                    implements, or tests exactly one abstraction that is documented by a comment
                    at the point of declaration, file comments are not required. All other files
                    must have file comments.
                </p>

            </div>

            <div class="stylebody">

                <h4 class="stylepoint_subsection">
                    Legal Notice and Author
                    Line
                </h4>



                <p>
                    Every file should contain license
                    boilerplate. Choose the appropriate boilerplate for the
                    license used by the project (for example, Apache 2.0,
                    BSD, LGPL, GPL).
                </p>

                <p>
                    If you make significant changes to a file with an
                    author line, consider deleting the author line.
                </p>

                <h4 class="stylepoint_subsection">File Contents</h4>

                <p>
                    If a <code>.h</code> declares multiple abstractions, the file-level comment
                    should broadly describe the contents of the file, and how the abstractions are
                    related. A 1 or 2 sentence file-level comment may be sufficient. The detailed
                    documentation about individual abstractions belongs with those abstractions,
                    not at the file level.
                </p>

                <p>
                    Do not duplicate comments in both the <code>.h</code> and the
                    <code>.cc</code>. Duplicated comments diverge.
                </p>

            </div>

            <h3 id="Class_Comments">Class Comments</h3>

            <div class="summary">
                <p>
                    Every non-obvious class declaration should have an accompanying
                    comment that describes what it is for and how it should be used.
                </p>
            </div>

            <div class="stylebody">

<pre>// Iterates over the contents of a GargantuanTable.
// Example:
//    GargantuanTableIterator* iter = table-&gt;NewIterator();
//    for (iter-&gt;Seek("foo"); !iter-&gt;done(); iter-&gt;Next()) {
//      process(iter-&gt;key(), iter-&gt;value());
//    }
//    delete iter;
class GargantuanTableIterator {
  ...
};
</pre>

                <p>
                    The class comment should provide the reader with enough information to know
                    how and when to use the class, as well as any additional considerations
                    necessary to correctly use the class. Document the synchronization assumptions
                    the class makes, if any. If an instance of the class can be accessed by
                    multiple threads, take extra care to document the rules and invariants
                    surrounding multithreaded use.
                </p>

                <p>
                    The class comment is often a good place for a small example code snippet
                    demonstrating a simple and focused usage of the class.
                </p>

                <p>
                    When sufficiently separated (e.g. <code>.h</code> and <code>.cc</code>
                    files), comments describing the use of the class should go together with its
                    interface definition; comments about the class operation and implementation
                    should accompany the implementation of the class's methods.
                </p>

            </div>

            <h3 id="Function_Comments">Function Comments</h3>

            <div class="summary">
                <p>
                    Declaration comments describe use of the function (when it is
                    non-obvious); comments at the definition of a function describe
                    operation.
                </p>
            </div>

            <div class="stylebody">

                <h4 class="stylepoint_subsection">Function Declarations</h4>

                <p>
                    Almost every function declaration should have comments immediately
                    preceding it that describe what the function does and how to use
                    it. These comments may be omitted only if the function is simple and
                    obvious (e.g. simple accessors for obvious properties of the
                    class).  These comments should be descriptive ("Opens the file")
                    rather than imperative ("Open the file"); the comment describes the
                    function, it does not tell the function what to do. In general, these
                    comments do not describe how the function performs its task. Instead,
                    that should be left to comments in the function definition.
                </p>

                <p>
                    Types of things to mention in comments at the function
                    declaration:
                </p>

                <ul>
                    <li>What the inputs and outputs are.</li>

                    <li>
                        For class member functions: whether the object
                        remembers reference arguments beyond the duration of
                        the method call, and whether it will free them or
                        not.
                    </li>

                    <li>
                        If the function allocates memory that the caller
                        must free.
                    </li>

                    <li>
                        Whether any of the arguments can be a null
                        pointer.
                    </li>

                    <li>
                        If there are any performance implications of how a
                        function is used.
                    </li>

                    <li>
                        If the function is re-entrant. What are its
                        synchronization assumptions?
                    </li>
                </ul>

                <p>Here is an example:</p>

<pre>// Returns an iterator for this table.  It is the client's
// responsibility to delete the iterator when it is done with it,
// and it must not use the iterator once the GargantuanTable object
// on which the iterator was created has been deleted.
//
// The iterator is initially positioned at the beginning of the table.
//
// This method is equivalent to:
//    Iterator* iter = table-&gt;NewIterator();
//    iter-&gt;Seek("");
//    return iter;
// If you are going to immediately seek to another place in the
// returned iterator, it will be faster to use NewIterator()
// and avoid the extra seek.
Iterator* GetIterator() const;
</pre>

                <p>
                    However, do not be unnecessarily verbose or state the
                    completely obvious. Notice below that it is not necessary
                    to say "returns false otherwise" because this is
                    implied.
                </p>

<pre>// Returns true if the table cannot hold any more entries.
bool IsTableFull();
</pre>

                <p>
                    When documenting function overrides, focus on the
                    specifics of the override itself, rather than repeating
                    the comment from the overridden function.  In many of these
                    cases, the override needs no additional documentation and
                    thus no comment is required.
                </p>

                <p>
                    When commenting constructors and destructors, remember
                    that the person reading your code knows what constructors
                    and destructors are for, so comments that just say
                    something like "destroys this object" are not useful.
                    Document what constructors do with their arguments (for
                    example, if they take ownership of pointers), and what
                    cleanup the destructor does. If this is trivial, just
                    skip the comment. It is quite common for destructors not
                    to have a header comment.
                </p>

                <h4 class="stylepoint_subsection">Function Definitions</h4>

                <p>
                    If there is anything tricky about how a function does
                    its job, the function definition should have an
                    explanatory comment. For example, in the definition
                    comment you might describe any coding tricks you use,
                    give an overview of the steps you go through, or explain
                    why you chose to implement the function in the way you
                    did rather than using a viable alternative. For instance,
                    you might mention why it must acquire a lock for the
                    first half of the function but why it is not needed for
                    the second half.
                </p>

                <p>
                    Note you should <em>not</em> just repeat the comments
                    given with the function declaration, in the
                    <code>.h</code> file or wherever. It's okay to
                    recapitulate briefly what the function does, but the
                    focus of the comments should be on how it does it.
                </p>

            </div>

            <h3 id="Variable_Comments">Variable Comments</h3>

            <div class="summary">
                <p>
                    In general the actual name of the variable should be
                    descriptive enough to give a good idea of what the variable
                    is used for. In certain cases, more comments are required.
                </p>
            </div>

            <div class="stylebody">

                <h4 class="stylepoint_subsection">Class Data Members</h4>

                <p>
                    The purpose of each class data member (also called an instance
                    variable or member variable) must be clear. If there are any
                    invariants (special values, relationships between members, lifetime
                    requirements) not clearly expressed by the type and name, they must be
                    commented. However, if the type and name suffice (<code>
                        int
                        num_events_;
                    </code>), no comment is needed.
                </p>

                <p>
                    In particular, add comments to describe the existence and meaning
                    of sentinel values, such as nullptr or -1, when they are not
                    obvious. For example:
                </p>

<pre>private:
 // Used to bounds-check table accesses. -1 means
 // that we don't yet know how many entries the table has.
 int num_total_entries_;
</pre>

                <h4 class="stylepoint_subsection">Global Variables</h4>

                <p>
                    All global variables should have a comment describing what they
                    are, what they are used for, and (if unclear) why it needs to be
                    global. For example:
                </p>

<pre>// The total number of tests cases that we run through in this regression test.
const int kNumTestCases = 6;
</pre>

            </div>

            <h3 id="Implementation_Comments">Implementation Comments</h3>

            <div class="summary">
                <p>
                    In your implementation you should have comments in tricky,
                    non-obvious, interesting, or important parts of your code.
                </p>
            </div>

            <div class="stylebody">

                <h4 class="stylepoint_subsection">Explanatory Comments</h4>

                <p>
                    Tricky or complicated code blocks should have comments
                    before them. Example:
                </p>

<pre>// Divide result by two, taking into account that x
// contains the carry from the add.
for (int i = 0; i &lt; result-&gt;size(); i++) {
  x = (x &lt;&lt; 8) + (*result)[i];
  (*result)[i] = x &gt;&gt; 1;
  x &amp;= 1;
}
</pre>

                <h4 class="stylepoint_subsection">Line Comments</h4>

                <p>
                    Also, lines that are non-obvious should get a comment
                    at the end of the line. These end-of-line comments should
                    be separated from the code by 2 spaces. Example:
                </p>

<pre>// If we have enough memory, mmap the data portion too.
mmap_budget = max&lt;int64&gt;(0, mmap_budget - index_-&gt;length());
if (mmap_budget &gt;= data_size_ &amp;&amp; !MmapData(mmap_chunk_bytes, mlock))
  return;  // Error already logged.
</pre>

                <p>
                    Note that there are both comments that describe what
                    the code is doing, and comments that mention that an
                    error has already been logged when the function
                    returns.
                </p>

                <p>
                    If you have several comments on subsequent lines, it
                    can often be more readable to line them up:
                </p>

<pre>DoSomething();                  // Comment here so the comments line up.
DoSomethingElseThatIsLonger();  // Two spaces between the code and the comment.
{ // One space before comment when opening a new scope is allowed,
  // thus the comment lines up with the following comments and code.
  DoSomethingElse();  // Two spaces before line comments normally.
}
std::vector&lt;string&gt; list{
                    // Comments in braced lists describe the next element...
                    "First item",
                    // .. and should be aligned appropriately.
                    "Second item"};
DoSomething(); /* For trailing block comments, one space is fine. */
</pre>

                <h4 class="stylepoint_subsection">Function Argument Comments</h4>

                <p>
                    When the meaning of a function argument is nonobvious, consider
                    one of the following remedies:
                </p>

                <ul>
                    <li>
                        If the argument is a literal constant, and the same constant is
                        used in multiple function calls in a way that tacitly assumes they're
                        the same, you should use a named constant to make that constraint
                        explicit, and to guarantee that it holds.
                    </li>

                    <li>
                        Consider changing the function signature to replace a <code>bool</code>
                        argument with an <code>enum</code> argument. This will make the argument
                        values self-describing.
                    </li>

                    <li>
                        For functions that have several configuration options, consider
                        defining a single class or struct to hold all the options
                        ,
                        and pass an instance of that.
                        This approach has several advantages. Options are referenced by name
                        at the call site, which clarifies their meaning. It also reduces
                        function argument count, which makes function calls easier to read and
                        write. As an added benefit, you don't have to change call sites when
                        you add another option.
                    </li>

                    <li>Replace large or complex nested expressions with named variables.</li>

                    <li>
                        As a last resort, use comments to clarify argument meanings at the
                        call site.
                    </li>
                </ul>

                Consider the following example:

<pre class="badcode">// What are these arguments?
const DecimalNumber product = CalculateProduct(values, 7, false, nullptr);
</pre>

                <p>versus:</p>

<pre>ProductOptions options;
options.set_precision_decimals(7);
options.set_use_cache(ProductOptions::kDontUseCache);
const DecimalNumber product =
    CalculateProduct(values, options, /*completion_callback=*/nullptr);
</pre>

                <h4 class="stylepoint_subsection">Don'ts</h4>

                <p>
                    Do not state the obvious. In particular, don't literally describe what
                    code does, unless the behavior is nonobvious to a reader who understands
                    C++ well. Instead, provide higher level comments that describe <i>why</i>
                    the code does what it does, or make the code self describing.
                </p>

                Compare this:

<pre class="badcode">// Find the element in the vector.  &lt;-- Bad: obvious!
auto iter = std::find(v.begin(), v.end(), element);
if (iter != v.end()) {
  Process(element);
}
</pre>

                To this:

<pre>// Process "element" unless it was already processed.
auto iter = std::find(v.begin(), v.end(), element);
if (iter != v.end()) {
  Process(element);
}
</pre>

                Self-describing code doesn't need a comment. The comment from
                the example above would be obvious:

<pre>if (!IsAlreadyProcessed(element)) {
  Process(element);
}
</pre>

            </div>

            <h3 id="Punctuation,_Spelling_and_Grammar">Punctuation, Spelling and Grammar</h3>

            <div class="summary">
                <p>
                    Pay attention to punctuation, spelling, and grammar; it is
                    easier to read well-written comments than badly written
                    ones.
                </p>
            </div>

            <div class="stylebody">

                <p>
                    Comments should be as readable as narrative text, with
                    proper capitalization and punctuation. In many cases,
                    complete sentences are more readable than sentence
                    fragments. Shorter comments, such as comments at the end
                    of a line of code, can sometimes be less formal, but you
                    should be consistent with your style.
                </p>

                <p>
                    Although it can be frustrating to have a code reviewer
                    point out that you are using a comma when you should be
                    using a semicolon, it is very important that source code
                    maintain a high level of clarity and readability. Proper
                    punctuation, spelling, and grammar help with that
                    goal.
                </p>

            </div>

            <h3 id="TODO_Comments">TODO Comments</h3>

            <div class="summary">
                <p>
                    Use <code>TODO</code> comments for code that is temporary,
                    a short-term solution, or good-enough but not perfect.
                </p>
            </div>

            <div class="stylebody">

                <p>
                    <code>TODO</code>s should include the string
                    <code>TODO</code> in all caps, followed by the

                    name, e-mail address, bug ID, or other
                    identifier
                    of the person or issue with the best context
                    about the problem referenced by the <code>TODO</code>. The
                    main purpose is to have a consistent <code>TODO</code> that
                    can be searched to find out how to get more details upon
                    request. A <code>TODO</code> is not a commitment that the
                    person referenced will fix the problem. Thus when you create
                    a <code>TODO</code> with a name, it is almost always your
                    name that is given.
                </p>



                <div>
<pre>// TODO(kl@gmail.com): Use a "*" here for concatenation operator.
// TODO(Zeke) change this to use relations.
// TODO(bug 12345): remove the "Last visitors" feature
</pre>
                </div>

                <p>
                    If your <code>TODO</code> is of the form "At a future
                    date do something" make sure that you either include a
                    very specific date ("Fix by November 2005") or a very
                    specific event ("Remove this code when all clients can
                    handle XML responses.").
                </p>

            </div>

            <h3 id="Deprecation_Comments">Deprecation Comments</h3>

            <div class="summary">
                <p>
                    Mark deprecated interface points with <code>DEPRECATED</code>
                    comments.
                </p>
            </div>

            <div class="stylebody">

                <p>
                    You can mark an interface as deprecated by writing a
                    comment containing the word <code>DEPRECATED</code> in
                    all caps. The comment goes either before the declaration
                    of the interface or on the same line as the
                    declaration.
                </p>



                <p>
                    After the word
                    <code>DEPRECATED</code>, write your name, e-mail address,
                    or other identifier in parentheses.
                </p>

                <p>
                    A deprecation comment must include simple, clear
                    directions for people to fix their callsites. In C++, you
                    can implement a deprecated function as an inline function
                    that calls the new interface point.
                </p>

                <p>
                    Marking an interface point <code>DEPRECATED</code>
                    will not magically cause any callsites to change. If you
                    want people to actually stop using the deprecated
                    facility, you will have to fix the callsites yourself or
                    recruit a crew to help you.
                </p>

                <p>
                    New code should not contain calls to deprecated
                    interface points. Use the new interface point instead. If
                    you cannot understand the directions, find the person who
                    created the deprecation and ask them for help using the
                    new interface point.
                </p>



            </div>

            <h2 id="Formatting">Formatting</h2>

            <p>
                Coding style and formatting are pretty arbitrary, but a

                project is much easier to follow
                if everyone uses the same style. Individuals may not agree with every
                aspect of the formatting rules, and some of the rules may take
                some getting used to, but it is important that all

                project contributors follow the
                style rules so that
                they can all read and understand
                everyone's code easily.
            </p>



            <p>
                To help you format code correctly, we've
                created a
                <a href="https://raw.githubusercontent.com/google/styleguide/gh-pages/google-c-style.el">
                    settings file for emacs
                </a>.
            </p>

            <h3 id="Line_Length">Line Length</h3>

            <div class="summary">
                <p>
                    Each line of text in your code should be at most 80
                    characters long.
                </p>
            </div>

            <div class="stylebody">



                <p>
                    We recognize that this rule is
                    controversial, but so much existing code already adheres
                    to it, and we feel that consistency is important.
                </p>

                <div class="pros">
                    <p>
                        Those who favor  this rule
                        argue that it is rude to force them to resize
                        their windows and there is no need for anything longer.
                        Some folks are used to having several code windows
                        side-by-side, and thus don't have room to widen their
                        windows in any case. People set up their work environment
                        assuming a particular maximum window width, and 80
                        columns has been the traditional standard. Why change
                        it?
                    </p>
                </div>

                <div class="cons">
                    <p>
                        Proponents of change argue that a wider line can make
                        code more readable. The 80-column limit is an hidebound
                        throwback to 1960s mainframes;  modern equipment has wide screens that
                        can easily show longer lines.
                    </p>
                </div>

                <div class="decision">
                    <p> 80 characters is the maximum.</p>

                    <p class="exception">
                        Comment lines can be longer than 80
                        characters if it is not feasible to split them without
                        harming readability, ease of cut and paste or auto-linking
                        -- e.g. if a line contains an example command or a literal
                        URL longer than 80 characters.
                    </p>

                    <p class="exception">
                        A raw-string literal may have content
                        that exceeds 80 characters.  Except for test code, such literals
                        should appear near the top of a file.
                    </p>

                    <p class="exception">
                        An <code>#include</code> statement with a
                        long path may exceed 80 columns.
                    </p>

                    <p class="exception">
                        You needn't be concerned about
                        <a href="#The__define_Guard">header guards</a> that exceed
                        the maximum length.
                    </p>
                </div>

            </div>

            <h3 id="Non-ASCII_Characters">Non-ASCII Characters</h3>

            <div class="summary">
                <p>
                    Non-ASCII characters should be rare, and must use UTF-8
                    formatting.
                </p>
            </div>

            <div class="stylebody">

                <p>
                    You shouldn't hard-code user-facing text in source,
                    even English, so use of non-ASCII characters should be
                    rare. However, in certain cases it is appropriate to
                    include such words in your code. For example, if your
                    code parses data files from foreign sources, it may be
                    appropriate to hard-code the non-ASCII string(s) used in
                    those data files as delimiters. More commonly, unittest
                    code (which does not  need to be localized) might
                    contain non-ASCII strings. In such cases, you should use
                    UTF-8, since that is  an encoding
                    understood by most tools able to handle more than just
                    ASCII.
                </p>

                <p>
                    Hex encoding is also OK, and encouraged where it
                    enhances readability &#8212; for example,
                    <code>"\xEF\xBB\xBF"</code>, or, even more simply,
                    <code>u8"\uFEFF"</code>, is the Unicode zero-width
                    no-break space character, which would be invisible if
                    included in the source as straight UTF-8.
                </p>

                <p>
                    Use the <code>u8</code> prefix
                    to guarantee that a string literal containing
                    <code>\uXXXX</code> escape sequences is encoded as UTF-8.
                    Do not use it for strings containing non-ASCII characters
                    encoded as UTF-8, because that will produce incorrect
                    output if the compiler does not interpret the source file
                    as UTF-8.
                </p>

                <p>
                    You shouldn't use the C++11 <code>char16_t</code> and
                    <code>char32_t</code> character types, since they're for
                    non-UTF-8 text. For similar reasons you also shouldn't
                    use <code>wchar_t</code> (unless you're writing code that
                    interacts with the Windows API, which uses
                    <code>wchar_t</code> extensively).
                </p>

            </div>

            <h3 id="Spaces_vs._Tabs">Spaces vs. Tabs</h3>

            <div class="summary">
                <p>Use only spaces, and indent 2 spaces at a time.</p>
            </div>

            <div class="stylebody">

                <p>
                    We use spaces for indentation. Do not use tabs in your
                    code. You should set your editor to emit spaces when you
                    hit the tab key.
                </p>

            </div>

            <h3 id="Function_Declarations_and_Definitions">Function Declarations and Definitions</h3>

            <div class="summary">
                <p>
                    Return type on the same line as function name, parameters
                    on the same line if they fit. Wrap parameter lists which do
                    not fit on a single line as you would wrap arguments in a
                    <a href="#Function_Calls">function call</a>.
                </p>
            </div>

            <div class="stylebody">

                <p>Functions look like this:</p>


<pre>ReturnType ClassName::FunctionName(Type par_name1, Type par_name2) {
  DoSomething();
  ...
}
</pre>

                <p>If you have too much text to fit on one line:</p>

<pre>ReturnType ClassName::ReallyLongFunctionName(Type par_name1, Type par_name2,
                                             Type par_name3) {
  DoSomething();
  ...
}
</pre>

                <p>or if you cannot fit even the first parameter:</p>

<pre>ReturnType LongClassName::ReallyReallyReallyLongFunctionName(
    Type par_name1,  // 4 space indent
    Type par_name2,
    Type par_name3) {
  DoSomething();  // 2 space indent
  ...
}
</pre>

                <p>Some points to note:</p>

                <ul>
                    <li>Choose good parameter names.</li>

                    <li>
                        Parameter names may be omitted only if the parameter is unused and its
                        purpose is obvious.
                    </li>

                    <li>
                        If you cannot fit the return type and the function
                        name on a single line, break between them.
                    </li>

                    <li>
                        If you break after the return type of a function
                        declaration or definition, do not indent.
                    </li>

                    <li>
                        The open parenthesis is always on the same line as
                        the function name.
                    </li>

                    <li>
                        There is never a space between the function name
                        and the open parenthesis.
                    </li>

                    <li>
                        There is never a space between the parentheses and
                        the parameters.
                    </li>

                    <li>
                        The open curly brace is always on the end of the last line of the function
                        declaration, not the start of the next line.
                    </li>

                    <li>
                        The close curly brace is either on the last line by
                        itself or on the same line as the open curly brace.
                    </li>

                    <li>
                        There should be a space between the close
                        parenthesis and the open curly brace.
                    </li>

                    <li>All parameters should be aligned if possible.</li>

                    <li>Default indentation is 2 spaces.</li>

                    <li>Wrapped parameters have a 4 space indent.</li>
                </ul>

                <p>Unused parameters that are obvious from context may be omitted:</p>

<pre>class Foo {
 public:
  Foo(Foo&amp;&amp;);
  Foo(const Foo&amp;);
  Foo&amp; operator=(Foo&amp;&amp;);
  Foo&amp; operator=(const Foo&amp;);
};
</pre>

                <p>
                    Unused parameters that might not be obvious should comment out the variable
                    name in the function definition:
                </p>

<pre>class Shape {
 public:
  virtual void Rotate(double radians) = 0;
};

class Circle : public Shape {
 public:
  void Rotate(double radians) override;
};

void Circle::Rotate(double /*radians*/) {}
</pre>

<pre class="badcode">// Bad - if someone wants to implement later, it's not clear what the
// variable means.
void Circle::Rotate(double) {}
</pre>

                <p>
                    Attributes, and macros that expand to attributes, appear at the very
                    beginning of the function declaration or definition, before the
                    return type:
                </p>
<pre>MUST_USE_RESULT bool IsOK();
</pre>

            </div>

            <h3 id="Formatting_Lambda_Expressions">Lambda Expressions</h3>

            <div class="summary">
                <p>
                    Format parameters and bodies as for any other function, and capture
                    lists like other comma-separated lists.
                </p>
            </div>

            <div class="stylebody">
                <p>
                    For by-reference captures, do not leave a space between the
                    ampersand (&amp;) and the variable name.
                </p>
<pre>int x = 0;
auto x_plus_n = [&amp;x](int n) -&gt; int { return x + n; }
</pre>
                <p>Short lambdas may be written inline as function arguments.</p>
<pre>std::set&lt;int&gt; blacklist = {7, 8, 9};
std::vector&lt;int&gt; digits = {3, 9, 1, 8, 4, 7, 1};
digits.erase(std::remove_if(digits.begin(), digits.end(), [&amp;blacklist](int i) {
               return blacklist.find(i) != blacklist.end();
             }),
             digits.end());
</pre>

            </div>

            <h3 id="Function_Calls">Function Calls</h3>

            <div class="summary">
                <p>
                    Either write the call all on a single line, wrap the
                    arguments at the parenthesis, or start the arguments on a new
                    line indented by four spaces and continue at that 4 space
                    indent. In the absence of other considerations, use the
                    minimum number of lines, including placing multiple arguments
                    on each line where appropriate.
                </p>
            </div>

            <div class="stylebody">

                <p>Function calls have the following format:</p>
<pre>bool result = DoSomething(argument1, argument2, argument3);
</pre>

                <p>
                    If the arguments do not all fit on one line, they
                    should be broken up onto multiple lines, with each
                    subsequent line aligned with the first argument. Do not
                    add spaces after the open paren or before the close
                    paren:
                </p>
<pre>bool result = DoSomething(averyveryveryverylongargument1,
                          argument2, argument3);
</pre>

                <p>
                    Arguments may optionally all be placed on subsequent
                    lines with a four space indent:
                </p>
<pre>if (...) {
  ...
  ...
  if (...) {
    bool result = DoSomething(
        argument1, argument2,  // 4 space indent
        argument3, argument4);
    ...
  }
</pre>

                <p>
                    Put multiple arguments on a single line to reduce the
                    number of lines necessary for calling a function unless
                    there is a specific readability problem. Some find that
                    formatting with strictly one argument on each line is
                    more readable and simplifies editing of the arguments.
                    However, we prioritize for the reader over the ease of
                    editing arguments, and most readability problems are
                    better addressed with the following techniques.
                </p>

                <p>
                    If having multiple arguments in a single line decreases
                    readability due to the complexity or confusing nature of the
                    expressions that make up some arguments, try creating
                    variables that capture those arguments in a descriptive name:
                </p>
<pre>int my_heuristic = scores[x] * y + bases[x];
bool result = DoSomething(my_heuristic, x, y, z);
</pre>

                <p>
                    Or put the confusing argument on its own line with
                    an explanatory comment:
                </p>
<pre>bool result = DoSomething(scores[x] * y + bases[x],  // Score heuristic.
                          x, y, z);
</pre>

                <p>
                    If there is still a case where one argument is
                    significantly more readable on its own line, then put it on
                    its own line. The decision should be specific to the argument
                    which is made more readable rather than a general policy.
                </p>

                <p>
                    Sometimes arguments form a structure that is important
                    for readability. In those cases, feel free to format the
                    arguments according to that structure:
                </p>
<pre>// Transform the widget by a 3x3 matrix.
my_widget.Transform(x1, x2, x3,
                    y1, y2, y3,
                    z1, z2, z3);
</pre>

            </div>

            <h3 id="Braced_Initializer_List_Format">Braced Initializer List Format</h3>

            <div class="summary">
                <p>
                    Format a <a href="#Braced_Initializer_List">braced initializer list</a>
                    exactly like you would format a function call in its place.
                </p>
            </div>

            <div class="stylebody">

                <p>
                    If the braced list follows a name (e.g. a type or
                    variable name), format as if the <code>{}</code> were the
                    parentheses of a function call with that name. If there
                    is no name, assume a zero-length name.
                </p>

<pre>// Examples of braced init list on a single line.
return {foo, bar};
functioncall({foo, bar});
std::pair&lt;int, int&gt; p{foo, bar};

// When you have to wrap.
SomeFunction(
    {"assume a zero-length name before {"},
    some_other_function_parameter);
SomeType variable{
    some, other, values,
    {"assume a zero-length name before {"},
    SomeOtherType{
        "Very long string requiring the surrounding breaks.",
        some, other values},
    SomeOtherType{"Slightly shorter string",
                  some, other, values}};
SomeType variable{
    "This is too long to fit all in one line"};
MyType m = {  // Here, you could also break before {.
    superlongvariablename1,
    superlongvariablename2,
    {short, interior, list},
    {interiorwrappinglist,
     interiorwrappinglist2}};
</pre>

            </div>

            <h3 id="Conditionals">Conditionals</h3>

            <div class="summary">
                <p>
                    Prefer no spaces inside parentheses. The <code>if</code>
                    and <code>else</code> keywords belong on separate lines.
                </p>
            </div>

            <div class="stylebody">

                <p>
                    There are two acceptable formats for a basic
                    conditional statement. One includes spaces between the
                    parentheses and the condition, and one does not.
                </p>

                <p>
                    The most common form is without spaces. Either is
                    fine, but <em>be consistent</em>. If you are modifying a
                    file, use the format that is already present. If you are
                    writing new code, use the format that the other files in
                    that directory or project use. If in doubt and you have
                    no personal preference, do not add the spaces.
                </p>

<pre>if (condition) {  // no spaces inside parentheses
  ...  // 2 space indent.
} else if (...) {  // The else goes on the same line as the closing brace.
  ...
} else {
  ...
}
</pre>

                <p>
                    If you prefer you may add spaces inside the
                    parentheses:
                </p>

<pre>if ( condition ) {  // spaces inside parentheses - rare
  ...  // 2 space indent.
} else {  // The else goes on the same line as the closing brace.
  ...
}
</pre>

                <p>
                    Note that in all cases you must have a space between
                    the <code>if</code> and the open parenthesis. You must
                    also have a space between the close parenthesis and the
                    curly brace, if you're using one.
                </p>

<pre class="badcode">if(condition) {   // Bad - space missing after IF.
if (condition){   // Bad - space missing before {.
if(condition){    // Doubly bad.
</pre>

<pre>if (condition) {  // Good - proper space after IF and before {.
</pre>

                <p>
                    Short conditional statements may be written on one
                    line if this enhances readability. You may use this only
                    when the line is brief and the statement does not use the
                    <code>else</code> clause.
                </p>

<pre>if (x == kFoo) return new Foo();
if (x == kBar) return new Bar();
</pre>

                <p>
                    This is not allowed when the if statement has an
                    <code>else</code>:
                </p>

<pre class="badcode">// Not allowed - IF statement on one line when there is an ELSE clause
if (x) DoThis();
else DoThat();
</pre>

                <p>
                    In general, curly braces are not required for
                    single-line statements, but they are allowed if you like
                    them; conditional or loop statements with complex
                    conditions or statements may be more readable with curly
                    braces. Some
                    projects require that an
                    <code>if</code> must always always have an accompanying
                    brace.
                </p>

<pre>if (condition)
  DoSomething();  // 2 space indent.

if (condition) {
  DoSomething();  // 2 space indent.
}
</pre>

                <p>
                    However, if one part of an
                    <code>if</code>-<code>else</code> statement uses curly
                    braces, the other part must too:
                </p>

<pre class="badcode">// Not allowed - curly on IF but not ELSE
if (condition) {
  foo;
} else
  bar;

// Not allowed - curly on ELSE but not IF
if (condition)
  foo;
else {
  bar;
}
</pre>

<pre>// Curly braces around both IF and ELSE required because
// one of the clauses used braces.
if (condition) {
  foo;
} else {
  bar;
}
</pre>

            </div>

            <h3 id="Loops_and_Switch_Statements">Loops and Switch Statements</h3>

            <div class="summary">
                <p>
                    Switch statements may use braces for blocks. Annotate
                    non-trivial fall-through between cases.
                    Braces are optional for single-statement loops.
                    Empty loop bodies should use empty braces or <code>continue</code>.
                </p>
            </div>

            <div class="stylebody">

                <p>
                    <code>case</code> blocks in <code>switch</code>
                    statements can have curly braces or not, depending on
                    your preference. If you do include curly braces they
                    should be placed as shown below.
                </p>

                <p>
                    If not conditional on an enumerated value, switch
                    statements should always have a <code>default</code> case
                    (in the case of an enumerated value, the compiler will
                    warn you if any values are not handled). If the default
                    case should never execute, simply
                    <code>assert</code>:
                </p>



                <div>
<pre>switch (var) {
  case 0: {  // 2 space indent
    ...      // 4 space indent
    break;
  }
  case 1: {
    ...
    break;
  }
  default: {
    assert(false);
  }
}
</pre>
                </div>





                <p> Braces are optional for single-statement loops.</p>

<pre>for (int i = 0; i &lt; kSomeNumber; ++i)
  printf("I love you\n");

for (int i = 0; i &lt; kSomeNumber; ++i) {
  printf("I take it back\n");
}
</pre>


                <p>
                    Empty loop bodies should use an empty pair of braces or <code>continue</code>,
                    but not a single semicolon.
                </p>

<pre>while (condition) {
  // Repeat test until it returns false.
}
for (int i = 0; i &lt; kSomeNumber; ++i) {}  // Good - one newline is also OK.
while (condition) continue;  // Good - continue indicates no logic.
</pre>

<pre class="badcode">while (condition);  // Bad - looks like part of do/while loop.
</pre>

            </div>

            <h3 id="Pointer_and_Reference_Expressions">Pointer and Reference Expressions</h3>

            <div class="summary">
                <p>
                    No spaces around period or arrow. Pointer operators do not
                    have trailing spaces.
                </p>
            </div>

            <div class="stylebody">

                <p>
                    The following are examples of correctly-formatted
                    pointer and reference expressions:
                </p>

<pre>x = *p;
p = &amp;x;
x = r.y;
x = r-&gt;y;
</pre>

                <p>Note that:</p>

                <ul>
                    <li>
                        There are no spaces around the period or arrow when
                        accessing a member.
                    </li>

                    <li>
                        Pointer operators have no space after the
                        <code>*</code> or <code>&amp;</code>.
                    </li>
                </ul>

                <p>
                    When declaring a pointer variable or argument, you may
                    place the asterisk adjacent to either the type or to the
                    variable name:
                </p>

<pre>// These are fine, space preceding.
char *c;
const string &amp;str;

// These are fine, space following.
char* c;
const string&amp; str;
</pre>

                It is allowed (if unusual) to declare multiple variables in the same
                declaration, but it is disallowed if any of those have pointer or
                reference decorations. Such declarations are easily misread.
<pre>// Fine if helpful for readability.
int x, y;
</pre>
<pre class="badcode">int x, *y;  // Disallowed - no &amp; or * in multiple declaration
char * c;  // Bad - spaces on both sides of *
const string &amp; str;  // Bad - spaces on both sides of &amp;
</pre>

                <p>
                    You should do this consistently within a single
                    file,
                    so, when modifying an existing file, use the style in
                    that file.
                </p>

            </div>

            <h3 id="Boolean_Expressions">Boolean Expressions</h3>

            <div class="summary">
                <p>
                    When you have a boolean expression that is longer than the
                    <a href="#Line_Length">standard line length</a>, be
                    consistent in how you break up the lines.
                </p>
            </div>

            <div class="stylebody">

                <p>
                    In this example, the logical AND operator is always at
                    the end of the lines:
                </p>

<pre>if (this_one_thing &gt; this_other_thing &amp;&amp;
    a_third_thing == a_fourth_thing &amp;&amp;
    yet_another &amp;&amp; last_one) {
  ...
}
</pre>

                <p>
                    Note that when the code wraps in this example, both of
                    the <code>&amp;&amp;</code> logical AND operators are at
                    the end of the line. This is more common in Google code,
                    though wrapping all operators at the beginning of the
                    line is also allowed. Feel free to insert extra
                    parentheses judiciously because they can be very helpful
                    in increasing readability when used
                    appropriately. Also note that you should always use
                    the punctuation operators, such as
                    <code>&amp;&amp;</code> and <code>~</code>, rather than
                    the word operators, such as <code>and</code> and
                    <code>compl</code>.
                </p>

            </div>

            <h3 id="Return_Values">Return Values</h3>

            <div class="summary">
                <p>
                    Do not needlessly surround the <code>return</code>
                    expression with parentheses.
                </p>
            </div>

            <div class="stylebody">

                <p>
                    Use parentheses in <code>return expr;</code> only
                    where you would use them in <code>x = expr;</code>.
                </p>

<pre>return result;                  // No parentheses in the simple case.
// Parentheses OK to make a complex expression more readable.
return (some_long_condition &amp;&amp;
        another_condition);
</pre>

<pre class="badcode">return (value);                // You wouldn't write var = (value);
return(result);                // return is not a function!
</pre>

            </div>



            <h3 id="Variable_and_Array_Initialization">Variable and Array Initialization</h3>

            <div class="summary">
                <p>
                    Your choice of <code>=</code>, <code>()</code>, or
                    <code>{}</code>.
                </p>
            </div>

            <div class="stylebody">

                <p>
                    You may choose between <code>=</code>,
                    <code>()</code>, and <code>{}</code>; the following are
                    all correct:
                </p>

<pre>int x = 3;
int x(3);
int x{3};
string name = "Some Name";
string name("Some Name");
string name{"Some Name"};
</pre>

                <p>
                    Be careful when using a braced initialization list <code>{...}</code>
                    on a type with an <code>std::initializer_list</code> constructor.
                    A nonempty <i>braced-init-list</i> prefers the
                    <code>std::initializer_list</code> constructor whenever
                    possible. Note that empty braces <code>{}</code> are special, and
                    will call a default constructor if available. To force the
                    non-<code>std::initializer_list</code> constructor, use parentheses
                    instead of braces.
                </p>

<pre>std::vector&lt;int&gt; v(100, 1);  // A vector of 100 1s.
std::vector&lt;int&gt; v{100, 1};  // A vector of 100, 1.
</pre>

                <p>
                    Also, the brace form prevents narrowing of integral
                    types. This can prevent some types of programming
                    errors.
                </p>

<pre>int pi(3.14);  // OK -- pi == 3.
int pi{3.14};  // Compile error: narrowing conversion.
</pre>

            </div>

            <h3 id="Preprocessor_Directives">Preprocessor Directives</h3>

            <div class="summary">
                <p>
                    The hash mark that starts a preprocessor directive should
                    always be at the beginning of the line.
                </p>
            </div>

            <div class="stylebody">

                <p>
                    Even when preprocessor directives are within the body
                    of indented code, the directives should start at the
                    beginning of the line.
                </p>

<pre>// Good - directives at beginning of line
  if (lopsided_score) {
#if DISASTER_PENDING      // Correct -- Starts at beginning of line
    DropEverything();
# if NOTIFY               // OK but not required -- Spaces after #
    NotifyClient();
# endif
#endif
    BackToNormal();
  }
</pre>

<pre class="badcode">// Bad - indented directives
  if (lopsided_score) {
    #if DISASTER_PENDING  // Wrong!  The "#if" should be at beginning of line
    DropEverything();
    #endif                // Wrong!  Do not indent "#endif"
    BackToNormal();
  }
</pre>

            </div>

            <h3 id="Class_Format">Class Format</h3>

            <div class="summary">
                <p>
                    Sections in <code>public</code>, <code>protected</code> and
                    <code>private</code> order, each indented one space.
                </p>
            </div>

            <div class="stylebody">

                <p>
                    The basic format for a class definition (lacking the
                    comments, see <a href="#Class_Comments">
                        Class
                        Comments
                    </a> for a discussion of what comments are
                    needed) is:
                </p>

<pre>class MyClass : public OtherClass {
 public:      // Note the 1 space indent!
  MyClass();  // Regular 2 space indent.
  explicit MyClass(int var);
  ~MyClass() {}

  void SomeFunction();
  void SomeFunctionThatDoesNothing() {
  }

  void set_some_var(int var) { some_var_ = var; }
  int some_var() const { return some_var_; }

 private:
  bool SomeInternalFunction();

  int some_var_;
  int some_other_var_;
};
</pre>

                <p>Things to note:</p>

                <ul>
                    <li>
                        Any base class name should be on the same line as
                        the subclass name, subject to the 80-column limit.
                    </li>

                    <li>
                        The <code>public:</code>, <code>protected:</code>,
                        and <code>private:</code> keywords should be indented
                        one space.
                    </li>

                    <li>
                        Except for the first instance, these keywords
                        should be preceded by a blank line. This rule is
                        optional in small classes.
                    </li>

                    <li>
                        Do not leave a blank line after these
                        keywords.
                    </li>

                    <li>
                        The <code>public</code> section should be first,
                        followed by the <code>protected</code> and finally the
                        <code>private</code> section.
                    </li>

                    <li>
                        See <a href="#Declaration_Order">
                            Declaration
                            Order
                        </a> for rules on ordering declarations within
                        each of these sections.
                    </li>
                </ul>

            </div>

            <h3 id="Constructor_Initializer_Lists">Constructor Initializer Lists</h3>

            <div class="summary">
                <p>
                    Constructor initializer lists can be all on one line or
                    with subsequent lines indented four spaces.
                </p>
            </div>

            <div class="stylebody">

                <p>The acceptable formats for initializer lists are:</p>

<pre>// When everything fits on one line:
MyClass::MyClass(int var) : some_var_(var) {
  DoSomething();
}

// If the signature and initializer list are not all on one line,
// you must wrap before the colon and indent 4 spaces:
MyClass::MyClass(int var)
    : some_var_(var), some_other_var_(var + 1) {
  DoSomething();
}

// When the list spans multiple lines, put each member on its own line
// and align them:
MyClass::MyClass(int var)
    : some_var_(var),             // 4 space indent
      some_other_var_(var + 1) {  // lined up
  DoSomething();
}

// As with any other code block, the close curly can be on the same
// line as the open curly, if it fits.
MyClass::MyClass(int var)
    : some_var_(var) {}
</pre>

            </div>

            <h3 id="Namespace_Formatting">Namespace Formatting</h3>

            <div class="summary">
                <p>The contents of namespaces are not indented.</p>
            </div>

            <div class="stylebody">

                <p>
                    <a href="#Namespaces">Namespaces</a> do not add an
                    extra level of indentation. For example, use:
                </p>

<pre>namespace {

void foo() {  // Correct.  No extra indentation within namespace.
  ...
}

}  // namespace
</pre>

                <p>Do not indent within a namespace:</p>

<pre class="badcode">namespace {

  // Wrong.  Indented when it should not be.
  void foo() {
    ...
  }

}  // namespace
</pre>

                <p>
                    When declaring nested namespaces, put each namespace
                    on its own line.
                </p>

<pre>namespace foo {
namespace bar {
</pre>

            </div>

            <h3 id="Horizontal_Whitespace">Horizontal Whitespace</h3>

            <div class="summary">
                <p>
                    Use of horizontal whitespace depends on location. Never put
                    trailing whitespace at the end of a line.
                </p>
            </div>

            <div class="stylebody">

                <h4 class="stylepoint_subsection">General</h4>

<pre>void f(bool b) {  // Open braces should always have a space before them.
  ...
int i = 0;  // Semicolons usually have no space before them.
// Spaces inside braces for braced-init-list are optional.  If you use them,
// put them on both sides!
int x[] = { 0 };
int x[] = {0};

// Spaces around the colon in inheritance and initializer lists.
class Foo : public Bar {
 public:
  // For inline function implementations, put spaces between the braces
  // and the implementation itself.
  Foo(int b) : Bar(), baz_(b) {}  // No spaces inside empty braces.
  void Reset() { baz_ = 0; }  // Spaces separating braces from implementation.
  ...
</pre>

                <p>
                    Adding trailing whitespace can cause extra work for
                    others editing the same file, when they merge, as can
                    removing existing trailing whitespace. So: Don't
                    introduce trailing whitespace. Remove it if you're
                    already changing that line, or do it in a separate
                    clean-up
                    operation (preferably when no-one
                    else is working on the file).
                </p>

                <h4 class="stylepoint_subsection">Loops and Conditionals</h4>

<pre>if (b) {          // Space after the keyword in conditions and loops.
} else {          // Spaces around else.
}
while (test) {}   // There is usually no space inside parentheses.
switch (i) {
for (int i = 0; i &lt; 5; ++i) {
// Loops and conditions may have spaces inside parentheses, but this
// is rare.  Be consistent.
switch ( i ) {
if ( test ) {
for ( int i = 0; i &lt; 5; ++i ) {
// For loops always have a space after the semicolon.  They may have a space
// before the semicolon, but this is rare.
for ( ; i &lt; 5 ; ++i) {
  ...

// Range-based for loops always have a space before and after the colon.
for (auto x : counts) {
  ...
}
switch (i) {
  case 1:         // No space before colon in a switch case.
    ...
  case 2: break;  // Use a space after a colon if there's code after it.
</pre>

                <h4 class="stylepoint_subsection">Operators</h4>

<pre>// Assignment operators always have spaces around them.
x = 0;

// Other binary operators usually have spaces around them, but it's
// OK to remove spaces around factors.  Parentheses should have no
// internal padding.
v = w * x + y / z;
v = w*x + y/z;
v = w * (x + z);

// No spaces separating unary operators and their arguments.
x = -5;
++x;
if (x &amp;&amp; !y)
  ...
</pre>

                <h4 class="stylepoint_subsection">Templates and Casts</h4>

<pre>// No spaces inside the angle brackets (&lt; and &gt;), before
// &lt;, or between &gt;( in a cast
std::vector&lt;string&gt; x;
y = static_cast&lt;char*&gt;(x);

// Spaces between type and pointer are OK, but be consistent.
std::vector&lt;char *&gt; x;
</pre>

            </div>

            <h3 id="Vertical_Whitespace">Vertical Whitespace</h3>

            <div class="summary">
                <p>Minimize use of vertical whitespace.</p>
            </div>

            <div class="stylebody">

                <p>
                    This is more a principle than a rule: don't use blank
                    lines when you don't have to. In particular, don't put
                    more than one or two blank lines between functions,
                    resist starting functions with a blank line, don't end
                    functions with a blank line, and be discriminating with
                    your use of blank lines inside functions.
                </p>

                <p>
                    The basic principle is: The more code that fits on one
                    screen, the easier it is to follow and understand the
                    control flow of the program. Of course, readability can
                    suffer from code being too dense as well as too spread
                    out, so use your judgement. But in general, minimize use
                    of vertical whitespace.
                </p>

                <p>
                    Some rules of thumb to help when blank lines may be
                    useful:
                </p>

                <ul>
                    <li>
                        Blank lines at the beginning or end of a function
                        very rarely help readability.
                    </li>

                    <li>
                        Blank lines inside a chain of if-else blocks may
                        well help readability.
                    </li>
                </ul>

            </div>

            <h2 id="Exceptions_to_the_Rules">Exceptions to the Rules</h2>

            <p>
                The coding conventions described above are mandatory.
                However, like all good rules, these sometimes have exceptions,
                which we discuss here.
            </p>



            <div>
                <h3 id="Existing_Non-conformant_Code">Existing Non-conformant Code</h3>

                <div class="summary">
                    <p>
                        You may diverge from the rules when dealing with code that
                        does not conform to this style guide.
                    </p>
                </div>

                <div class="stylebody">

                    <p>
                        If you find yourself modifying code that was written
                        to specifications other than those presented by this
                        guide, you may have to diverge from these rules in order
                        to stay consistent with the local conventions in that
                        code. If you are in doubt about how to do this, ask the
                        original author or the person currently responsible for
                        the code. Remember that <em>consistency</em> includes
                        local consistency, too.
                    </p>

                </div>
            </div>



            <h3 id="Windows_Code">Windows Code</h3>

            <div class="summary">
                <p>
                    Windows
                    programmers have developed their own set of coding
                    conventions, mainly derived from the conventions in Windows
                    headers and other Microsoft code. We want to make it easy
                    for anyone to understand your code, so we have a single set
                    of guidelines for everyone writing C++ on any platform.
                </p>
            </div>

            <div class="stylebody">
                <p>
                    It is worth reiterating a few of the guidelines that
                    you might forget if you are used to the prevalent Windows
                    style:
                </p>

                <ul>
                    <li>
                        Do not use Hungarian notation (for example, naming
                        an integer <code>iNum</code>). Use the Google naming
                        conventions, including the <code>.cc</code> extension
                        for source files.
                    </li>

                    <li>
                        Windows defines many of its own synonyms for
                        primitive types, such as <code>DWORD</code>,
                        <code>HANDLE</code>, etc. It is perfectly acceptable,
                        and encouraged, that you use these types when calling
                        Windows API functions. Even so, keep as close as you
                        can to the underlying C++ types. For example, use
                        <code>const TCHAR *</code> instead of
                        <code>LPCTSTR</code>.
                    </li>

                    <li>
                        When compiling with Microsoft Visual C++, set the
                        compiler to warning level 3 or higher, and treat all
                        warnings as errors.
                    </li>

                    <li>
                        Do not use <code>#pragma once</code>; instead use
                        the standard Google include guards. The path in the
                        include guards should be relative to the top of your
                        project tree.
                    </li>

                    <li>
                        In fact, do not use any nonstandard extensions,
                        like <code>#pragma</code> and <code>__declspec</code>,
                        unless you absolutely must. Using
                        <code>__declspec(dllimport)</code> and
                        <code>__declspec(dllexport)</code> is allowed; however,
                        you must use them through macros such as
                        <code>DLLIMPORT</code> and <code>DLLEXPORT</code>, so
                        that someone can easily disable the extensions if they
                        share the code.
                    </li>
                </ul>

                <p>
                    However, there are just a few rules that we
                    occasionally need to break on Windows:
                </p>

                <ul>
                    <li>
                        Normally we <a href="#Multiple_Inheritance">
                            forbid
                            the use of multiple implementation inheritance
                        </a>;
                        however, it is required when using COM and some ATL/WTL
                        classes. You may use multiple implementation
                        inheritance to implement COM or ATL/WTL classes and
                        interfaces.
                    </li>

                    <li>
                        Although you should not use exceptions in your own
                        code, they are used extensively in the ATL and some
                        STLs, including the one that comes with Visual C++.
                        When using the ATL, you should define
                        <code>_ATL_NO_EXCEPTIONS</code> to disable exceptions.
                        You should investigate whether you can also disable
                        exceptions in your STL, but if not, it is OK to turn on
                        exceptions in the compiler. (Note that this is only to
                        get the STL to compile. You should still not write
                        exception handling code yourself.)
                    </li>

                    <li>
                        The usual way of working with precompiled headers
                        is to include a header file at the top of each source
                        file, typically with a name like <code>StdAfx.h</code>
                        or <code>precompile.h</code>. To make your code easier
                        to share with other projects, avoid including this file
                        explicitly (except in <code>precompile.cc</code>), and
                        use the <code>/FI</code> compiler option to include the
                        file automatically.
                    </li>

                    <li>
                        Resource headers, which are usually named
                        <code>resource.h</code> and contain only macros, do not
                        need to conform to these style guidelines.
                    </li>
                </ul>

            </div>

            <h2 class="ignoreLink">Parting Words</h2>

            <p>Use common sense and <em>BE CONSISTENT</em>.</p>

            <p>
                If you are editing code, take a few minutes to look at the
                code around you and determine its style. If they use spaces
                around their <code>if</code> clauses, you should, too. If their
                comments have little boxes of stars around them, make your
                comments have little boxes of stars around them too.
            </p>

            <p>
                The point of having style guidelines is to have a common
                vocabulary of coding so people can concentrate on what you are
                saying, rather than on how you are saying it. We present global
                style rules here so people know the vocabulary. But local style
                is also important. If code you add to a file looks drastically
                different from the existing code around it, the discontinuity
                throws readers out of their rhythm when they go to read it. Try
                to avoid this.
            </p>



            <p>
                OK, enough writing about writing code; the code itself is much
                more interesting. Have fun!
            </p>

            <hr>

        </div>
    </div>
</body>
</html>

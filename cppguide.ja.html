<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>Google C++ Style Guide (Japanese)</title>
    <link rel="stylesheet" type="text/css" href="include/styleguide.ja.css">
    <script language="javascript" src="include/styleguide.ja.js"></script>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
    <style>
        /* 翻訳ポップアップ */
        span:hover {
            background-color: #FFC;
        }

        #tip_popup {
            position: absolute;
            border: 1px solid black;
            max-width: 50%;
            background-color: #EFF;
            padding: 8px;
            z-index: 100;
            left: -99999px;
        }

        span.src {
            display: none;
        }
    </style>
    <script language="javascript">
        // 翻訳ポップアップ
        $(document).ready(function () {
            $("body").append('<div id="tip_popup"></div>');
            var tip = $('#tip_popup');
            $("span").each(function () {
                if ($(this).attr("title")) {
                    $(this).attr("data-title", $(this).attr("title"));
                    $(this).removeAttr("title");
                    $(this).mousemove(function (m) { tip.html($(this).attr("data-title")); });
                    $(this).mousemove(function (m) { tip.css({ left: (m.pageX + 20) + "px", top: (m.pageY + 20) + "px" }); });
                    $(this).mouseout(function () { tip.css({ left: "-99999px" }); });
                }
                else if ($(this).children("span.src")) {
                    $(this).mousemove(function (m) { tip.html($(this).children("span.src").html()); });
                    $(this).mousemove(function (m) { tip.css({ left: (m.pageX + 20) + "px", top: (m.pageY + 20) + "px" }); });
                    $(this).mouseout(function () { tip.css({ left: "-99999px" }); });
                }

            });
        });
    </script>

    <link rel="shortcut icon" type="image/x-icon" href="https://www.google.com/favicon.ico" />
</head>
<body onload="initStyleGuide();">
    <div id="content">
        <h1>
            <span title="Google C++ Style Guide">Google C++ スタイルガイド</span> 日本語訳
        </h1>
        <div>
            本ドキュメントは
            <a href="https://github.com/google/styleguide/">https://github.com/google/styleguide/</a> にて公開されているGoogle C++ Style Guideを日本語に訳したものです。
        </div>
        <div>
            commit
            <a href="https://github.com/google/styleguide/blob/db0a26320f3e930c6ea7225ed53539b4fb31310c/cppguide.html">db0a263  on 18 Nov</a> を底本としています。(訳文にマウスを重ねると原文が表示されます)
        </div>
        <div>
            オリジナルと同様
            <a href="https://creativecommons.org/licenses/by/3.0/">CC-By 3.0 License</a>で頒布します。
        </div>
        <div>
            誤訳の指摘・改善案は
            <a href="https://github.com/ttsuki/styleguide/issues">Issues</a> or
            <a href="https://github.com/ttsuki/styleguide/pulls">Pull Requests</a>までお願いします。
        </div>
        <div class="horizontal_toc" id="tocDiv"></div>

        <div class="main_body">

            <h2 class="ignoreLink" id="Background">
                <span title="Background">本ガイドの背景</span>
            </h2>

            <p>
                <span title="C++ is one of the main development languages used by many of Google's open-source projects.">C++は、多くのGoogleのオープンソースプロジェクトで使われている主要言語のうちのひとつです。</span>
                <span title="As every C++ programmer knows, the language has many powerful features, but this power brings with it complexity, which in turn can make code more bug-prone and harder to read and maintain.">C++のプログラマなら誰でも知っているように、この言語はパワフルな機能がありますが、一方でこのパワフルさが複雑さを招き、バグを発生させやすくしたり、また可読性やメンテナンス性の妨げになったりしています。</span>
            </p>

            <p>
                <span title="The goal of this guide is to manage this complexity by describing in detail the dos and don'ts of writing C++ code.">本ガイドの目的は、C++のコードを書く際に、すべきこと、すべきでないことを詳しく説明することによって、この複雑性を管理下に置くことです。</span>
                <span title="These rules exist to keep the code base manageable while still allowing coders to use C++ language features productively.">
                    これらのルールは、プログラマがC++の言語機能を生産的に使用できるようにしたまま、コードベースを管理しやすくするために存在します。
                </span>
            </p>

            <p>
                <span title="Style, also known as readability, is what we call the conventions that govern our C++ code."><em>スタイル</em>とは、リーダビリティとしても知られ、私たちのC++コードを管理するための規約のことです。</span>
                <span title="The term Style is a bit of a misnomer, since these conventions cover far more than just source file formatting.">これらの規約は、単にソースファイルのフォーマットだけではなく、広い範囲を含むため<em>スタイル</em>という用語はちょっとふさわしくないかもしれません。</span>
            </p>

            <p>
                <span title="Most open-source projects developed by Google conform to the requirements in this guide.">Googleのオープンソースプロジェクトのほとんどが、本ガイドに則っています。</span>
            </p>





            <p>
                <span title="Note that this guide is not a C++ tutorial: we assume that the reader is familiar with the language.">注意してほしいのは、このガイドはC++のチュートリアルではないということです。このガイドは読者がC++に精通していることを想定して書かれています。</span>
            </p>

            <h3 id="Goals">
                <span title="Goals of the Style Guide">本ガイドの目的</span>
            </h3>
            <div class="stylebody">
                <p>
                    <span title="Why do we have this document?">なぜ本ガイドは書かれたか</span>
                </p>

                <p>
                    <span title="There are a few core goals that we believe this guide should serve.">このガイドで役立つと思われるいくつかの中核的目標があります。</span>
                    <span title="These are the fundamental whys that underlie all of the individual rules.">それらは、すべての個々のルールの根底となっている基本的なものです。</span>
                    <span title="By bringing these ideas to the fore, we hope to ground discussions and make it clearer to our broader community why the rules are in place and why particular decisions have been made.">私たちは、この考え方を前面に出すことで、議論が行われ、より広範囲なコミュニティにおいて、これらのルールがなぜ作られ、なぜそのように決められたのか、より明確に伝わることを望んでいます。</span>
                    <span title="If you understand what goals each rule is serving, it should be clearer to everyone when a rule may be waived (some can be), and what sort of argument or alternative would be necessary to change a rule in the guide.">個々のルールがどのような目的を果たそうとしているか理解できれば、いつルールの採用を取りやめるべきか、ルールを変更するためにどんな議論や代替案が必要か、より明確になるでしょう。</span>
                </p>

                <p>
                    <span title="The goals of the style guide as we currently see them are as follows:">本スタイルガイドの目的は今のところ次のとおりです。</span>
                </p>
                <dl>
                    <dt><span title="Style rules should pull their weight">スタイルルールを重くしすぎないこと</span></dt>
                    <dd>
                        <span title="The benefit of a style rule must be large enough to justify asking all of our engineers to
remember it.">個々のスタイルルールは「所属するすべてのエンジニアが覚えなくてはならない」ことを正当化できるくらいに価値のあるものでなければなりません。</span> <span title="The benefit is measured relative to the codebase we would get without the rule, so a rule against a very harmful practice may still have a small benefit if people are unlikely to do it anyway.">ルールの価値は「仮にそのルールが無かったら書かれたかもしれないコード」との比較で測定されます。このため、仮に「非常に有害な慣行に対するルール」があったとしても、「そもそもそんなルールがなくとも普通はしないよね」という場合、そのルールの価値は低いと考えます。</span> <span title="This principle mostly explains the rules we don&#8217;t have, rather than the rules we do: for example, goto contravenes many of the following principles, but is already vanishingly rare, so the Style Guide doesn&#8217;t discuss it.">この原則は、どちらかというと、本スタイルガイドに書かれていないルールについて説明しています。例えば、<code>goto</code>の濫用はこれに続く多くの原則に違反しますが、すでにそれが行われること自体がレアケースになっています。このため、本ガイドでは<code>goto</code>の濫用については取り扱いません。</span>
                    </dd>

                    <dt><span title="Optimize for the reader, not the writer">コードの(書き手ではなく)読み手に優しいこと</span></dt>
                    <dd><span title="Our codebase (and most individual components submitted to it) is expected to continue for quite some time.">我々のコードベース(と、ほとんどの個々のコンポーネント)は、今後長い長い時を経ていくことが予想されます。</span> <span title="As a result, more time will be spent reading most of our code than writing it.">結果的に、そのコードを書くのに費やした時間に比べて、はるかに多くの時間がコードを読むために割かれることでしょう。</span> <span title="We explicitly choose to optimize for the experience of our average software engineer reading, maintaining, and debugging code in our codebase rather than ease when writing said code.">私たちは、私たちの平均的なエンジニアが「簡単にコードが書けること」よりも、「コードを読み、メンテし、デバッグがやりやすいこと」に最適化することを明示的に選択します。</span> <span title="&quot;Leave a trace for the reader&quot; is a particularly common sub-point of this principle:">特に「読者のためのヒントを残す」がこの原則の共通のサブテーマになっています。</span> <span title="When something surprising or unusual is happening in a snippet of code (for example, transfer of pointer ownership), leaving textual hints for the reader at the point of use is valuable (std::unique_ptr demonstrates the ownership transfer unambiguously at the call site).">コードの中で見慣れないことをするとき(たとえばポインタの所有権を移す)、読み手のためにヒントを残しておくことは価値があります(<code>std::unique_ptr</code>は明白に所有権を移すことを示しています)。</span> </dd>

                    <dt><span title="Be consistent with existing code">既存のコードと一貫性が保たれていること</span></dt>
                    <dd> <span title="Using one style consistently through our codebase lets us focus on other (more important) issues.">１つのスタイルをコードベース全体で一貫して用いることで、私たちは他の(より重要な)問題にフォーカスすることができます。</span> <span title="Consistency also allows for automation: tools that format your code or adjust your #includes only work properly when your code is consistent with the expectations of the tooling.">一貫性は自動化を進めやすくもします。コードフォーマットツールは、ツールが期待するコードとあなたのコードが一貫しているときにのみ正しく動作します。</span> <span title="In many cases, rules that are attributed to &quot;Be Consistent&quot; boil down to &quot;Just pick one and stop worrying about it&quot;">多くの場合「一貫性を保つ」に起因するルールは「ただ１つを選び、それについて悩むことをやめる」ということです。</span> <span title="the potential value of allowing flexibility on these points is outweighed by the cost of having people argue over them.">これらの点の多様性を認めることの潜在的な価値よりも、それについて議論するコストの方が上回っているのです。</span></dd>

                    <dt><span title="Be consistent with the broader C++ community when appropriate">より広範囲なC++コミュニティと一貫性があること</span></dt>
                    <dd><span title="Consistency with the way other organizations use C++ has value for the same reasons as consistency within our code base.">C++を使う他の組織のやり方と一貫性を保つことも、我々コードベース内で一貫性を保つことと同じ理由で価値があります。</span><span title="If a feature in the C++ standard solves a problem, or if some idiom is widely known and accepted, that's an argument for using it.">あるC++標準の機能が問題を解けるのならば、あるイディオムが広く知られて受け入れられているのならば、それを使うための議論をします。</span> <span title="However, sometimes standard features and idioms are flawed, or were just designed without our codebase's needs in mind.">しかし、時折、標準的な機能やイディオムは、不備があったり、あるいは単に私たちのコードベースのニーズを満たさない形でデザインされていたりします。</span> <span title="In those cases (as described below) it's appropriate to constrain or ban standard features.">このような場合、これらの標準機能は制限または禁止することが適切です。</span> <span title="In some cases we prefer a homegrown or third-party library over a library defined in the C++ Standard, either out of perceived superiority or insufficient value to transition the codebase to the standard interface.">いくつかのケースでは、C++標準ライブラリよりも自家製もしくはサードパーティのライブラリを選ぶ場合もあります。標準的なインターフェースにコードベースを移行することには知的優位性も十分な価値もありません。</span></dd>

                    <dt><span title="Avoid surprising or dangerous constructs">見慣れない、あるいは危険な構成は避けること</span></dt>
                    <dd>
                        <span title="C++ has features that are more surprising or dangerous than one might think at a glance.">C++には、ちょっと考えただけでは気が付かないかもしれない、驚くような、あるいは危険な機能も存在します。</span> <span title="Some style guide restrictions are in place to prevent falling into these pitfalls.">本ガイドにおけるいくつかの制限ルールは、このような落とし穴を避けるためのものです。</span> <span title="There is a high bar for style guide waivers on such restrictions, because waiving such rules often directly risks compromising program correctness.">これらのルールを破棄するとプログラムの正確性が失われる可能性があるため、それらのルールを破棄するためには高いハードルを設けています。</span>
                    </dd>

                    <dt><span title="Avoid constructs that our average C++ programmer would find tricky or hard to maintain">平均的なC++プログラマがトリッキーと感じたり、メンテしにくいと感じたりするような構成は避けること</span></dt>
                    <dd><span title="C++ has features that may not be generally appropriate because of the complexity they introduce to the code.">C++はその複雑さゆえに、コードに導入するのが適切でないような機能も持っています。</span> <span title="In widely used code, it may be more acceptable to use trickier language constructs, because any benefits of more complex implementation are multiplied widely by usage, and the cost in understanding the complexity does not need to be paid again when working with new portions of the codebase.">広く使われているコードの中は、トリッキーな言語構造の方が受け入れられることもあるかもしれません。その場合の理由は、より複雑な実装が過去に繰り返されてきたことや、その複雑なものを理解するコストは、コードベースの新しい部分で仕事をする時にもう一度払う必要はないからです。</span> <span title="When in doubt, waivers to rules of this type can be sought by asking  your project leads.">これを疑うのであれば、このタイプのルールの破棄についてプロジェクトリーダーと相談してください。</span> <span title="This is specifically important for our codebase because code ownership and team membership changes over time: even if everyone that works with some piece of code currently understands it, such understanding is not guaranteed to hold a few years from now.">これは我々のコードベースでは特に重要です。なぜなら、コードの担当者やチームメンバーは時とともに変わるからです。誰かがそのコードを理解して触っていたとしても、その理解が今から1年後にも保たれている保証はどこにもありません。</span></dd>

                    <dt><span title="Be mindful of our scale">我々のプロジェクト規模に留意すること</span></dt>
                    <dd><span title="With a codebase of 100+ million lines and thousands of engineers, some mistakes and simplifications for one engineer can become costly for many.">1億行以上のコードがあり、何千人ものエンジニアがいる状況において、ある一人のエンジニアのミスや単純化によるコストは非常に高くつくことがあります。</span> <span title="For instance it's particularly important to avoid polluting the global namespace: name collisions across a codebase of hundreds of millions of lines are difficult to work with and hard to avoid if everyone puts things into the global namespace.">たとえば、グローバル名前空間汚染を避けることは非常に重要です。何億行ものコードベースの間で、もし、誰もがグローバル名前空間に何でもかんでもおいていたら、名前の衝突は不可避です。</span></dd>

                    <dt><span title="Concede to optimization when necessary">必要な最適化は厭わない</span></dt>
                    <dd><span title="Performance optimizations can sometimes be necessary and appropriate, even when they conflict with the other principles of this document.">たとえ本ガイドのルールと競合したとしても、ときにパフォーマンスの最適化は必要かつ適切な場合もあります。</span></dd>
                </dl>

                <p>
                    <span title="The intent of this document is to provide maximal guidance with reasonable restriction.">本文書の目的は理にかなった制限の下での最大限のガイダンスを提供することです。</span>
                    <span title="As always, common sense and good taste should prevail.">いつもどおり、常識や良識が優先されるべきです。</span>
                    <span title="By this we specifically refer to the established conventions of the entire Google C++ community, not just your personal preferences or those of your team.">これによって、我々は、具体的に、あなたの個人的な好みやあなたのチームについてだけではなく、Google C++コミュニティ全体で確立された規約に言及します。</span>
                    <span title="Be skeptical about and reluctant to use clever or unusual constructs: the absence of a prohibition is not the same as a license to proceed.">巧妙なあるいは見慣れない構成には、懐疑的であってください。禁止されていないことはやっていいというわけではありません。</span>
                    <span title="Use your judgment, and if you are unsure, please don't hesitate to ask your project leads to get additional input.">自分の判断に従ってください。ルールに賛同できない場合には、自プロジェクトのリーダーに対して更なるインプットを求めることを躊躇わないようにしください。</span>
                </p>

            </div>



            <h2 id="Header_Files">
                <span title="Header Files">ヘッダファイル</span>
            </h2>

            <p>
                <span title="In general, every .cc file should have an associated .h file.">原則的に、全ての<code>.cc</code>ファイルは関連付く<code>.h</code>ファイルを持つようにします。</span>
                <span title="There are some common exceptions, such as unittests and small .cc files containing just a main() function.">ただし、ユニットテストや<code>main()</code>だけを含むような小さな<code>.cc</code>は例外です。</span>
            </p>


            <p>
                <span title="Correct use of header files can make a huge difference to the readability, size and performance of your code.">正しくヘッダーファイルを扱うことは、コードの可読性やサイズ、パフォーマンスに大きな違いをもたらします。</span>
            </p>

            <p>
                <span title="The following rules will guide you through the various pitfalls of using header files.">以下のルールはヘッダーファイルに関する様々な落とし穴を避けて通るための道しるべとなるはずです。</span>
            </p>

            <a id="The_-inl.h_Files"></a>
            <h3 id="Self_contained_Headers">
                <span title="Self-contained Headers">自己完結型ヘッダー</span>
            </h3>

            <div class="summary">
                <p>
                    <span title="Header files should be self-contained (compile on their own) and end in .h.">ヘッダファイルは自己完結(単体でコンパイルできる)していなくてはならず、名前は<code>.h</code>で終わります。</span>
                    <span title="Non-header files that are meant for inclusion should end in .inc and be used sparingly.">ヘッダファイルではない、includeして使われるべきものは<code>.inc</code>で終わるようにしますが、なるべく使用は控えるようにしましょう。
                </p>
            </div>

            <div class="stylebody">
                <p>
                    <span title="All header files should be self-contained.">すべてのヘッダは自己完結していなくてはなりません。</span>
                    <span title="Users and refactoring tools should not have to adhere to special conditions to include the header.">ヘッダの使用者やリファクタリングツールは、そのヘッダがincludeされる際に、なんら特別な条件を守る必要がないようにします。</span>
                    <span title="Specifically, a header should have header guards and include all other headers it needs.">特に、ヘッダには<a href="#The__define_Guard">インクルードガード</a>を持たせ、そのヘッダ自身が必要とするすべての他のヘッダをincludeします。</span>
                </p>

                <p>
                    <span title="Prefer placing the definitions for template and inline functions in the same file as their declarations.">テンプレートやインライン関数などの定義は、宣言と同じファイルに含めましょう。</span>
                    <span title="The definitions of these constructs must be included into every .cc file that uses them, or the program may fail to link in some build configurations.">これらの定義は、それを用いるすべての<code>.cc</code>ファイルに含まれる必要があり、さもなくばビルド環境によってはリンクに失敗するかもしれません。</span>
                    <span title="If declarations and definitions are in different files, including the former should transitively include the latter.">もし宣言と定義が違うファイルに分かれているならば、前者は後者をincludeすべきです。</span>
                    <span title="Do not move these definitions to separately included header files (-inl.h); this practice was common in the past, but is no longer allowed.">これらの定義を分割ヘッダファイル(<code>-inl.h</code>)に移動してはなりません。その手法は古いやり方であり、現在は禁止されています。</span>
                </p>

                <p>
                    <span title="As an exception, a template that is explicitly instantiated for all relevant sets of template arguments, or that is a private implementation detail of a class, is allowed to be defined in the one and only .cc file that instantiates the template.">例外として、すべての関連するテンプレート引数セットについて明示的に例示されたテンプレートや、クラスのprivateな実装であるテンプレートは、そのテンプレートを実体化している唯一の<code>.cc</code>ファイルで定義しても構いません。</span>
                </p>

                <p>
                    <span title="There are rare cases where a file designed to be included is not self-contained.">レアケースながら、includeされるが自己完結でないようなデザインも存在します。</span>
                    <span title="These are typically intended to be included at unusual locations, such as the middle of another file.">これらはたいていの場合、別のファイルの途中(中ほど)など変わった場所でinlucdeされることを想定しています。</span>
                    <span title="They might not use header guards, and might not include their prerequisites.">それらのファイルは、<a href="#The__define_Guard">インクルードガード</a>を持っていなかったり、そのヘッダ内で必要なものをincludeしていなかったりします。</span>
                    <span titile="Name such files with the .inc extension.">このようなファイルには、<code>.inc</code>拡張子を持たせるようにします。</span>
                    <span title="Use sparingly, and prefer self-contained headers when possible.">また、なるべく使用は避け、可能な限り自己完結型ヘッダを使うことを選択しましょう。</span>
                </p>

            </div>

            <h3 id="The__define_Guard">
                <span title="#define guards">インクルードガード</span>
            </h3>

            <div class="summary">
                <p>
                    <span title="All header files should have #define guards to prevent multiple inclusion.">すべてのヘッダファイルは、インクルードガード(<code>#define</code> guards)を持たなくてはなりません。</span>
                    <span title="The format of the symbol name should be &lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H_.">その際のシンボル名は<code><i>&lt;PROJECT&gt;</i>_<i>&lt;PATH&gt;</i>_<i>&lt;FILE&gt;</i>_H_</code>の形でなくてはなりません。</span>
                </p>
            </div>

            <div class="stylebody">



                <p>
                    <span title="To guarantee uniqueness, they should be based on the full path in a project's source tree.">ユニーク性を保証するため、プロジェクト内ソースツリーのフルパスに基づくものにします。</span>
                    <span title="For example, the file foo/src/bar/baz.h in project foo should have the following guard:">たとえば、プロジェクトfooに含まれるファイル<code>foo/src/bar/baz.h</code>のガードは次のようにします。</span>
                </p>

<pre>#ifndef FOO_BAR_BAZ_H_
#define FOO_BAR_BAZ_H_

...

#endif  // FOO_BAR_BAZ_H_
</pre>




            </div>

            <h3 id="Forward_Declarations">
                <span title="Forward Declarations">前方宣言</span>
            </h3>

            <div class="summary">
                <p>
                    <span title="Avoid using forward declarations where possible.">前方宣言は可能な限り避けましょう。</span>
                    <span title="Just #include the headers you need.">必要ならば単にヘッダを<code>#include</code>してください。
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        <span title="A &quot;forward declaration&quot; is a declaration of a class, function, or template without an associated definition.">前方宣言とは、関連付く定義のないクラス・関数・テンプレートの宣言のことです。</span>
                    </p>
                </div>

                <div class="pros">
                    <ul>
                        <li>
                            <span title="Forward declarations can save compile time, as #includes force the compiler to open more files and process more input.">前方宣言は、<code>#include</code>がコンパイラに多数のファイルを開かせてそれを処理させるためのコンパイル時間を節約することができます。</span>
                        </li>

                        <li>
                            <span title="Forward declarations can save on unnecessary recompilation.">前方宣言は、不必要な再コンパイルを抑えることができます。</span>
                            <span title="#includes can force your code to be recompiled more often, due to unrelated changes in the header."><code>#include</code>は、ヘッダの変更があなたのコードに無関係な場合でもコードを再コンパイルする必要があるため、再コンパイルの頻度が上がります。</span>
                        </li>
                    </ul>
                </div>

                <div class="cons">
                    <ul>
                        <li>
                            <span title="Forward declarations can hide a dependency, allowing user code to skip necessary recompilation when headers change.">前方宣言は、依存性を隠してしまうため、コードの再コンパイルが必要な場合でも、それをスキップさせてしまうことがあります。</span>
                        </li>

                        <li>
                            <span title="A forward declaration may be broken by subsequent changes to the library.">前方宣言は、将来のライブラリ側の変更によって壊れる可能性があります。</span>
                            <span title="Forward declarations of functions and templates can prevent the header owners from making otherwise-compatible changes to their APIs, such as widening a parameter type, adding a template parameter with a default value, or migrating to a new namespace.">関数やテンプレートの前方宣言は、元のヘッダの持ち主がAPIに対する互換性のない変更(パラメータの型を拡張したり、デフォルト値とともにテンプレートパラメータを増やしたり、新しい名前空間への移行したり)をすることを妨げになります。</span>
                        </li>

                        <li>
                            <span title="Forward declaring symbols from namespace std yields undefined behavior."><code>std::</code>名前空間のシンボルに対する前方宣言は未定義動作を引き起こします。</span>
                        </li>

                        <li>
                            <span title="It can be difficult to determine whether a forward declaration or a full #include is needed.">前方宣言だけで済むのか、<code>#include</code>が必要かを判断するのは、難しいことがあります。</span>
                            <span title="Replacing an #include with a forward declaration can silently change the meaning of code:">次のコードの<code>#include</code>を単に前方宣言に置き換えてしまうと、コードの意味が変わってしまいます。</span>
                            <pre>      // b.h:
      struct B {};
      struct D : B {};

      // good_user.cc:
      #include "b.h"
      void f(B*);
      void f(void*);
      void test(D* x) { f(x); }  // calls f(B*)
      </pre>

                            <span title="If the #include was replaced with forward decls for B and D, test() would call f(void*)."><code>B</code>と<code>D</code>に対する<code>#include</code>を、単に前方宣言に置き換えてしまった場合、test()は <code>f(void*)</code> を呼び出すことになるでしょう。</span>
                        </li>

                        <li>
                            <span title="Forward declaring multiple symbols from a header can be more verbose than simply #include-ing the header.">ある1つのヘッダに含まれる複数のシンボルを前方宣言することは、単にそのヘッダを<code>#include</code>するよりも冗長になってしまいます。</span>
                        </li>

                        <li>
                            <span title="Structuring code to enable forward declarations (e.g. using pointer members instead of object members) can make the code slower and more complex.">前方宣言を使ってコードを作ろうとすると、(メンバにオブジェクトではなくポインタにしなくてはならないなど)、実行速度を下げ、しかも複雑なコードを書く羽目になるかもしれません。</span>
                        </li>


                    </ul>
                </div>

                <div class="decision">
                    <ul>
                        <li>
                            <span title="Try to avoid forward declarations of entities defined in another project.">外部プロジェクト内に存在するモノの前方宣言は避けましょう。</span>
                        </li>

                        <li>
                            <span title="When using a function declared in a header file, always #include that header.">ヘッダで宣言されている関数を使いたい場合は、常にそのヘッダを<code>#include</code>しましょう。</span>
                        </li>

                        <li>
                            <span title="When using a class template, prefer to #include its header file.">クラステンプレートを使いたい場合、ヘッダを<code>#include</code>しましょう。</span>
                        </li>
                    </ul>

                    <p>
                        <span title="Please see Names and Order of Includes for rules about when to #include a header.">ヘッダの<code>#include</code>関するルール<a href="#Names_and_Order_of_Includes">インクルードの名前と順序</a>も読んでください。</span>
                    </p>
                </div>

            </div>

            <h3 id="Inline_Functions">
                <span title="Inline Functions">インライン関数</span>
            </h3>

            <div class="summary">
                <p>
                    <span title="Define functions inline only when they are small, say, 10 lines or fewer.">インライン関数は、関数の定義が小さいとき(10行以下)だけ使うようにしましょう。</span>
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        <span title="You can declare functions in a way that allows the compiler to expand them inline rather than calling them through the usual function call mechanism.">関数は、コンパイラに対して、通常の関数呼び出しの代わりに、直接その場に展開することを許した形で宣言することができます。
                    </p>
                </div>

                <div class="pros">
                    <p>
                        <span title="Inlining a function can generate more efficient object code, as long as the inlined function is small.">関数のインライン化によって、インライン化される関数が小さければ、効率的なオブジェクトコードを生成することができるようになります。</span>
                        <span title="Feel free to inline accessors and mutators, and other short, performance-critical functions.">アクセサ(訳注:日本語圏でいうGetterのこと)やミューテータ(訳注:日本語圏でいうSetterのこと)、パフォーマンスクリティカルな小さい関数はどんどんインライン化しましょう。</span>
                    </p>
                </div>

                <div class="cons">
                    <p>
                        <span title="Overuse of inlining can actually make programs slower.">インライン関数を使いすぎると実のところプログラムは遅くなることもあります。</span>
                        <span title="Depending on a function's size, inlining it can cause the code size to increase or decrease.">関数のサイズによっては、インライン化によってコードのサイズも増えたり減ったりします。</span>
                        <span title="Inlining a very small accessor function will usually decrease code size while inlining a very large function can dramatically increase code size.">とても小さいアクセッサ関数をインライン化する場合たいていコードのサイズは小さくなりますが、一方で、大きな関数をインライン化してしまうと全体のコードサイズは劇的に大きくなってしまうこともあります。</span>
                        <span title="On modern processors smaller code usually runs faster due to better use of the instruction cache.">イマドキのCPUにおいては、大抵の場合、命令キャッシュがうまく使える小さいコードの方が動作が速いです。</span>
                    </p>
                </div>

                <div class="decision">
                    <p>
                        <span title="A decent rule of thumb is to not inline a function if it is more than 10 lines long.">経験的なルールとして、関数が10行より多くなったらインライン化すべきではないです。</span>
                        <span title="Beware of destructors, which are often longer than they appear because of implicit member- and base-destructor calls!">デストラクタに特に気を付けましょう。デストラクタは、暗黙的にメンバのデストラクタと基底デストラクタを呼び出すため見た目より長くなることがしばしばあるのです！</span>
                    </p>

                    <p>
                        <span title="Another useful rule of thumb: it's typically not cost effective to inline functions with loops or switch statements (unless, in the common case, the loop or switch statement is never executed).">もう１つ、有用な経験的なルールとして、大抵の場合、ループやswitch文のある関数は(それらがまったく実行されないような場合を除いて)インライン化しても効率的にはなりません。
                    </p>

                    <p>
                        <span title="It is important to know that functions are not always inlined even if they are declared as such; for example, virtual and recursive functions are not normally inlined.">重要な知識として、インライン関数はインラインで宣言されたからといって常にインライン化されるわけではありません。たとえば仮想関数や再帰関数は通常インライン化されません。</span>
                        <span title="Usually recursive functions should not be inline.">通常、再帰関数はインライン化すべきではありません。</span>
                        <span title="The main reason for making a virtual function inline is to place its definition in the class, either for convenience or to document its behavior, e.g., for accessors and mutators.">仮想関数をクラス内にインラインで定義する理由は、利便性や、(GetterやSetterの場合など)動作に関するドキュメントとしての役割があるからです。</span>
                    </p>
                </div>

            </div>

            <h3 id="Names_and_Order_of_Includes">
                <span title="Names and Order of Includes">インクルードの名前と順序</span>
            </h3>

            <div class="summary">
                <p>
                    <span title="Use standard order for readability and to avoid hidden dependencies:">可読性を保つため、また、依存関係が隠れるのを防ぐため、次に示す順序でヘッダをincludeします。</span>
                    <span title="Related header, C library, C++ library,  other libraries' .h, your project's .h.">関連付くヘッダ, Cライブラリヘッダ, C++ライブラリヘッダ, 他のライブラリヘッダ, 自分のプロジェクトのヘッダ.</span>
                </p>
            </div>

            <div class="stylebody">
                <p>
                    <span title="All of a project's header files should be listed as descendants of the project's source directory without use of UNIX directory shortcuts . (the current directory) or .. (the parent directory).">プロジェクトヘッダはプロジェクトソースディレクトリ以下に配置しなくてはなりません。UNIXディレクトリショートカットである <code>.</code>(カレントディレクトリ)や、<code>..</code>(親ディレクトリ)は省きます。</span>
                    <span title="For example, google-awesome-project/src/base/logging.h should be included as:">たとえば、<code>google-awesome-project/src/base/logging.h</code>は次のようにインクルードされます。
                </p>

<pre>#include "base/logging.h"
</pre>

                <p>
                    <span title="In dir/foo.cc or dir/foo_test.cc, whose main purpose is to implement or test the stuff in dir2/foo2.h, order your includes as follows:"><code><var>dir2/foo2</var>.h</code>の宣言を実装もしくはテストする目的のファイル、<code><var>dir/foo</var>.cc</code>や<code><var>dir/foo_test</var>.cc</code>の中では、次の順序でincludeします。</span>
                </p>

                <ol>
                    <li>
                        <code><var>dir2/foo2</var>.h</code>.
                    </li>

                    <li>
                        <span title="C system files.">C システムヘッダ</span>
                    </li>

                    <li>
                        <span title="C++ system files.">C++ システムヘッダ</span>
                    </li>

                    <li>
                        <span title="Other libraries' .h files.">ほかのライブラリの<code>.h</code>ファイル
                    </li>

                    <li>
                        <span title="Your project's .h files.">あなたのプロジェクトの.hファイル</span>
                    </li>
                </ol>

                <p>
                    <span title="With the preferred ordering, if dir2/foo2.h omits any necessary includes, the build of dir/foo.cc or dir/foo_test.cc will break.">この順番であれば、もし<code><var>dir2/foo2</var>.h</code>が必要なincludeを省くと、<code><var>dir/foo</var>.cc</code>や<code><var>dir/foo</var>_test.cc</code>のビルドが失敗します。</span>

                    <span title="Thus, this rule ensures that build breaks show up first for the people working on these files, not for innocent people in other packages.">このルールであれば、ビルドが壊れたことを、他のパッケージで作業している無実の人ではなく、このファイルで作業をしていた人に一番最初に見せることができます。</span>
                </p>

                <p>
                    <span title="dir/foo.cc and dir2/foo2.h are usually in the same directory (e.g. base/basictypes_test.cc and base/basictypes.h), but may sometimes be in different directories too."><code><var>dir/foo</var>.cc</code>と<code><var>dir2/foo2</var>.h</code>は、一般的に同じディレクトリに置きますが(たとえば、<code>base/basictypes_test.cc</code>と<code>base/basictypes.h</code>)、異なるディレクトリに置いてもよいです。
                </p>


                <p>
                    <span title="Within each section the includes should be ordered alphabetically.">各セクション内ではアルファベット順に並べます。</span>
                    <span title="Note that older code might not conform to this rule and should be fixed when convenient.">古いコードはこのルールに沿ってないかもしれませんが、利便性を考えたときは修正(訳注:be fixed)します。</span>
                </p>

                <p>
                    <span title="You should include all the headers that define the symbols you rely upon, except in the unusual case of forward declaration.">ヘッダは、<a href="#Forward_Declarations">前方宣言</a>の例外を除いて、ヘッダが定義するシンボルに関連するすべてのヘッダをインクルードしなくてはなりません。</span>
                    <span title="If you rely on symbols from bar.h, don't count on the fact that you included foo.h which (currently) includes bar.h: include bar.h yourself, unless foo.h explicitly demonstrates its intent to provide you the symbols of bar.h.">
                        もし、あなたが<code>bar.h</code>のシンボルに依存した定義をしようとしているのであれば、(仮にその時点で<code>bar.h</code>をインクルードしている<code>foo.h</code>をインクルードしていたとしてもその事実は忘れて、)素直に<code>bar.h</code>をインクルードするようにします。<code>foo.h</code>が<code>bar.h</code>のシンボルを提供すると明示的に説明している場合は除きます。
                    </span>

                    <span title="However, any includes present in the related header do not need to be included again in the related cc (i.e., foo.cc can rely on foo.h's includes).">関連ヘッダでインクルードしているヘッダは、<code>cc</code>ファイルで再度インクルードしないようにします。(つまり、<code>foo.cc</code>は、<code>foo.h</code>がインクルードに依存することができます)</span>
                </p>

                <p>
                    <span title="For example, the includes in google-awesome-project/src/foo/internal/fooserver.cc might look like this:">
                        例をあげます。<code>google-awesome-project/src/foo/internal/fooserver.cc</code>のインクルードは次のようになります。
                    </span>
                </p>


<pre>#include "foo/server/fooserver.h"

#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

#include &lt;hash_map&gt;
#include &lt;vector&gt;

#include "base/basictypes.h"
#include "base/commandlineflags.h"
#include "foo/server/bar.h"
</pre>

                <p class="exception">
                    <span title="Sometimes, system-specific code needs conditional includes.">システム特有のコードは、しばしば条件が必要なインクルードを必要とする場合があります。</span>
                    <span title="Such code can put conditional includes after other includes.">このようなコードは他のインクルードの後に条件付きインクルードを配置します。</span>
                    <span title="Of course, keep your system-specific code small and localized.">もちろんのことですが、システム特有のコードは小さく局所的に保つようにしましょう。</span>
                    <span title="Example:">例:</span>
                </p>

<pre>#include "foo/public/fooserver.h"

#include "base/port.h"  // For LANG_CXX11.

#ifdef LANG_CXX11
#include &lt;initializer_list&gt;
#endif  // LANG_CXX11
</pre>

            </div>

            <h2 id="Scoping">
                <span title="Scoping">スコープ</span>
            </h2>

            <h3 id="Namespaces">
                <span title="Namespaces">名前空間</span>
            </h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            With few exceptions, place code in a namespace.
                        </span>
                        細かい例外を除いて、コードは名前空間の中に置いてください。
                    </span>
                    <span>
                        <span class="src">
                            Namespaces should have unique names based on the project name, and possibly its path.
                        </span>
                        名前空間はプロジェクト名やファイルのパスに基づいてユニークな名前をつけてください。
                    </span>
                    <span>
                        <span class="src">
                            Do not use <i>using-directives</i> (e.g.
                            <code>using namespace foo</code>).
                        </span>また、usingディレクティブ(<code>using namespace foo</code>)は使ってはいけません。
                    </span>
                    <span>
                        <span class="src">
                            Do not use inline namespaces.
                        </span>
                        インライン名前空間も使ってはいけません。
                    </span>

                    <span>
                        <span class="src">
                            For unnamed namespaces, see
                            <a href="#Unnamed_Namespaces_and_Static_Variables">
                                Unnamed Namespaces and
                                Static Variables
                            </a>.
                        </span>
                        無名名前空間については<a href="#Unnamed_Namespaces_and_Static_Variables">無名名前空間と静的変数</a>を参照してください。
                    </span></a>.
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        <span>
                            <span class="src">
                                Namespaces subdivide the global scope
                                into distinct, named scopes, and so are useful for preventing
                                name collisions in the global scope.
                            </span>
                            名前空間は、グローバルなスコープを名前付きのスコープに分割し、グローバルスコープにおける名前の衝突を防ぐのに有用です。
                        </span>
                    </p>
                </div>

                <div class="pros">

                    <p>
                        <span>
                            <span class="src">
                                Namespaces provide a method for preventing name conflicts
                                in large programs while allowing most code to use reasonably
                                short names.
                            </span>
                            名前空間を用いることで、大きなプログラムにおける名前の衝突を避け、コードの大部分で理にかなった短い名前を使うことができるようになります。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                For example, if two different projects have a class
                                <code>Foo</code> in the global scope, these symbols may
                                collide at compile time or at runtime.
                            </span>たとえば、2つのプロジェクトが同じ名前のクラス<code>Foo</code>をグローバル名前空間に持っていたとすると、これらのシンボルはコンパイル時や実行時に衝突してしまうかもしれません。
                        </span>
                        <span>
                            <span class="src">
                                If each project
                                places their code in a namespace, <code>project1::Foo</code>
                                and <code>project2::Foo</code> are now distinct symbols that
                                do not collide, and code within each project's namespace
                                can continue to refer to <code>Foo</code> without the prefix.
                            </span>
                            しかし、各プロジェクトが独自の名前空間を持っていれば、同名だったシンボル<code>project1::Foo</code>と<code>project2::Foo</code>は区別できるようになり、衝突しなくなります。一方で、各プロジェクトの名前空間内のコードは、引き続き、プレフィクスなしの<code>Foo</code>で参照を保つことができます。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">Inline namespaces automatically place their names in the enclosing scope.</span>
                            インライン名前空間は、自動的に、その内部に持つ名前を、自身を囲む(外側の)スコープに配置します。
                        </span>

                        <span>
                            <span class="src">Consider the following snippet, for example:</span>
                            例として、次のスニペットについて考えます。
                        </span>
                    </p>

<pre>namespace X {
inline namespace Y {
  void foo();
}  // namespace Y
}  // namespace X
</pre>

                    <p>
                        <span>
                            <span class="src">
                                The expressions <code>X::Y::foo()</code> and
                                <code>X::foo()</code> are interchangeable.
                            </span>
                            このとき、式<code>X::Y::foo()</code>は<code>X::foo()</code>とも書けます。
                        </span>
                        <span>
                            <span class="src">
                                Inline namespaces are primarily intended for ABI compatibility across versions.
                            </span>
                            インライン名前空間は、主にバージョン間におけるABIの互換性を保つことを目的としています。
                            `
                        </span>
                    </p>
                </div>

                <div class="cons">

                    <p>
                        <span>
                            <span class="src">
                                Namespaces can be confusing, because they complicate
                                the mechanics of figuring out what definition a name refers
                                to.
                            </span>
                            名前空間は、その名前解決の仕組みの複雑さから、混乱を招くこともあります。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Inline namespaces, in particular, can be confusing
                                because names aren't actually restricted to the namespace
                                where they are declared.
                            </span>
                            インライン名前空間は、事実上その中で宣言される名前を名前空間の中に閉じ込めないため、特に混乱しやすいです。
                        </span>
                        <span>
                            <span class="src">
                                They are only useful as part of
                                some larger versioning policy.
                            </span>
                            インライン名前空間は、バージョン管理ポリシーの一部としてのみ役に立ちます。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                In some contexts, it's necessary to repeatedly refer to
                                symbols by their fully-qualified names.
                            </span>
                            いくつかの文脈では、シンボルを解決するのに完全修飾された名前を用いる必要があります。
                        </span>
                        <span>
                            <span class="src">
                                For deeply-nested
                                namespaces, this can add a lot of clutter.
                            </span>
                            名前空間のネストが深い場合、コードが散らってしまうことになりかねません。
                        </span>
                    </p>
                </div>

                <div class="decision">

                    <p>
                        <span>
                            <span class="src">
                                Namespaces should be used as follows:
                            </span>
                            名前空間は次のように使いましょう:
                        </span>
                    </p>

                    <ul>
                        <li>
                            <span>
                                <span class="src">Follow the rules on <a href="#Namespace_Names">Namespace Names</a></span>
                                <a href="#Namespace_Names">名前空間の名前</a>のルールに従ってください。
                            </span>
                        </li>
                        <li>
                            <span>
                                <span class="src">Terminate namespaces with comments as shown in the given examples.</span>
                                名前空間の終わりには、先の例の通り、コメントをつけてください。
                            </span>
                        </li>
                        <li>
                            <p>
                                <span>
                                    <span class="src">
                                        Namespaces wrap the entire source file after
                                        includes,
                                        <a href="https://gflags.github.io/gflags/">gflags</a> definitions/declarations
                                        and forward declarations of classes from other namespaces.
                                    </span>
                                    名前空間は、include文や<a href="https://gflags.github.io/gflags/">gflags</a>の定義と宣言、他の名前空間のクラスの前方宣言の後に続くソースコードをすべて包むようにしてください。
                                </span>
                            </p>
                            <span>
                                <span class="src">
<pre>// In the .h file
namespace mynamespace {

// All declarations are within the namespace scope.
// Notice the lack of indentation.
class MyClass {
 public:
  ...
  void Foo();
};

}  // namespace mynamespace
</pre>
                                </span>
                                <pre>// .h ファイル
namespace mynamespace {

// すべての宣言は名前空間のスコープに含めます。
// インデントはしません。
class MyClass {
 public:
  ...
  void Foo();
};

}  // namespace mynamespace
</pre>
<pre>// .ccファイル
namespace mynamespace {

// 関数の定義は名前空間に含めます。
void MyClass::Foo() {
  ...
}

}  // namespace mynamespace
</pre>
                            </span>

                            <p>
                                <span>
                                    <span class="src">
                                        More complex <code>.cc</code> files might have additional details,
                                        like flags or using-declarations.
                                    </span>
                                    より複雑な <code>.cc</code>ファイルは、flagsやusing宣言などを含む場合もあります。
                                </span>
                            </p>
                            <span>
                                <span class="src">
<pre>#include "a.h"

DEFINE_FLAG(bool, someflag, false, "dummy flag");

namespace a {

using ::foo::bar;

...code for a...         // Code goes against the left margin.

}  // namespace a
</pre>
                                </span>
                                <pre>#include "a.h"

DEFINE_FLAG(bool, someflag, false, "dummy flag");

namespace a {

using ::foo::bar;

...code for a...         // コードの左側には余白を入れない。

}  // namespace a
</pre>
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Do not declare anything in namespace
                                    <code>std</code>, including forward declarations of
                                    standard library classes.
                                </span><code>std</code>名前空間の中には、標準ライブラリの前方宣言を含めて、何も宣言してはいけません。
                            </span>
                            <span>
                                <span class="src">
                                    Declaring entities in
                                    namespace <code>std</code> is undefined behavior, i.e.,
                                    not portable.
                                </span><code>std</code>名前空間の中に何かを宣言することは、コードの移植性を失わせ、未定義の動作を引き起こします。
                            </span>
                            <span>
                                <span class="src">
                                    To declare entities from the standard
                                    library, include the appropriate header file.
                                </span>標準ライブラリのエンティティを宣言するためには適切なヘッダファイルをインクルードします。
                            </span>
                        </li>

                        <li>
                            <p>
                                <span>
                                    <span class="src">
                                        You may not use a <i>using-directive</i>
                                        to make all names from a namespace available.
                                    </span>
                                    名前空間内のすべての名前を利用できるようにするための<i>usingディレクティブ</i>は使ってはいけません。
                                </span>
                            </p>
                            <span>
                                <span class="src">
<pre class="badcode">// Forbidden -- This pollutes the namespace.
using namespace foo;
</pre>
                                </span>
                                <pre class="badcode">// ダメ。名前空間を汚染している。
using namespace foo;
</pre>
                            </span>
                        </li>

                        <li>
                            <p>
                                <span>
                                    <span class="src">
                                        Do not use <i>Namespace aliases</i> at namespace scope
                                        in header files except in explicitly marked
                                        internal-only namespaces, because anything imported into a namespace
                                        in a header file becomes part of the public
                                        API exported by that file.
                                    </span>
                                    内部的に使用すると明示した名前空間の中を除いて、名前空間の別名(Namespace ailiases)</i>をヘッダファイルの名前空間のスコープで使ってはいけません。なぜならば、ヘッダファイルで名前空間にインポートされたすべてのものが、そのヘッダファイルが提供するpublicなAPIの一部として公開されることになるからです。
                                </span>
                            </p>

                            <span>
                                <span class="src">
                                    <pre>// Shorten access to some commonly used names in .cc files.
namespace baz = ::foo::bar::baz;
</pre>
                                </span>
                                <pre>// .ccファイルの中でたくさん使われる名前へのショートカットを作る。
namespace baz = ::foo::bar::baz;
</pre>
                            </span>
                            <span>
                                <span class="src">
<pre>// Shorten access to some commonly used names (in a .h file).
namespace librarian {
namespace impl {  // Internal, not part of the API.
namespace sidetable = ::pipeline_diagnostics::sidetable;
}  // namespace impl

inline void my_inline_function() {
  // namespace alias local to a function (or method).
  namespace baz = ::foo::bar::baz;
  ...
}
}  // namespace librarian
</pre>
                                </span><pre>// .hファイルの中で、よく使われる名前へのショートカットを作る。
namespace librarian {
namespace impl {  // 内部用。APIではありません。
namespace sidetable = ::pipeline_diagnostics::sidetable;
}  // namespace impl

inline void my_inline_function() {
  // 関数内に限定された名前空間の別名。
  namespace baz = ::foo::bar::baz;
  ...
}
}  // namespace librarian
</pre>
                            </span>

                        </li>
                        <li>
                            <span><span class="src">Do not use inline namespaces.</span>インライン名前空間は使ってはいけません。</span>
                        </li>
                    </ul>
                </div>
            </div>

            <h3 id="Unnamed_Namespaces_and_Static_Variables">
                <span title="Unnamed Namespaces and Static Variables">無名名前空間と静的変数</span>
            </h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            When definitions in a <code>.cc</code> file do not need to be
                            referenced outside that file, place them in an unnamed
                            namespace or declare them <code>static</code>.
                        </span>
                        <code>.cc</code>ファイル中に、ファイル外から参照される必要がない定義を行うときは、それらを無名の名前空間内で宣言するか、<code>static</code>に宣言します。
                    </span>
                    <span>
                        <span class="src">
                            Do not use either
                            of these constructs in <code>.h</code> files.
                        </span>
                        これらの宣言を<code>.h</code>においてはいけません。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        <span>
                            <span class="src">
                                All declarations can be given internal linkage by placing them in
                                unnamed namespaces, and functions and variables can be given internal linkage by
                                declaring them <code>static</code>.
                            </span>
                            無名名前空間内のすべての宣言は内部リンケージとなります。また<code>static</code>に宣言された関数や変数も内部リンケージとなります。
                        </span>
                        <span>
                            <span class="src">
                                This means that anything you're declaring
                                can't be accessed from another file.
                            </span>
                            内部リンケージとなったものは、他のファイルからアクセスできません。
                        </span>
                        <span>
                            <span class="src">
                                If a different file declares something
                                with the same name, then the two entities are completely independent.
                            </span>
                            仮に、他のファイルで同じ名前が宣言されていたとしても、それらは2つの独立した別々の実体として扱われます。
                        </span>
                    </p>
                </div>

                <div class="decision">

                    <p>
                        <span>
                            <span class="src">
                                Use of internal linkage in <code>.cc</code> files is encouraged
                                for all code that does not need to be referenced elsewhere.
                            </span>
                            <code>.cc</code>で内部リンケージを使うことで、他の場所からこれらのコードは参照されてないということを強調できます。
                        </span>
                        <span>
                            <span class="src">
                                Do not use internal linkage in <code>.h</code> files.
                            </span>
                            <code>.h</code>ファイルでは内部リンケージは使用してはいけません。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Format unnamed namespaces like named namespaces.
                            </span>
                            無名名前空間も、名前付きの名前空間と同じようにフォーマットします。
                        </span>
                        <span>
                            <span class="src">
                                In the
                                terminating comment, leave the namespace name empty:
                            </span>
                            無名名前空間が終わるときのコメントは、以下の例のように名前空間名を空白のままにしておきます。
                        </span>
                    </p>

<pre>namespace {
...
}  // namespace
</pre>
                </div>
            </div>

            <h3 id="Nonmember,_Static_Member,_and_Global_Functions">
                <span title="Nonmember, Static Member, and Global Functions">メンバではない関数、静的メンバ関数、グローバル関数
            </h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Prefer placing nonmember functions in a namespace; use completely global
                            functions rarely.
                        </span>
                        メンバではない関数はいずれかの名前空間内におきましょう。完全なグローバル関数は滅多に使ってはいけません。
                    </span>
                    <span>
                        <span class="src">
                            Prefer grouping functions with a namespace instead of
                            using a class as if it were a namespace.
                        </span>
                        グローバル関数をグループ化するときは、クラスではなく名前空間を使いましょう。
                    </span>
                    <span>
                        <span class="src">
                            Static methods of a class should
                            generally be closely related to instances of the class or the class's static
                            data.
                        </span>
                        静的メンバ関数は、そのクラスのインスタンスや静的メンバ変数と関連性が強い場合にのみ用います。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <div class="pros">
                    <p>
                        <span>
                            <span class="src">
                                Nonmember and static member functions can be useful in
                                some situations.
                            </span>
                            静的メンバ関数や、メンバではない通常の関数は、いくつかのシチュエーションで有用です。
                        </span>
                        <span>
                            <span class="src">
                                Putting nonmember functions in a
                                namespace avoids polluting the global namespace.
                            </span>
                            通常の関数はいずれかの名前空間内に置くことで、グローバル名前空間の汚染を避けられます。
                        </span>
                    </p>
                </div>

                <div class="cons">
                    <p>
                        <span>
                            <span class="src">
                                Nonmember and static member functions may make more sense
                                as members of a new class, especially if they access
                                external resources or have significant dependencies.
                            </span>
                            通常の関数や、静的メンバ関数は、それらが外部のリソースにアクセスしたり強く依存したりしているときに、クラスのメンバとするよりも理にかなっている場合があります。
                        </span>
                    </p>
                </div>

                <div class="decision">
                    <p>
                        <span>
                            <span class="src">
                                Sometimes it is useful to define a
                                function not bound to a class instance.
                            </span>
                            場合により、関数はクラスインスタンスに紐付けない方が便利なことがあります。
                        </span>
                        <span>
                            <span class="src">
                                Such a function
                                can be either a static member or a nonmember function.
                            </span>
                            このような関数は、静的メンバ関数やメンバではない通常の関数とすることができます。
                        </span>
                        <span>
                            <span class="src">
                                Nonmember functions should not depend on external
                                variables, and should nearly always exist in a namespace.
                            </span>
                            メンバでない関数は、外部の変数に依存してはいけません。
                            また、常に近しい名前空間の中に存在していなければなりません。
                        </span>
                        <span>
                            <span class="src">
                                Rather than creating classes only to group static member
                                functions which do not share static data, use
                                <a href="#Namespaces">namespaces</a> instead.
                                静的な変数を共有しない、通常の関数をまとめるだけのクラスを作るのではなく、<a href="#Namespaces">名前空間</a>を使います。
                            </span>
                        </span>
                        <span>
                            <span class="src">
                                For a header
                                <code>myproject/foo_bar.h</code>, for example, write
                            </span>
                            例として、<code>myproject/foo_bar.h</code>は以下のように記述します。
                        </span>
                    </p>
<pre>namespace myproject {
namespace foo_bar {
void Function1();
void Function2();
}  // namespace foo_bar
}  // namespace myproject
</pre>
                    <p>
                        <span>
                            <span class="src">instead of</span>
                            悪い例:
                        </span>
                    </p>
<pre class="badcode">namespace myproject {
class FooBar {
 public:
  static void Function1();
  static void Function2();
};
}  // namespace myproject
</pre>
                    <p>
                        <span>
                            <span class="src">
                                If you define a nonmember function and it is only
                                needed in its <code>.cc</code> file, use
                                <a href="#Unnamed_Namespaces_and_Static_Variables">internal linkage</a> to limit
                                its scope.
                            </span>
                            通常の関数が特定の<code>.cc</code>ファイルでのみ使用される場合、<a href="#Unnamed_Namespaces_and_Static_Variables">内部リンケージ</a>を用いることで、スコープを制限することができます。
                        </span>
                    </p>
                </div>

            </div>

            <h3 id="Local_Variables">
                <span title="Local Variables">ローカル変数</span>
            </h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Place a function's variables in the narrowest scope
                            possible, and initialize variables in the declaration.
                        </span>
                        関数内の変数は、可能な限りそのスコープを狭めるようにしてください。また、関数内の変数は、宣言と同時に初期化してください。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <p>
                    <span>
                        <span class="src">
                            C++ allows you to declare variables anywhere in a
                            function.
                        </span>
                        C++では、関数のどこでも変数を宣言することができます。
                    </span>
                    <span>
                        <span class="src">
                            We encourage you to declare them in as local a
                            scope as possible, and as close to the first use as
                            possible.
                        </span>
                        我々は、変数のスコープをできる限り局所的にし、できる限り初めて使用する場所の近くで宣言することをおすすめしています。
                    </span>
                    <span>
                        <span class="src">
                            This makes it easier for the reader to find the
                            declaration and see what type the variable is and what it
                            was initialized to.
                        </span>
                        そうすることによって、コードの読者が、変数の宣言がどこにあるか、型は何か、どのように初期化されたかを、見つけやすくすることができます。
                    </span>
                    <span>
                        <span class="src">
                            In particular, initialization should
                            be used instead of declaration and assignment, e.g.:
                        </span>
                        特に、変数の初期化は宣言と同時に行うようにし、宣言と代入を別に行うようなことは避けてください。例:
                    </span>
                </p>
                <span>
                    <span class="src">
<pre class="badcode">int i;
i = f();      // Bad -- initialization separate from declaration.
</pre>
                    </span>
                    <pre class="badcode">int i;
i = f();      // 悪い例。初期化が宣言と分かれている。
</pre>
                </span>
                <span>
                    <span class="src">
<pre>int j = g();  // Good -- declaration has initialization.
</pre>
                    </span>
                    <pre>int j = g();  // よい例。宣言と同時に初期化が行われている。
</pre>
                </span>
                <span>
                    <span class="src">
<pre class="badcode">std::vector&lt;int&gt; v;
v.push_back(1);  // Prefer initializing using brace initialization.
v.push_back(2);
</pre>
                    </span>
                    <pre class="badcode">std::vector&lt;int&gt; v;
v.push_back(1);  // {}による初期化を使う方がよい。
v.push_back(2);
</pre>
                </span>
                <span>
                    <span class="src">
<pre>std::vector&lt;int&gt; v = {1, 2};  // Good -- v starts initialized.
</pre>
                    </span>
                    <pre>std::vector&lt;int&gt; v = {1, 2};  // よい例。 vは初期化されている。
</pre>
                </span>

                <p>
                    <span>
                        <span class="src">
                            Variables needed for <code>if</code>, <code>while</code>
                            and <code>for</code> statements should normally be declared
                            within those statements, so that such variables are confined
                            to those scopes.  E.g.:
                        </span>

                        <code>if</code>文や<code>while</code>文、<code>for</code>文で使用される変数は、通常は、それらの文の中で宣言します。そうすることで、変数のスコープを制限することができます。例：
                    </span>
                </p>
<pre>while (const char* p = strchr(str, '/')) str = p + 1;
</pre>
                <p>
                    <span>
                        <span class="src">
                            There is one caveat: if the variable is an object, its
                            constructor is invoked every time it enters scope and is
                            created, and its destructor is invoked every time it goes
                            out of scope.
                        </span>
                        ただし、もし変数がオブジェクトだったとすると、スコープに入るたびに毎回コンストラクタが呼ばれ、オブジェクトが生成され、スコープから出るたびに毎回デストラクタが呼ばれることになります。
                    </span>
                </p>
                <span>
                    <span class="src">
<pre class="badcode">// Inefficient implementation:
for (int i = 0; i &lt; 1000000; ++i) {
  Foo f;  // My ctor and dtor get called 1000000 times each.
  f.DoSomething(i);
}
</pre>
                    </span>
                    <pre class="badcode">// 非効率的な実装
for (int i = 0; i &lt; 1000000; ++i) {
  Foo f;  // コンストラクタとデストラクタがそれぞれ 1000000 回ずつ呼ばれる。
  f.DoSomething(i);
}
</pre>
                </span>

                <p>
                    <span>
                        <span class="src">
                            It may be more efficient to declare such a variable
                            used in a loop outside that loop:
                        </span>
                        こういった場合、変数はループの外で宣言する方が効率的になる場合があります。
                    </span>
                </p>
                <span>
                    <span class="src">
<pre>Foo f;  // My ctor and dtor get called once each.
for (int i = 0; i &lt; 1000000; ++i) {
  f.DoSomething(i);
}
</pre>
                    </span>
                    <pre>Foo f;  // コンストラクタとデストラクタは1回ずつ呼ばれる。
for (int i = 0; i &lt; 1000000; ++i) {
  f.DoSomething(i);
}
</pre>
                </span>
            </div>

            <h3 id="Static_and_Global_Variables">
                <span title="Static and Global Variables">静的変数とグローバル変数</span>
            </h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Variables of class type with <a href="http://en.cppreference.com/w/cpp/language/storage_duration#Storage_duration">
                                static storage duration
                            </a> are forbidden: they cause hard-to-find bugs due
                            to indeterminate order of construction and destruction.
                        </span>
                        <a href="http://en.cppreference.com/w/cpp/language/storage_duration#Storage_duration">静的記憶域期間(static storage duration)</a>を持ったクラス型の変数は禁止です。これらの変数は不定な順番で生成(construct)・破壊(destruct)されるため、発見が困難な不具合を引き起こすことにつながります。
                    </span>
                    <span>
                        <span class="src">
                            However, such
                            variables are allowed if they are <code>constexpr</code>: they have no
                            dynamic initialization or destruction.
                        </span>
                        ただし、そのような変数でも<code>constexpr</code>と共に定義される場合は使用が認められます。これらは動的な初期化や破壊が行われないため問題になりません。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <p>
                    <span>
                        <span class="src">
                            Objects with static storage duration, including global
                            variables, static variables, static class member
                            variables, and function static variables, must be Plain
                            Old Data (POD): only ints, chars, floats, or pointers, or
                            arrays/structs of POD.
                        </span>
                        静的な生存時間を持つオブジェクト(グローバル変数や静的変数、静的クラスメンバ変数、関数内静的変数を含む)は、必ずPlain Old Data(POD)でなくてはなりません。PODとは、組み込みの整数型(int,char,...)、浮動小数点型(float,double,...)、ポインタ、PODの配列、PODだけで構成された構造体のことです。
                    </span>
                </p>

                <p>
                    <span>
                        <span class="src">
                            The order in which class constructors and initializers
                            for static variables are called is only partially
                            specified in C++ and can even change from build to build,
                            which can cause bugs that are difficult to find.
                        </span>
                        C++において、静的変数のコンストラクタや初期化子の呼び出し順序は、部分的にしか決められておらず、ビルドのたびに変わる可能性すらあり、これらは非常に見つけづらいバグの元となります。
                    </span>
                    <span>
                        <span class="src">
                            Therefore in addition to banning globals of class type,
                            we do not allow non-local static variables to be initialized
                            with the result of a function, unless that function (such
                            as getenv(), or getpid()) does not itself depend on any
                            other globals.
                        </span>
                        このため、クラス型のグローバル変数に加え、(呼び出す関数が他のグローバルに依存していない場合を除いて)関数の結果によって初期化されるローカルでない静的変数も許容できません。
                    </span>
                    <span>
                        <span class="src">
                            However, a static POD variable within
                            function scope may be initialized with the result of a
                            function, since its initialization order is well-defined
                            and does not occur until control passes through its
                            declaration.
                        </span>
                        一方で、関数スコープの静的POD変数は、その初期化順序は十分に定義され、かつ、その宣言を初めて通過するまで初期化されないため、関数の結果で初期化されても問題ありません。
                    </span>
                </p>

                <p>
                    <span>
                        <span class="src">
                            Likewise, global and static variables are destroyed
                            when the program terminates, regardless of whether the
                            termination is by returning from <code>main()</code> or
                            by calling <code>exit()</code>.
                        </span>
                        ここまでの初期化の話と同様に、グローバル変数や静的変数は、(<code>main()</code>の処理が終わったか<code>exit()</code>の呼び出しであるかに関わらず)プログラムの終了時に破壊されます。
                    </span>
                    <span>
                        <span class="src">
                            The order in which
                            destructors are called is defined to be the reverse of
                            the order in which the constructors were called.
                        </span>
                        このときのデストラクタが呼ばれる順序は、コンストラクタが呼ばれた順の逆順と定義されていますが、
                    </span>
                    <span>
                        <span class="src">
                            Since
                            constructor order is indeterminate, so is destructor
                            order.
                        </span>
                        そもそも、コンストラクタの呼び出し順序は決まっていないため、デストラクタの呼び出し順序も決まっていません。
                    </span>
                    <span>
                        <span class="src">
                            For example, at program-end time a static variable
                            might have been destroyed, but code still running
                            &#8212; perhaps in another thread
                            &#8212; tries to access it and fails.
                        </span>
                        たとえば、プログラム終了処理時には静的変数は破壊されますが、まだ実行中のコード(おそらく別スレッド)がその変数にアクセスしようとして失敗するかもしれません。
                    </span>
                    <span>
                        <span class="src">
                            Or the
                            destructor for a static <code>string</code> variable
                            might be run prior to the destructor for another variable
                            that contains a reference to that string.
                        </span>
                        あるいは、静的な<code>string</code>のデストラクタが、その文字列への参照を持つ別の変数のデストラクタよりも先に実行されてしまうかもしれません。
                    </span>
                </p>

                <p>
                    <span>
                        <span class="src">
                            One way to alleviate the destructor problem is to
                            terminate the program by calling
                            <code>quick_exit()</code> instead of <code>exit()</code>.
                        </span>
                        このデストラクタ問題を軽減する1つの方法は、プログラムを終了するために<code>exit()</code>ではなく<code>quick_exit()</code>を呼び出すことです。
                    </span>
                    <span>
                        <span class="src">
                            The difference is that <code>quick_exit()</code> does not
                            invoke destructors and does not invoke any handlers that
                            were registered by calling <code>atexit()</code>.
                        </span>
                        <code>quick_exit()</code>は、<code>exit()</code>と違って、変数のデストラクタを呼び出さず、<code>atexit()</code>で事前に登録されたハンドラも呼び出しません。
                    </span>
                    <span>
                        <span class="src">
                            If you
                            have a handler that needs to run when a program
                            terminates via <code>quick_exit()</code> (flushing logs,
                            for example), you can register it using
                            <code>at_quick_exit()</code>.
                        </span>
                        たとえばログのflushなど、<code>quick_exit()</code>でプログラムを終了する場合に実行しないといけないことがある場合は<code>at_quick_exit()</code>で、ハンドラを登録することができます。
                    </span>
                    <span>
                        <span class="src">
                            (If you have a handler that
                            needs to run at both <code>exit()</code> and
                            <code>quick_exit()</code>, you need to register it in
                            both places.)
                        </span>
                        (<code>exit()</code>と<code>quick_exit()</code>のどちらが呼び出されてもハンドラを実行したい場合は、両方に登録しておく必要があります。)
                    </span>
                </p>

                <p>
                    <span>
                        <span class="src">
                            As a result we only allow static variables to contain
                            POD data.
                        </span>
                        結果的には、静的変数に格納できるものはPODだけです。
                    </span>
                    <span>
                        <span class="src">
                            This rule completely disallows
                            <code>std::vector</code> (use C arrays instead), or
                            <code>string</code> (use <code>const char []</code>).
                        </span>
                        このルールは、静的な<code>std::vector</code>や<code>string</code>を認めないことを意味します。
                        これらの代わりに、Cの配列や、<code>const char[]</code>を使うようにしてください。
                    </span>
                </p>



                <p>
                    <span>
                        <span class="src">
                            If you need a static or global
                            variable of a class type, consider initializing a pointer
                            (which will never be freed), from either your main()
                            function or from pthread_once().
                        </span>
                        もし、クラス型の静的変数やグローバル変数がほしくなった場合は、変数をポインタとして用意し、<code>main()</code>や<code>pthread_once()</code>の処理の中などで初期化する方法を検討してください(ポインタの解放処理はどこにも書きません)
                        。
                    </span>
                    <span>
                        <span class="src">
                            Note that this must be a
                            raw pointer, not a "smart" pointer, since the smart
                            pointer's destructor will have the order-of-destructor
                            issue that we are trying to avoid.
                        </span>
                        このとき宣言するポインタは生のポインタとし、スマートポインタ等を使用してはいけません。
                        スマートポインタのデストラクタは、ここまで回避しようとしてきたデストラクタ呼び出し順序の問題を再燃させてしまいます。
                    </span>
                </p>





            </div>

            <h2 id="Classes">
                <span title="Classes">クラス</span>
            </h2>

            <p>
                <span>
                    <span class="src">
                        Classes are the fundamental unit of code in C++.
                    </span>
                    クラスはC++におけるコードの基本単位です。
                </span>
                <span>
                    <span class="src">
                        Naturally, we use them extensively.
                    </span>
                    もちろん、我々は、それらを広く使っています。
                </span>
                <span>
                    <span class="src">
                        This section lists the main dos and
                        don'ts you should follow when writing a class.
                    </span>
                    このセクションでは、クラスを書くときに、すべきこと、すべきでないことについて述べます。
                </span>
            </p>

            <h3 id="Doing_Work_in_Constructors">
                <span title="Doing Work in Constructors">コンストラクタで行うこと</span>
            </h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Avoid virtual method calls in constructors, and avoid
                            initialization that can fail if you can't signal an error.
                        </span>
                        コンストラクタで仮想メンバ関数を呼ぶのはやめましょう。エラーを伝える手段がない場合、失敗するかもしれない初期化処理を行うのはやめましょう。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        <span>
                            <span class="src">
                                It is possible to perform arbitrary initialization in the body
                                of the constructor.
                            </span>
                            コンストラクタでは任意の初期化処理を行うことができます。
                        </span>
                    </p>
                </div>

                <div class="pros">
                    <ul>
                        <li>
                            <span>
                                <span class="src">
                                    No need to worry about whether the class has been initialized or
                                    not.
                                </span>
                                クラスが初期化済みであるかどうか、気にかけなくてよくなります。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Objects that are fully initialized by constructor call can
                                    be <code>const</code> and may also be easier to use with standard containers
                                    or algorithms.
                                </span>
                                コンストラクタで完全に初期化されるオブジェクトは、<code>const</code>にしやすく、標準コンテナや標準アルゴリズムで扱いやすくなります。
                            </span>
                        </li>
                    </ul>

                </div>

                <div class="cons">
                    <ul>
                        <li>
                            <span>
                                <span class="src">
                                    If the work calls virtual functions, these calls
                                    will not get dispatched to the subclass
                                    implementations.
                                </span>
                                コンストラクタで仮想関数が呼び出されたとしても、それらは派生クラスの実装を呼び出しません。
                            </span>
                            <span>
                                <span class="src">
                                    Future modification to your class can
                                    quietly introduce this problem even if your class is
                                    not currently subclassed, causing much confusion.
                                </span>
                                現時点で派生クラスがなくとも、将来的にクラスが変更された場合に、地味にこの問題を引き起こし、混乱を招くかもしれません。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    There is no easy way for constructors to signal errors, short of
                                    crashing the program (not always appropriate) or using exceptions
                                    (which are <a href="#Exceptions">forbidden</a>).
                                </span>
                                コンストラクタには、簡単にエラーを伝える方法がありません。せいぜい、プログラムをクラッシュさせる(常にそれが適切とは限らない)方法や、例外を使う(ルール上<a href="#Exceptions">禁止</a>)方法くらいです。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    If the work fails, we now have an object whose initialization
                                    code failed, so it may be an unusual state requiring a <code>
                                        bool
                                        IsValid()
                                    </code> state checking mechanism (or similar) which is easy
                                    to forget to call.
                                </span>
                                コンストラクタの処理が失敗した場合、初期化に失敗したオブジェクトができてしまいます。<code>bool IsValid()</code>のような状態をチェックする仕組みを用意しても、その呼び出しは簡単に忘れられてしまいます。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    You cannot take the address of a constructor, so whatever work
                                    is done in the constructor cannot easily be handed off to, for
                                    example, another thread.
                                </span>
                                コンストラクタのアドレスを得ることはできません。このため、コンストラクタで行われる処理の内容を他のスレッドに渡したりするようなことは、簡単にはできません。
                            </span>
                        </li>
                    </ul>
                </div>


                <div class="decision">
                    <p>
                        <span>
                            <span class="src">
                                Constructors should never call virtual functions.
                            </span>
                            コンストラクタでは仮想関数を呼び出してはいけません。
                        </span>
                        <span>
                            <span class="src">
                                If appropriate
                                for your code
                                ,
                                terminating the program may be an appropriate error handling
                                response.
                            </span>
                            それが適切と考えるのであれば、プログラムを強制終了するのもエラー処理の1つのやり方です。
                        </span>
                        <span>
                            <span class="src">
                                Otherwise, consider a factory function
                                or <code>Init()</code> method.
                            </span>
                            さもなくば、ファクトリ関数や<code>Init()</code>メソッドの導入を検討しましょう。
                        </span>
                        <span>
                            <span class="src">
                                Avoid <code>Init()</code> methods on objects with
                                no other states that affect which public methods may be called
                                (semi-constructed objects of this form are particularly hard to work
                                with correctly).
                            </span>
                            どのpublicメソッドが呼びだされてもよいかという他の状態を持たないオブジェクトの<code>Init()</code>メソッドは避けてください(特に、中途半端に生成されたオブジェクトを正しく動作させるのは困難です)。
                        </span>
                    </p>
                </div>

            </div>

            <a id="Explicit_Constructors"></a>
            <h3 id="Implicit_Conversions">
                <span title="Implicit Conversions">暗黙的型変換</span>
            </h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Do not define implicit conversions.
                        </span>
                        暗黙的型変換を新たに定義してはいけません。
                    </span>
                    <span>
                        <span class="src">
                            Use the <code>explicit</code>
                            keyword for conversion operators and single-argument
                            constructors.
                        </span>
                        型変換演算子や、1つの引数をとるコンストラクタにおいては<code>explicit</code>キーワードを使用してください。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        <span>
                            <span class="src">
                                Implicit conversions allow an
                                object of one type (called the <dfn>source type</dfn>) to
                                be used where a different type (called the <dfn>
                                    destination
                                    type
                                </dfn>) is expected, such as when passing an
                                <code>int</code> argument to a function that takes a
                                <code>double</code> parameter.
                            </span>
                            暗黙的型変換によって、ある型のオブジェクトを異なる型のオブジェクトとして扱えるようになります。たとえば、<code>double</code>型の仮引数をとる関数に<code>int</code>型の値を渡せます。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                In addition to the implicit conversions defined by the language,
                                users can define their own, by adding appropriate members to the
                                class definition of the source or destination type.
                            </span>
                            言語で元々定義されている暗黙的型変換に加えて、変換元の型か変換先の型のクラス定義に適切なメンバを加えることで、新たに暗黙的型変換を定義することができます。
                        </span>
                        <span>
                            <span class="src">
                                An implicit
                                conversion in the source type is defined by a type conversion operator
                                named after the destination type (e.g. <code>
                                    operator
                                    bool()
                                </code>).
                            </span>
                            変換元の型における暗黙的型変換は、変換先型の名前をつけた型変換演算子によって定義されます(例:<code>operator bool()</code>)。
                        </span>
                        <span>
                            <span class="src">
                                An implicit conversion in the destination
                                type is defined by a constructor that can take the source type as
                                its only argument (or only argument with no default value).
                            </span>
                            変換先の型における暗黙的型変換は、変換元の型の引数を1つだけとる(またはデフォルト値のない引数を1つだけとる)コンストラクタによって定義されます。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                The <code>explicit</code> keyword can be applied to a constructor
                                or (since C++11) a conversion operator, to ensure that it can only be
                                used when the destination type is explicit at the point of use,
                                e.g. with a cast.
                            </span>
                            <code>explicit</code>キーワードは、コンストラクタや(C++11では)型変換演算子につけることができます。これによって、型変換を、変換先の型が明示された場合にのみ行うよう限定することができます。
                        </span>
                        <span>
                            <span class="src">
                                This applies not only to implicit conversions, but to
                                C++11's list initialization syntax:
                            </span>
                            これは、暗黙的型変換だけではなく、以下に示すようなC++11のリスト初期化構文にも適用されます。
                        </span>
                    </p>
<pre>class Foo {
  explicit Foo(int x, double y);
  ...
};

void Func(Foo f);
</pre>
<pre class="badcode">Func({42, 3.14});  // Error
</pre>
                    <span>
                        <span class="src">
                            This kind of code isn't technically an implicit conversion, but the
                            language treats it as one as far as <code>explicit</code> is concerned.
                        </span>
                        このようなコードは何らテクニカルな暗黙的型変換はしていませんが、言語上<code>explicit</code>に関連していると見なして扱われます。
                    </span>
                </div>

                <div class="pros">
                    <ul>
                        <li>
                            <span>
                                <span class="src">
                                    Implicit conversions can make a type more usable and
                                    expressive by eliminating the need to explicitly name a type
                                    when it's obvious.
                                </span>
                                暗黙的型変換は、型の利便性を高め、型が明確であるときには型の名前を省略可能であるため表現上も優れています。
                            </span>
                        </li>
                        <li>
                            <span>
                                <span class="src">
                                    Implicit conversions can be a simpler alternative to
                                    overloading.
                                </span>
                                暗黙的型変換は単にオーバーロードの代替手段としても利用可能です。
                            </span>
                        </li>
                        <li>
                            <span>
                                <span class="src">
                                    List initialization syntax is a concise and expressive
                                    way of initializing objects.
                                </span>
                                リスト初期化子による構文は、簡潔で表現的に優れたオブジェクトの初期化方法です。
                            </span>
                        </li>
                    </ul>
                </div>

                <div class="cons">
                    <ul>
                        <li>
                            <span>
                                <span class="src">
                                    Implicit conversions can hide type-mismatch bugs, where the
                                    destination type does not match the user's expectation, or
                                    the user is unaware that any conversion will take place.
                                </span>
                                暗黙的型変換は、型の不一致によるバグを隠してしまうことがあります。たとえば、変換先の型がユーザの期待どおりにならなかったり、そもそもその場で型変換が行わることに気づかなかったりします。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Implicit conversions can make code harder to read, particularly
                                    in the presence of overloading, by making it less obvious what
                                    code is actually getting called.
                                </span>
                                暗黙的型変換は、コードの可読性を下げる場合があります。特に、関数にオーバーロードが存在する場合、どれが実際に呼び出されるのかをわかりにくくしてしまうことがあります。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Constructors that take a single argument may accidentally
                                    be usable as implicit type conversions, even if they are not
                                    intended to do so.
                                </span>
                                1つの引数をとるコンストラクタが、意図せず型変換のために呼び出されてしまうことがあります。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    When a single-argument constructor is not marked
                                    <code>explicit</code>, there's no reliable way to tell whether
                                    it's intended to define an implicit conversion, or the author
                                    simply forgot to mark it.
                                </span>
                                1つの引数をとるコンストラクタが<code>explicit</code>でマークされていなかったとき、それが意図した暗黙的型変換のために書かれているのか、単にコードの著者が<code>explicit</code>をつけるのを忘れてしまっただけなのか、信頼できる判断方法がありません。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    It's not always clear which type should provide the conversion,
                                    and if they both do, the code becomes ambiguous.
                                </span>
                                変換元の型と変換先の型との、どちらの型が型変換を提供すべきかが常に明確であるとは限りません。もし両方がも型変換機能を持っていた場合、コードが曖昧になってしまいます。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    List initialization can suffer from the same problems if
                                    the destination type is implicit, particularly if the
                                    list has only a single element.
                                </span>
                                リスト初期化子は、変換先の型が暗黙的型変換を持つとき同じ問題にぶつかります(特にリストに1要素しか持っていなかった場合)。
                            </span>
                        </li>
                    </ul>
                </div>

                <div class="decision">
                    <p>
                        <span>
                            <span class="src">
                                Type conversion operators, and constructors that are
                                callable with a single argument, must be marked
                                <code>explicit</code> in the class definition.
                            </span>
                            型変換演算子と1つの引数で呼び出せるコンストラクタは<code>explicit</code>でマークされていなくてはなりません。
                        </span>
                        <span>
                            <span class="src">
                                As an
                                exception, copy and move constructors should not be
                                <code>explicit</code>, since they do not perform type
                                conversion.
                            </span>
                            例外として、コピーコンストラクタとムーブコンストラクタは<code>explicit</code>でマークされているべきではありません。これらは型変換を行うものではないからです。
                        </span>
                        <span>
                            <span class="src">
                                Implicit conversions can sometimes be necessary and
                                appropriate for types that are designed to transparently wrap other
                                types.
                            </span>
                            また、ある型が他の型を透過的にラップするようデザインされている場合など、暗黙的型変換が必要かつ適切な時もあります。
                        </span>
                        <span>
                            <span class="src">
                                In that case, contact
                                your project leads to request
                                a waiver of this rule.
                            </span>
                            そのような場合においては、プロジェクトリーダーと相談し、このルールの適用から外してください。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Constructors that cannot be called with a single argument
                                should usually omit <code>explicit</code>.
                            </span>
                            通常、1つの引数では呼び出せないコンストラクタについては<code>explicit</code>を省略します。
                        </span>
                        <span>
                            <span class="src">
                                Constructors that
                                take a single <code>std::initializer_list</code> parameter should
                                also omit <code>explicit</code>, in order to support copy-initialization
                                (e.g. <code>MyType m = {1, 2};</code>).
                            </span>
                            また、1つの<code>std::initializer_list</code>型の引数をとるコンストラクタについも、コピーによる初期化(例: <code>MyType m = {1, 2};</code>)をサポートするために<code>explicit</code>を省略してください。
                        </span>
                    </p>
                </div>

            </div>

            <h3 id="Copyable_Movable_Types">
                <span title="Copyable and Movable Types">コピー可能な型・ムーブ可能な型</span>
            </h3>
            <a id="Copy_Constructors"></a>
            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Support copying and/or moving if these operations are clear and meaningful
                            for your type.
                        </span>
                        コピーやムーブは、それの実装が明確でかつ意味のある場合に限って実装してください。
                    </span>
                    <span>
                        <span class="src">
                            Otherwise, disable the implicitly generated special functions
                            that perform copies and moves.
                        </span>
                        それ以外の場合には、暗黙的に自動生成されるコピー・ムーブ関数は無効にしてください。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        <span>
                            <span class="src">
                                A copyable type allows its objects to be initialized or assigned
                                from any other object of the same type, without changing the value of the source.
                            </span>
                            型をコピー可能にすることによって、他の同じ型のオブジェクトから、元となるオブジェクトを変更することなく、自分自身の初期化や自分自身への代入ができるようになります。
                        </span>
                        <span>
                            <span class="src">
                                For user-defined types, the copy behavior is defined by the copy
                                constructor and the copy-assignment operator.
                            </span>
                            ユーザ定義の型においては、コピーの挙動は、コピーコンストラクタやコピー代入演算子によって定義されます。
                        </span>
                        <span>
                            <span class="src">
                                <code>string</code> is an example of a copyable type.
                            </span>
                            コピー可能な型の一例として<code>string</code>があります。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                A movable type is one that can be initialized and assigned
                                from temporaries (all copyable types are therefore movable).
                            </span>
                            ムーブ可能な型は、一時オブジェクトからの初期化または代入が可能な型です(ゆえに、コピー可能な型は常にムーブ可能な型です)。
                        </span>
                        <span>
                            <span class="src">
                                <code>std::unique_ptr&lt;int&gt;</code> is an example of a movable but not
                                copyable type.
                            </span>
                            ムーブは可能ですがコピーは不可能な型の一例として<code>std::unique_ptr&lt;int&gt;</code>があります。
                        </span>
                        <span>
                            <span class="src">
                                For user-defined types, the move behavior is defined by the move
                                constructor and the move-assignment operator.
                            </span>
                            ユーザ定義の型においては、ムーブの挙動は、ムーブコンストラクタやムーブ代入演算子によって定義されます。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                The copy/move constructors can be implicitly invoked by the compiler
                                in some situations, e.g. when passing objects by value.
                            </span>
                            コピーコンストラクタやムーブコンストラクタは、オブジェクトの値渡しなどの際、コンパイラによって暗黙的に呼び出されます。
                        </span>
                    </p>
                </div>

                <div class="pros">
                    <p>
                        <span>
                            <span class="src">
                                Objects of copyable and movable types can be passed and returned by value,
                                which makes APIs simpler, safer, and more general.
                            </span>
                            コピー可能・ムーブ可能なオブジェクトは、値渡し・値戻しができるため、APIがシンプルかつ安全で、より一般的な形になります。
                        </span>
                        <span>
                            <span class="src">
                                Unlike when passing objects
                                by pointer or reference, there's no risk of confusion over ownership,
                                lifetime, mutability, and similar issues, and no need to specify them in the
                                contract.
                            </span>
                            この場合は、オブジェクトのポインタ渡し・参照渡しと違って、オブジェクトの所有権や生存時間、ミュータビリティなどに関する危険がなく、それらに関する前提条件も必要なくなります。
                        </span>
                        <span>
                            <span class="src">
                                It also prevents non-local interactions between the client and the
                                implementation, which makes them easier to understand, maintain, and optimize by
                                the compiler.
                            </span>
                            また、呼び出し元と実装をつないでしまうような局所的でない相互作用も自動的に防がれます。これによって、理解しやすく、メンテナンスしやすく、コンパイラによって最適化が掛かりやすくなります。
                        </span>
                        <span>
                            <span class="src">
                                Further, such objects can be used with generic APIs that
                                require pass-by-value, such as most containers, and they allow for additional
                                flexibility in e.g., type composition.
                            </span>
                            さらに、このようなオブジェクトは、多くのコンテナ型のような値渡しを要求するAPIに利用することができる他、型の合成などにおいて柔軟な扱い方ができるようにもなります。
                        </span>
                    </p>
                    <p>
                        <span>
                            <span class="src">
                                Copy/move constructors and assignment operators are usually
                                easier to define correctly than alternatives
                                like <code>Clone()</code>, <code>CopyFrom()</code> or <code>Swap()</code>,
                                because they can be generated by the compiler, either implicitly or
                                with <code>= default</code>.
                            </span>
                            コピー・ムーブを行うコンストラクタや代入演算子は、一般に、<code>Clone()</code>, <code>CopyFrom()</code>あるいは<code>Swap()</code>といった代替的な方法に比べて、正しく定義することが容易です。なぜならば、これらのコンストラクタや代入演算子は暗黙的に、または明示的に<code>= default</code>と記載することで、コンパイラに生成させることができるためです。
                        </span>
                        <span>
                            <span class="src">
                                They are concise, and ensure
                                that all data members are copied.
                            </span>
                            自動的に生成されるコンストラクタや代入演算子は、明瞭で、かつすべてのメンバーがコピーされることが保証されます。
                        </span>
                        <span>
                            <span class="src">
                                Copy and move
                                constructors are also generally more efficient, because they don't
                                require heap allocation or separate initialization and assignment
                                steps, and they're eligible for optimizations such as

                                <a href="http://en.cppreference.com/w/cpp/language/copy_elision">
                                    copy elision
                                </a>.
                            </span>
                            また、コピーコンストラクタやムーブコンストラクタは一般的に、より効率的に動作します。なぜならば、これらはヒープメモリは確保せず、初期化と割り当てをまとめて行い、<a href="http://en.cppreference.com/w/cpp/language/copy_elision">copy elision</a>のような適切な最適化が行われるためです。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Move operations allow the implicit and efficient transfer of
                                resources out of rvalue objects.
                            </span>
                            ムーブ操作によって、右辺値オブジェクトから暗黙的かつ効率的にリソースを取り出すことが可能になります。
                        </span>
                        <span>
                            <span class="src">
                                This allows a plainer coding style
                                in some cases.
                            </span>
                            これによって、よりわかりやすいコーディングスタイルを採用できる場合があります。
                        </span>
                    </p>
                </div>

                <div class="cons">
                    <p>
                        <span>
                            <span class="src">
                                Some types do not need to be copyable, and providing copy
                                operations for such types can be confusing, nonsensical, or outright
                                incorrect.
                            </span>
                            型によってはコピーができることを必要としない場合や、コピー操作を提供しようとすること自体が理屈的におかしい場合もあります。
                        </span>
                        <span>
                            <span class="src">
                                Types representing singleton objects (<code>Registerer</code>),
                                objects tied to a specific scope (<code>Cleanup</code>), or closely coupled to
                                object identity (<code>Mutex</code>) cannot be copied meaningfully.
                            </span>
                            たとえば、(<code>Registerer</code>のような)シングルトンのオブジェクトや、(<code>Cleanup</code>のような)そのスコープに紐付くオブジェクト、あるいは(<code>Mutex</code>のような)個別のオブジェクトと密接に繋がっているようなオブジェクトは、意味のあるコピーはできません。
                        </span>
                    </p>
                    <p>
                        <span>
                            <span class="src">
                                Copy operations for base class types that are to be used
                                polymorphically are hazardous, because use of them can lead to
                                <a href="https://en.wikipedia.org/wiki/Object_slicing">object slicing</a>.
                            </span>
                            ポリモーフィズムを使用しているような型の基底クラスに対するコピー操作は、<a href="https://en.wikipedia.org/wiki/Object_slicing">オブジェクトのスライシング</a>を引き起こす可能性があり危険です。
                        </span>
                        <span>
                            <span class="src">
                                Defaulted or carelessly-implemented copy operations can be incorrect, and the
                                resulting bugs can be confusing and difficult to diagnose.
                            </span>
                            デフォルト実装や雑に実装されたコピー操作は誤ったものとなり、結果的に困惑的な診断の難しいバグを招くことがあります。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Copy constructors are invoked implicitly, which makes the
                                invocation easy to miss.
                            </span>
                            コピーコンストラクタは暗黙的に呼び出されるため、呼び出しを見落としやすいです。
                        </span>
                        <span>
                            <span class="src">
                                This may cause confusion for programmers used to
                                languages where pass-by-reference is conventional or mandatory.
                            </span>
                            これは、参照渡しが慣習的なプログラミング言語に馴染んだプログラマにとっての混乱ポイントになるでしょう。
                        </span>
                        <span>
                            <span class="src">
                                It may also
                                encourage excessive copying, which can cause performance problems.
                            </span>
                            また、余計なコピーを助長し、パフォーマンス上の問題になることもあります。
                        </span>
                    </p>
                </div>

                <div class="decision">

                    <p>
                        <span>
                            <span class="src">
                                Provide the copy and move operations if their meaning is clear to a casual
                                user and the copying/moving does not incur unexpected costs.
                            </span>
                            カジュアルなユーザから見て、操作の意味が明確で、かつコストも十分想定できる場合、コピー操作やムーブ操作が可能なようにしてください。
                        </span>
                        <span>
                            <span class="src">
                                If you define a
                                copy or move constructor, define the corresponding assignment operator, and
                                vice-versa.
                            </span>
                            コピーコンストラクタやムーブコンストラクタを独自に定義する場合は、それに紐付く代入演算子も併せて実装してください(逆の場合も同様です)。
                        </span>
                        <span>
                            <span class="src">
                                If your type is copyable, do not define move operations unless they
                                are significantly more efficient than the corresponding copy operations.
                            </span>
                            型がコピー可能な場合は、コピーに比べて非常に効率的にムーブできる場合を除いて、ムーブ操作を定義しないでください。
                        </span>
                        <span>
                            <span class="src">
                                If your
                                type is not copyable, but the correctness of a move is obvious to users of the
                                type, you may make the type move-only by defining both of the move operations.
                            </span>
                            また、コピー可能ではないが、ムーブ操作の正当性が明らかなときは、それぞれのムーブ操作を定義することで、ムーブのみ可能な型とすることもできます。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                If your type provides copy operations, it is recommended that you design
                                your class so that the default implementation of those operations is correct.
                            </span>
                            型がコピー操作をサポートする場合、できるだけコンパイラによるデフォルト実装が正しい操作となるようにクラスをデザインしてください。
                        </span>
                        <span>
                            <span class="src">
                                Remember to review the correctness of any defaulted operations as you would any
                                other code, and to document that your class is copyable and/or cheaply movable
                                if that's an API guarantee.
                            </span>
                            また、他のコードと同様に、デフォルトで生成されるコピー操作の正当性についても、忘れずにレビューを行ってください。
                            また、クラスがコピー可能である、もしくは、ムーブのみ可能であることを忘れずにドキュメント化してください。
                        </span>
                    </p>
                    <span>
                        <span class="src">
<pre class="badcode">class Foo {
 public:
  Foo(Foo&amp;&amp; other) : field_(other.field) {}
  // Bad, defines only move constructor, but not operator=.

 private:
  Field field_;
};
</pre>
                        </span>
                        <pre class="badcode">class Foo {
 public:
  Foo(Foo&amp;&amp; other) : field_(other.field) {}
  // ダメ。ムーブコンストラクタだけが実装されていて、operator= がない。.

 private:
  Field field_;
};
</pre>
                    </span>

                    <p>
                        <span>
                            <span class="src">
                                Due to the risk of slicing, avoid providing an assignment
                                operator or public copy/move constructor for a class that's
                                intended to be derived from (and avoid deriving from a class
                                with such members).
                            </span>
                            スライシングのリスクがあるため、継承されることを目的としているクラスは、publicなコピー・ムーブコンストラクタ、コピー・ムーブ代入演算子を提供しないでください。また、それらの操作を提供しているクラスから派生することは避けてください。
                        </span>
                        <span>
                            <span class="src">
                                If your base class needs to be
                                copyable, provide a public virtual <code>Clone()</code>
                                method, and a protected copy constructor that derived classes
                                can use to implement it.
                            </span>
                            基底クラスをコピー可能としたい場合、public virtualな<code>Clone()</code>メソッドを提供するようにしてください。
                            また、protectedなコピーコンストラクタを提供し、派生クラスのコピーの実装がそれを利用できるようにしておいてください。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                If you do not want to support copy/move operations on your type,
                                explicitly disable them using <code>= delete</code> in
                                the <code>public:</code> section:
                            </span>
                            型にコピー操作・ムーブ操作をサポートさせたくないときは、以下の例のように、<code>public:</code>セクション内において<code>= delete</code>を使って、明示的にそれらを無効にしてください。
                        </span>
                    </p>
                    <span>
                        <span class="src">
<pre class="code">// MyClass is neither copyable nor movable.
MyClass(const MyClass&amp;) = delete;
MyClass&amp; operator=(const MyClass&amp;) = delete;
</pre>
                        </span><pre class="code">// MyClassは、コピーもムーブも不可
MyClass(const MyClass&amp;) = delete;
MyClass&amp; operator=(const MyClass&amp;) = delete;
</pre>
                    </span>

                    <p></p>

                </div>
            </div>

            <h3 id="Structs_vs._Classes">
                <span title="Structs vs. Classes">構造体かクラスか</span>
            </h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Use a <code>struct</code> only for passive objects that
                            carry data; everything else is a <code>class</code>.
                        </span>
                        <code>struct</code>はデータを運ぶための受け身的なオブジェクトにのみ使用し、それ以外は<code>class</code>を使用してください。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <p>
                    <span>
                        <span class="src">
                            The <code>struct</code> and <code>class</code>
                            keywords behave almost identically in C++.
                        </span>
                        <code>struct</code>と<code>class</code>は、C++においてほとんど同じです。
                    </span>
                    <span>
                        <span class="src">
                            We add our own
                            semantic meanings to each keyword, so you should use the
                            appropriate keyword for the data-type you're
                            defining.
                        </span>
                        我々は、それぞれのキーワードに独自の意味づけをしています。そのため、定義されるデータの種類に応じて適切なキーワードを用いなくてはなりません。
                    </span>
                </p>

                <p>
                    <span>
                        <span class="src">
                            <code>structs</code> should be used for passive
                            objects that carry data, and may have associated
                            constants, but lack any functionality other than
                            access/setting the data members.
                        </span>
                        <code>struct</code>は、データを運ぶためだけの受け身的なオブジェクトに使います。<code>struct</code>は、関連する定数を持つことはできますが、それ以外はデータのGetterやSetterを除いて、何ら機能的なものを持ちません。
                    </span>
                    <span>
                        <span class="src">
                            The accessing/setting of
                            fields is done by directly accessing the fields rather
                            than through method invocations.
                        </span>
                        データの取得・設定は、メソッド呼び出しではなく、フィールドに直接アクセスして行います。
                    </span>
                    <span>
                        <span class="src">
                            Methods should not
                            provide behavior but should only be used to set up the
                            data members, e.g., constructor, destructor,
                            <code>Initialize()</code>, <code>Reset()</code>,
                            <code>Validate()</code>.
                        </span>
                        データメンバーを設定する以外のメソッドは持たせてはなりません。
                        たとえば、コンストラクタ、デストラクタ、<code>Initialize()</code>、<code>Reset()</code>、<code>Validate()</code>などです。
                    </span>
                </p>

                <p>
                    <span>
                        <span class="src">
                            If more functionality is required, a
                            <code>class</code> is more appropriate.
                        </span>
                        より機能的なものが要求される場合は、<code>class</code>の方が適切です。
                    </span>
                    <span>
                        <span class="src">
                            If in doubt, make
                            it a <code>class</code>.
                        </span>
                        迷ったら<code>class</code>にしましょう。
                    </span>
                </p>

                <p>
                    <span>
                        <span class="src">
                            For consistency with STL, you can use
                            <code>struct</code> instead of <code>class</code> for
                            functors and traits.
                        </span>
                        STLとの一貫性を持たせるため、ファンクタやtraitsについては、<code>struct</code>を使ってもかまいません。
                    </span>
                </p>

                <p>
                    <span>
                        <span class="src">
                            Note that member variables in structs and classes have
                            <a href="#Variable_Names">different naming rules</a>.
                        </span>
                        構造体とクラスでは、<a href="#Variable_Names">命名規則が異なる</a>ことに注意してください。
                    </span>
                </p>

            </div>

            <h3 id="Inheritance">
                <span title="Inheritance">継承</span>
            </h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Composition is often more appropriate than inheritance.
                        </span>
                        しばしば、継承より抱合(コンポジション)の方が適切な場合もあります。
                    </span>
                    <span>
                        <span class="src">
                            When using inheritance, make it <code>public</code>.
                        </span>
                        継承を使うのであれば、必ず<code>public</code>にします。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        <span>
                            <span class="src">
                                When a sub-class
                                inherits from a base class, it includes the definitions
                                of all the data and operations that the parent base class
                                defines.
                            </span>
                            派生クラスが基底クラスから継承するとき、派生クラスは親となる基底クラスで定義されているすべてのデータと操作の定義を含むようになります。
                        </span>
                        <span>
                            <span class="src">
                                In practice, inheritance is used in two major
                                ways in C++: implementation inheritance, in which actual
                                code is inherited by the child, and
                                <a href="#Interfaces">interface inheritance</a>, in which
                                only method names are inherited.
                            </span>
                            実際には、C++の継承は2種類の方法があります。実際のコードが継承される「実装の継承」と、メソッド名だけが継承される「<a href="#Interfaces">インターフェースの継承</a>」です。
                        </span>
                    </p>
                </div>

                <div class="pros">
                    <p>
                        <span>
                            <span class="src">
                                Implementation inheritance reduces code size by re-using
                                the base class code as it specializes an existing type.
                            </span>
                            実装の継承は、基底クラスのコードを再利用するため、コードのサイズが小さくなります。
                        </span>
                        <span>
                            <span class="src">
                                Because inheritance is a compile-time declaration, you
                                and the compiler can understand the operation and detect
                                errors.
                            </span>
                            継承はコンパイル時の宣言であるため、コンパイラは操作を理解し、エラーを検出します。
                        </span>
                        <span>
                            <span class="src">
                                Interface inheritance can be used to
                                programmatically enforce that a class expose a particular
                                API.
                            </span>
                            インターフェースの継承は、プログラム的に、クラスが特定のAPIを公開することを強制するために使用します。
                        </span>
                        <span>
                            <span class="src">
                                Again, the compiler can detect errors, in this case,
                                when a class does not define a necessary method of the
                                API.
                            </span>
                            同様に、コンパイラは、クラスが必要なメソッドを定義していない場合に、それをエラーとして検出します。
                        </span>
                    </p>
                </div>

                <div class="cons">
                    <p>
                        <span>
                            <span class="src">
                                For implementation inheritance, because the code
                                implementing a sub-class is spread between the base and
                                the sub-class, it can be more difficult to understand an
                                implementation.
                            </span>
                            実装の継承においては、派生クラスの実装が基底クラスと派生クラスとの間に分離するため、実装を理解するのをより難しくするかもしれません。
                        </span>
                        <span>
                            <span class="src">
                                The sub-class cannot override functions
                                that are not virtual, so the sub-class cannot change
                                implementation.
                            </span>
                            派生クラスは、基底クラスでvirtualとして宣言されていないものをオーバーライドすることはできず、実装を変えることはできません。
                        </span>
                        <span>
                            <span class="src">
                                The base class may also define some data
                                members, so that specifies physical layout of the base
                                class.
                            </span>
                            また、基底クラスはデータメンバを定義しているかもしれず、それによって基底クラスの物理的なレイアウトも決まってしまいます。
                        </span>
                    </p>
                </div>

                <div class="decision">

                    <p>
                        <span>
                            <span class="src">
                                All inheritance should be <code>public</code>.
                            </span>
                            すべての継承は<code>public</code>で行います。
                        </span>
                        <span>
                            <span class="src">
                                If you
                                want to do private inheritance, you should be including
                                an instance of the base class as a member instead.
                            </span>
                            privateな継承を行いたい場合は、継承の代わりに基底クラスのインスタンスをメンバーとして持つようにしてください。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Do not overuse implementation inheritance.
                            </span>
                            実装の継承を使いすぎないでください。
                        </span>
                        <span>
                            <span class="src">
                                Composition
                                is often more appropriate.
                            </span>
                            抱合(コンポジション)の方が適切な場合もしばしばあります。
                        </span>
                        <span>
                            <span class="src">
                                Try to restrict use of
                                inheritance to the "is-a" case: <code>Bar</code>
                                subclasses <code>Foo</code> if it can reasonably be said
                                that <code>Bar</code> "is a kind of"
                                <code>Foo</code>.
                            </span>
                            継承は is-a 関係が成立する場合のみ使うようにしてください。
                            たとえば<code>Foo</code>を継承して<code>Bar</code>を作ってよいのは、理屈の上で「<code>Bar</code>は<code>Foo</code>の一種」といえる時だけです。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Make your destructor <code>virtual</code> if
                                necessary.
                            </span>
                            必要に応じてデストラクタは<code>virtual</code>にしてください。
                        </span>
                        <span>
                            <span class="src">
                                If your class has virtual methods, its
                                destructor should be virtual.
                            </span>
                            もし、クラスが仮想関数を持っているのであれば、デストラクタも仮想でなくてはなりません。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Limit the use of <code>protected</code> to those
                                member functions that might need to be accessed from
                                subclasses.
                            </span>
                            <code>protected</code>は、派生クラスからアクセスされるメンバ関数だけにとどめてください。
                        </span>
                        <span>
                            <span class="src">
                                Note that <a href="#Access_Control">
                                    data
                                    members should be private
                                </a>.
                            </span>
                            <a href="#Access_Control">データメンバはprivateとする</a>ようにしてください.
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Explicitly annotate overrides of virtual functions
                                or virtual destructors with an <code>override</code>
                                or (less frequently) <code>final</code> specifier.
                            </span>
                            オーバーライドする仮想関数や仮想デストラクタには、明示的に<code>override</code>あるいは<code>final</code>指定子をつけてください。
                        </span>
                        <span>
                            <span class="src">
                                Older (pre-C++11) code will use the
                                <code>virtual</code> keyword as an inferior
                                alternative annotation.
                            </span>
                            古い(C++11より前の)コードでは、劣っていますが代替として<code>virtual</code>キーワードをつけてください。
                        </span>
                        <span>
                            <span class="src">
                                For clarity, use exactly one of
                                <code>override</code>, <code>final</code>, or
                                <code>virtual</code> when declaring an override.
                            </span>
                            明快さのため、オーバーライドするときには、必ず<code>override</code>か<code>final</code>か
                            <code>virtual</code>のいずれかのキーワードを使用してください。
                        </span>
                        <span>
                            <span class="src">
                                Rationale: A function or destructor marked
                                <code>override</code> or <code>final</code> that is
                                not an override of a base class virtual function will
                                not compile, and this helps catch common errors.
                            </span>
                            <code>override</code>か<code>final</code>でマークされた関数やデスクトラクタは、基底クラスの仮想関数をオーバーライドしていないときにコンパイルできなくなるため、問題に気づきやすくなります。
                        </span>
                        <span>
                            <span class="src">
                                The
                                specifiers serve as documentation; if no specifier is
                                present, the reader has to check all ancestors of the
                                class in question to determine if the function or
                                destructor is virtual or not.
                            </span>
                            これらの指定子はドキュメントの役割も果たします。もし、指定子がない場合、コードの読者は関数やデストラクタが仮想なのかそうでないのかを解決するためには、すべての継承元をたどって調べなくてはならなくなります。
                        </span>
                    </p>
                </div>

            </div>

            <h3 id="Multiple_Inheritance">
                <span title="Multiple Inheritance">多重継承</span>
            </h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Only very rarely is multiple implementation inheritance
                            actually useful.
                        </span>
                        実装の継承において、多重継承が有用なことはほとんどありません。
                    </span>
                    <span>
                        <span class="src">
                            We allow multiple inheritance only when at
                            most one of the base classes has an implementation; all
                            other base classes must be <a href="#Interfaces">
                                pure
                                interface
                            </a> classes tagged with the
                            <code>Interface</code> suffix.
                        </span>
                        多重継承の使用が認められるのは、基底クラスのうち実装を持つものが多くとも1つまでで、他の基底クラスはすべて
                        <code>Interface</code>接尾辞でタグ付けされた<a href="#Interfaces">純粋なインターフェース</a>クラスであるときにのみに限定されます。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        <span>
                            <span class="src">
                                Multiple inheritance allows a sub-class to have more than
                                one base class.
                            </span>
                            多重継承により、複数の基底クラスを持った派生クラスを作ることができます。
                        </span>
                        <span>
                            <span class="src">
                                We distinguish between base classes that are
                                <em>pure interfaces</em> and those that have an
                                <em>implementation</em>.
                            </span>
                            ここでは、基底クラスを<em>純粋インターフェース</em>と<em>実装</em>を持ったものに分類して考えます。
                        </span>
                    </p>
                </div>

                <div class="pros">
                    <p>
                        <span>
                            <span class="src">
                                Multiple implementation inheritance may let you re-use
                                even more code than single inheritance (see <a href="#Inheritance">Inheritance</a>).
                            </span>
                            実装の多重継承は、単一の継承よりもたくさんのコードを再利用できるかもしれません(参考:<a href="#Inheritance">継承</a>)。
                        </span>
                    </p>
                </div>

                <div class="cons">
                    <p>
                        <span>
                            <span class="src">
                                Only very rarely is multiple <em>implementation</em>
                                inheritance actually useful.
                            </span>
                            実際のところ、実装の多重継承が役に立つことはほとんどありません。
                        </span>
                        <span>
                            <span class="src">
                                When multiple implementation
                                inheritance seems like the solution, you can usually find
                                a different, more explicit, and cleaner solution.
                            </span>
                            多重継承が問題の答えに見えたとしても、たいていは、もっと明示的できれいな別の方法がきっとあるはずです。
                        </span>
                    </p>
                </div>

                <div class="decision">
                    <p>
                        <span>
                            <span class="src">
                                Multiple inheritance is allowed only when all
                                superclasses, with the possible exception of the first one,
                                are <a href="#Interfaces">pure interfaces</a>.
                            </span>
                            多重継承が認められるのは、1つめの基底クラスを除いて、他のすべての基底クラスが<a href="#Interfaces">純粋なインターフェース</a>であるときのみです。
                        </span>
                        <span>
                            <span class="src">
                                In order to
                                ensure that they remain pure interfaces, they must end with
                                the <code>Interface</code> suffix.
                            </span>
                            クラスが純粋インターフェースであることを保証するために、それらのクラスは<code>Interface</code>接尾辞を持っていなくてはなりません。
                        </span>
                    </p>
                </div>

                <div class="note">
                    <p>
                        <span>
                            <span class="src">
                                There is an <a href="#Windows_Code">exception</a> to
                                this rule on Windows.
                            </span>
                            このルールには<a href="#Windows_Code">Windowsに関する例外</a>があります。
                        </span>
                    </p>
                </div>

            </div>

            <h3 id="Interfaces">
                <span title="Interfaces">インターフェース</span>
            </h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Classes that satisfy certain conditions are allowed, but
                            not required, to end with an <code>Interface</code> suffix.
                        </span>
                        いくつかの特定の条件を満たすクラスは、クラス名を<code>Interface</code>接尾辞で終わることができます(が、必須ではありません)。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        <span>
                            <span class="src">
                                A class is a pure interface if it meets the following
                                requirements:
                            </span>
                            クラスが次の要件を満たすとき、クラスは純粋なインターフェースであると言います。
                        </span>
                    </p>

                    <ul>
                        <li>
                            <span>
                                <span class="src">
                                    It has only public pure virtual ("<code>
                                        =
                                        0
                                    </code>") methods and static methods (but see below
                                    for destructor).
                                </span>
                                public な純粋仮想関数(<code> = 0</code>で宣言された関数)と、静的なメンバ関数(と次で説明するデストラクタ)しかもたない。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    It may not have non-static data members.
                                </span>
                                静的でないデータメンバを持たない。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    It need not have any constructors defined.
                                </span>
                                いかなるコンストラクタも定義されていない。
                            </span>
                            <span>
                                <span class="src">
                                    If a
                                    constructor is provided, it must take no arguments and
                                    it must be protected.
                                </span>
                                コンストラクタが定義されている場合は、引数をとらず、protectedでなくてはならない。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    If it is a subclass, it may only be derived from
                                    classes that satisfy these conditions and are tagged
                                    with the <code>Interface</code> suffix.
                                </span>
                                クラスが派生クラスである場合には、基底とするクラスが、これら同じ条件を満たしていて、かつ、<code>Interface</code>接尾辞でタグ付けされていなくてはならない。
                            </span>
                        </li>
                    </ul>

                    <p>
                        <span>
                            <span class="src">
                                An interface class can never be directly instantiated
                                because of the pure virtual method(s) it declares.
                            </span>
                            インターフェースクラスは、それ自身が純粋仮想関数を宣言しているため、直接インスタンス化されることはありません。
                        </span>
                        <span>
                            <span class="src">
                                To
                                make sure all implementations of the interface can be
                                destroyed correctly, the interface must also declare a
                                virtual destructor (in an exception to the first rule,
                                this should not be pure).
                            </span>
                            インターフェースの持つすべての実装が正しく破壊されることを保証するために、インターフェースは仮想デストラクタを宣言しなくてはなりません(これは、最初のルールに対する唯一の例外として、定義を持たなくてはなりません)。
                        </span>
                        <span>
                            <span class="src">
                                See Stroustrup, <cite>
                                    The C++
                                    Programming Language
                                </cite>, 3rd edition, section 12.4
                                for details.
                            </span>
                            詳細はStroustrup著 <cite>The C++ Programming Language</cite>, 3rd edition セクション 12.4 を参照してください。
                        </span>
                    </p>
                </div>

                <div class="pros">
                    <p>
                        <span>
                            <span class="src">
                                Tagging a class with the <code>Interface</code> suffix
                                lets others know that they must not add implemented
                                methods or non static data members.
                            </span>
                            クラスを<code>Interface</code>でタグ付けすることで、他のプログラマに対して、このクラスに実装や静的でないメンバ変数を追加してはならないということを伝えられます。
                        </span>
                        <span>
                            <span class="src">
                                This is particularly
                                important in the case of <a href="#Multiple_Inheritance">multiple inheritance</a>.
                            </span>
                            これは特に、<a href="#Multiple_Inheritance">多重継承</a>される場合において重要なことです。
                        </span>
                        <span>
                            <span class="src">
                                Additionally, the interface concept is already
                                well-understood by Java programmers.
                            </span>
                            加えて、インターフェースはJavaプログラマの間ではよく知られているコンセプトです。
                        </span>
                    </p>
                </div>

                <div class="cons">
                    <p>
                        <span>
                            <span class="src">
                                The <code>Interface</code> suffix lengthens the class
                                name, which can make it harder to read and understand.
                            </span>
                            <code>Interface</code>という接尾辞をつけると、クラス名が長くなり、読みにくく、理解にしくくなるかもしれません。
                        </span>
                        <span>
                            <span class="src">
                                Also, the interface property may be considered an
                                implementation detail that shouldn't be exposed to
                                clients.
                            </span>
                            また、インターフェースの性質は、クライアントに対して公開すべきでない実装の詳細であると考えることもできます。
                        </span>
                    </p>
                </div>

                <div class="decision">
                    <p>
                        <span>
                            <span class="src">
                                A class may end
                                with <code>Interface</code> only if it meets the above
                                requirements.
                            </span>
                            クラスが上記の要件を満たす場合は<code>Interface</code>接尾辞をつけることができます。
                        </span>
                        <span>
                            <span class="src">
                                We do not require the converse, however:
                                classes that meet the above requirements are not required
                                to end with <code>Interface</code>.
                            </span>
                            逆の要件はありません。つまり、上記の要件を満たすクラスが<code>Interface</code>接尾辞を持たなくてはならないということはありません。
                        </span>
                    </p>
                </div>

            </div>

            <h3 id="Operator_Overloading">
                <span title="Operator Overloading">演算子のオーバーロード</span>
            </h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Overload operators judiciously.
                        </span>
                        演算子のオーバーロードは慎重に行わなくてはなりません。
                    </span>
                    <span>
                        <span class="src">
                            Do not create user-defined literals.
                        </span>
                        ユーザ定義のリテラルは作ってはいけません。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        <span>
                            <span class="src">
                                C++ permits user code to
                                <a href="http://en.cppreference.com/w/cpp/language/operators">
                                    declare
                                    overloaded versions of the built-in operators
                                </a> using the
                                <code>operator</code> keyword, so long as one of the parameters
                                is a user-defined type.
                            </span>
                            C++では、<code>operator</code>キーワードを使うことで、ユーザ定義の型を引数とした<a href="http://en.cppreference.com/w/cpp/language/operators">組み込み演算子のオーバーロードを宣言</a>することができます。
                        </span>
                        <span>
                            <span class="src">
                                The <code>operator</code> keyword also
                                permits user code to define new kinds of literals using
                                <code>operator""</code>, and to define type-conversion functions
                                such as <code>operator bool()</code>.
                            </span>
                            また、<code>operator</code>キーワードは、<code>operator""</code>を用いることで新しいリテラルを定義することもできます。<code>operator bool()</code>など、型変換を定義することもできます。
                        </span>
                    </p>
                </div>

                <div class="pros">
                    <p>
                        <span>
                            <span class="src">
                                Operator overloading can make code more concise and
                                intuitive by enabling user-defined types to behave the same
                                as built-in types.
                            </span>
                            演算子のオーバーロードは、ユーザ定義の型に組み込み型と同様の振る舞いをさせることができるようになるため、コードを簡潔で直感的にすることができます。
                        </span>
                        <span>
                            <span class="src">
                                Overloaded operators are the idiomatic names
                                for certain operations (e.g. <code>==</code>, <code>&lt;</code>,
                                <code>=</code>, and <code>&lt;&lt;</code>), and adhering to
                                those conventions can make user-defined types more readable
                                and enable them to interoperate with libraries that expect
                                those names.
                            </span>
                            オーバーロードされた演算子は、決まった操作に対して慣例に沿った名前を与えます(<code>==</code>や<code>&lt;</code>、<code>=</code>、<code>&lt;&lt;</code>など)。これらの慣例に従うことは、ユーザ定義の型に対する可読性を向上させ、それらの名前を期待しているライブラリとの相互運用性を高めることができます。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                User-defined literals are a very concise notation for
                                creating objects of user-defined types.
                            </span>
                            ユーザ定義のリテラルは、ユーザ定義のオブジェクトを生成する非常に賢明な記載方法です。
                        </span>
                    </p>
                </div>

                <div class="cons">
                    <ul>
                        <li>
                            <span>
                                <span class="src">
                                    Providing a correct, consistent, and unsurprising
                                    set of operator overloads requires some care, and failure
                                    to do so can lead to confusion and bugs.
                                </span>
                                正しい、一貫性を持った、よくある形の演算子のセットを提供するためには、細かな注意が必要となり、失敗すると、混乱やバグを引き起こしかねません。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Overuse of operators can lead to obfuscated code,
                                    particularly if the overloaded operator's semantics
                                    don't follow convention.
                                </span>
                                演算子の過剰な使用、特に、慣例に従わないような意味を演算子に持たせた場合、コードがわかりにくくなります。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    The hazards of function overloading apply just as
                                    much to operator overloading, if not more so.
                                </span>
                                関数のオーバーロードを行う場合と同様の危険性が、演算子のオーバーロードを行う場合にも当てはまります。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Operator overloads can fool our intuition into
                                    thinking that expensive operations are cheap, built-in
                                    operations.
                                </span>
                                演算子のオーバーロードは、本来高コストな処理を組み込み演算子のように低コストに見せかけてしまうことができます。このことは私たちの直感に反します。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Finding the call sites for overloaded operators may
                                    requre a search tool that's aware of C++ syntax, rather
                                    than e.g. grep.
                                </span>
                                オーバーロードされた演算子の呼び出し元を検索しようとする場合、grepでは要をなさず、C++の文法を理解するツールを使用する必要があります。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    If you get the argument type of an overloaded operator
                                    wrong, you may get a different overload rather than a
                                    compiler error.
                                </span>
                                オーバーロードされた演算子の引数の型を間違えたとき、単にコンパイルエラーになるのであればまだよいのですが、エラーにならず別の演算子の呼び出しに解決されてしまうかもしれません。
                            </span>
                            <span>
                                <span class="src">
                                    For example, <code>foo &lt; bar</code>
                                    may do one thing, while <code>&amp;foo &lt; &amp;bar</code>
                                    does something totally different.
                                </span>
                                たとえば、<code>foo &lt; bar</code>と<code>&amp;foo &lt; &amp;bar</code>はまったく意味の異なる演算です。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Certain operator overloads are inherently hazardous.
                                </span>
                                演算子の中には、オーバーロードすること自体に潜在的な危険性をはらんでいるものがあります。
                            </span>
                            <span>
                                <span class="src">
                                    Overloading unary <code>&amp;</code> can cause the same
                                    code to have different meanings depending on whether
                                    the overload declaration is visible.
                                </span>
                                単項演算子<code>&amp;</code>のオーバーロードは、その宣言が見えているかどうかで、意味が変わってしまうことになります。
                            </span>
                            <span>
                                <span class="src">
                                    Overloads of
                                    <code>&amp;&amp;</code>, <code>||</code>, and <code>,</code>
                                    (comma) cannot match the evaluation-order semantics of the
                                    built-in operators.
                                </span>
                                また、<code>&amp;&amp;</code>, <code>||</code>, and <code>,</code>(カンマ演算子)をオーバーロードした場合、組み込み演算子で定められている式の評価順序と一致させることはできません。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Operators are often defined outside the class,
                                    so there's a risk of different files introducing
                                    different definitions of the same operator.
                                </span>
                                オペレータはしばしばクラスの外で定義されますが、その場合、異なるファイルにある異なる定義を引き込んでしまう危険性があります。
                            </span>
                            <span>
                                <span class="src">
                                    If both
                                    definitions are linked into the same binary, this results
                                    in undefined behavior, which can manifest as subtle
                                    run-time bugs.
                                </span>
                                同じバイナリ内でそれらの実装の異なるオペレーターの両方がリンクされてしまった場合、未定義の動作を引き起こし、細かいバグを引き起こすことになるでしょう。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    User-defined literals allow the creation of new
                                    syntactic forms that are unfamiliar even to experienced C++
                                    programmers.
                                </span>
                                ユーザ定義のリテラルは、文法的に新しい形式を生み出しますが、それらは十分経験を積んだC++プログラマにとってさえ親しみの薄いものです。
                            </span>
                        </li>
                    </ul>
                </div>

                <div class="decision">
                    <p>
                        <span>
                            <span class="src">
                                Define overloaded operators only if their meaning is
                                obvious, unsurprising, and consistent with the corresponding
                                built-in operators.
                            </span>
                            演算子のオーバーロードを定義できるのは、意味が明らかであり、動作を予測可能であり、かつ、組み込み演算子との一貫性が保てる場合のみに限定します。
                        </span>
                        <span>
                            <span class="src">
                                For example, use <code>|</code> as a
                                bitwise- or logical-or, not as a shell-style pipe.
                            </span>
                            たとえば、<code>|</code>は、ビット和か論理和の意味でのみ使い、シェルでいうパイプのような意味では使いません。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Define operators only on your own types.
                            </span>
                            演算子は自分の型に対するもののみ定義してください。
                        </span>
                        <span>
                            <span class="src">
                                More precisely,
                                define them in the same headers, .cc files, and namespaces
                                as the types they operate on.
                            </span>
                            より厳密には、それらは型と同じヘッダか.ccファイル、そして型と同じ名前空間の中で定義してください。
                        </span>
                        <span>
                            <span class="src">
                                That way, the operators are available
                                wherever the type is, minimizing the risk of multiple
                                definitions.
                            </span>
                            そうすることで、型が利用可能なところでは演算子も利用できるようになり、演算子の多重定義に関するリスクを最小限にとどめることができます。
                        </span>
                        <span>
                            <span class="src">
                                If possible, avoid defining operators as templates,
                                because they must satisfy this rule for any possible template
                                arguments.
                            </span>
                            可能であれば、演算子をテンプレートとして定義するのは避けてください。テンプレートとして宣言された演算子は、取り得る限りすべてのテンプレート引数において、ここで述べているルールを満たさなくてはなりません。
                        </span>
                        <span>
                            <span class="src">
                                If you define an operator, also define
                                any related operators that make sense, and make sure they
                                are defined consistently.
                            </span>
                            ある演算子を定義する場合、関連するオペレータも定義し、必ず一貫性を持たせるようにしてください。
                        </span>
                        <span>
                            <span class="src">
                                For example, if you overload
                                <code>&lt;</code>, overload all the comparison operators,
                                and make sure <code>&lt;</code> and <code>&gt;</code> never
                                return true for the same arguments.
                            </span>
                            たとえば、<code>&lt;</code>をオーバーロードしたのであれば、すべての比較演算子をオーバーロードし、ある引数の組に対する比較演算<code>&lt;</code>と<code>&gt;</code>の結果が両方ともtrueになるようなことがないようにしてください。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Prefer to define non-modifying binary operators as
                                non-member functions.
                            </span>
                            引数に対して変更を伴わない二項演算子は、非メンバ関数として定義されることが好ましいです。
                        </span>
                        <span>
                            <span class="src">
                                If a binary operator is defined as a
                                class member, implicit conversions will apply to the
                                right-hand argument, but not the left-hand one.
                            </span>
                            仮に二項演算子がクラスのメンバとして定義された場合、演算子の右辺については暗黙的型変換を適用できますが、左辺には適用できなくなってしまいます。
                        </span>
                        <span>
                            <span class="src">
                                It will
                                confuse your users if <code>a &lt; b</code> compiles but
                                <code>b &lt; a</code> doesn't.
                            </span>
                            <code>a &lt; b</code>はコンパイルできるけど<code>b &lt; a</code>はコンパイルできないのような状況は、ユーザを混乱させることになります。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Don't go out of your way to avoid defining operator
                                overloads.
                            </span>
                            演算子のオーバーロードをわざわざ避けるようなことはしないでください。
                        </span>
                        <span>
                            <span class="src">
                                For example, prefer to define <code>==</code>,
                                <code>=</code>, and <code>&lt;&lt;</code>, rather than
                                <code>Equals()</code>, <code>CopyFrom()</code>, and
                                <code>PrintTo()</code>.
                            </span>
                            <code>Equals()</code>や<code>CopyFrom()</code>、<code>PrintTo()</code>などを実装するよりも、<code>==</code>、<code>=</code>、<code>&lt;&lt;</code>を定義するようにしましょう。
                        </span>
                        <span>
                            <span class="src">
                                Conversely, don't define
                                operator overloads just because other libraries expect
                                them.
                            </span>
                            逆に、他のライブラリを使いたいがためだけに演算子をオーバーロードすることは避けてください。
                        </span>
                        <span>
                            <span class="src">
                                For example, if your type doesn't have a natural
                                ordering, but you want to store it in a <code>std::set</code>,
                                use a custom comparator rather than overloading
                                <code>&lt;</code>.
                            </span>
                            たとえば、値同士の順序をつけられないのに、<code>std::set</code>に入れたいがためだけに<code>&lt;</code>をオーバーロードしてはいけません。このような型を<code>std::set</code>に入れたい場合は、カスタムの比較子(comparator)を使うようにします。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Do not overload <code>&amp;&amp;</code>, <code>||</code>,
                                <code>,</code> (comma), or unary <code>&amp;</code>.
                            </span>
                            演算子<code>&amp;&amp;</code>と<code>||</code>と<code>,</code> (カンマ演算子)、単項演算子<code>&amp;</code>はオーバーロードをしてはいけません。
                        </span>
                        <span>
                            <span class="src">
                                Do not overload
                                <code>operator""</code>, i.e. do not introduce user-defined
                                literals.
                            </span>
                            また、<code>operator""</code>のオーバーロードもしてはいけません。つまり、ユーザ定義リテラルを導入してはいけません。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Type conversion operators are covered in the section on
                                <a href="#Implicit_Conversions">implicit conversions</a>.
                            </span>
                            型変換演算子については<a href="#Implicit_Conversions">暗黙的型変換</a>のセクションでカバーします。
                        </span>
                        <span>
                            <span class="src">
                                The <code>=</code> operator is covered in the section on
                                <a href="#Copy_Constructors">copy constructors</a>.
                            </span>
                            <code>=</code>演算子は<a href="#Copy_Constructors">コピーコンストラクタ</a>のセクションでカバーします。
                        </span>
                        <span>
                            <span class="src">
                                Overloading
                                <code>&lt;&lt;</code> for use with streams is covered in the
                                section on <a href="#Streams">streams</a>.
                            </span>
                            <code>&lt;&lt;</code>をストリーム用途で使うオーバーロードについては、<a href="#Streams">ストリーム</a>でカバーします。
                        </span>
                        <span>
                            <span class="src">
                                See also the rules on
                                <a href="#Function_Overloading">function overloading</a>, which
                                apply to operator overloading as well.
                            </span>
                            そのほか、演算子のオーバーロードは<a href="#Function_Overloading">関数のオーバーロード</a>にあるルールも同様に適用されますので、あわせてそちらも参照してください。
                        </span>
                    </p>
                </div>

            </div>

            <h3 id="Access_Control">
                <span title="Access Control">アクセス制限</span>
            </h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Make data members <code>private</code>, unless they are
                            <code>static const</code> (and follow the <a href="#Constant_Names">
                                naming convention for constants
                            </a>).
                        </span>
                        データメンバーは<code>private</code>としてください。
                        ただし、<code>static const</code>であるもの(<a href="#Constant_Names">定数に関する命名規則</a>も参照)を除きます。
                    </span>
                    <span>
                        <span class="src">
                            For technical
                            reasons, we allow data members of a test fixture class to
                            be <code>protected</code> when using
                            <a href="https://github.com/google/googletest">
                                Google
                                Test
                            </a>).
                        </span>
                        技術的な理由により、<a href="https://github.com/google/googletest">Google Test</a>を使う場合のテスト用のクラスのデータメンバは<code>protected</code>であってもよいとします。
                    </span>
                </p>
            </div>

            <h3 id="Declaration_Order">
                <span title="Declaration Order">宣言の順序</span>
            </h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Group similar declarations together, placing public parts
                            earlier.
                        </span>
                        似ている宣言は1つにまとめ、public部分の先の方に置きます。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <p>
                    <span>
                        <span class="src">
                            A class definition should usually start with a
                            <code>public:</code> section, followed by
                            <code>protected:</code>, then <code>private:</code>.
                        </span>
                        クラスの定義は、通常は<code>public:</code>セクションから始め、<code>protected:</code>、<code>private:</code>と続けます。
                    </span>
                    <span>
                        <span class="src">
                            Omit
                            sections that would be empty.
                        </span>
                        空になるセクションは省略してください。
                    </span>
                </p>

                <p>
                    <span>
                        <span class="src">
                            Within each section, generally prefer grouping similar
                            kinds of declarations together, and generally prefer the
                            following order: types (including <code>typedef</code>,
                            <code>using</code>, and nested structs and classes),
                            constants, factory functions, constructors, assignment
                            operators, destructor, all other methods, data members.
                        </span>
                        各セクションにおいて、似た宣言は1カ所にまとるようにしましょう。また、順序は、型(<code>typedef</code>、<code>using</code>、内部構造体・クラスを含む)、定数、ファクトリ関数、コンストラクタ、代入演算子、デストラクタ、それ以外のすべてのメソッド、データメンバ の順となるようにしましょう。
                    </span>
                </p>

                <p>
                    <span>
                        <span class="src">
                            Do not put large method definitions inline in the
                            class definition.
                        </span>
                        クラス定義の中では、大きなメソッドの定義をインラインで行わないでください。
                    </span>
                    <span>
                        <span class="src">
                            Usually, only trivial or
                            performance-critical, and very short, methods may be
                            defined inline.
                        </span>
                        通常は、ささいな関数、パフォーマンス的に重要な関数、非常に短い関数のみがインラインで定義されます。
                    </span>
                    <span>
                        <span class="src">
                            See <a href="#Inline_Functions">
                                Inline
                                Functions
                            </a> for more details.
                        </span>
                        詳細は<a href="#Inline_Functions">インライン関数</a>で述べます。
                    </span>
                </p>

            </div>

            <h2 id="Functions">
                <span title="Functions">関数</span>
            </h2>

            <h3 id="Function_Parameter_Ordering">
                <span title="Parameter Ordering">引数の順序</span>
            </h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            When defining a function, parameter order is: inputs, then
                            outputs.
                        </span>
                        関数を定義するときの引数の順序は入力が先、出力が後とします。
                    </span>
                </p>
            </div>

            <div class="stylebody">
                <p>
                    <span>
                        <span class="src">
                            Parameters to C/C++ functions are either input to the
                            function, output from the function, or both.
                        </span>
                        C/C++の関数に渡される引数は、関数への入力であるか、関数への出力であるか、あるいはその両方です。
                    </span>
                    <span>
                        <span class="src">
                            Input
                            parameters are usually values or <code>const</code>
                            references, while output and input/output parameters will
                            be pointers to non-<code>const</code>.
                        </span>
                        入力となる引数は、通常は、値渡しか、<code>const</code>参照渡しです。一方で出力となる引数、あるいは入力と出力の両方となる引数は、非<code>const</code>なポインタとなります。
                    </span>
                    <span>
                        <span class="src">
                            When ordering
                            function parameters, put all input-only parameters before
                            any output parameters.
                        </span>
                        引数の順番を決めるときは、入力のみに使われる引数を、いかなる出力の引数よりも前に配置します。
                    </span>
                    <span>
                        <span class="src">
                            In particular, do not add new
                            parameters to the end of the function just because they
                            are new; place new input-only parameters before the
                            output parameters.
                        </span>
                        特に、新しい引数を追加するときは、新しいからという理由だけで関数の最後に追加してはいけません。新しく追加する引数が入力のための引数であるのならば、それは出力引数の前に配置します。
                    </span>
                </p>

                <p>
                    <span>
                        <span class="src">
                            This is not a hard-and-fast rule.
                        </span>
                        これは絶対のルールではありません。
                    </span>
                    <span>
                        <span class="src">
                            Parameters that are
                            both input and output (often classes/structs) muddy the
                            waters, and, as always, consistency with related
                            functions may require you to bend the rule.
                        </span>
                        入力と出力の両方の役割を持つ引数(大抵はクラスや構造体)が存在する場合は、明確な線引きはできません。また、関連する関数との一貫性を保つためにはこのルールを曲げなくてはならないかもしれません。
                    </span>
                </p>

            </div>

            <h3 id="Write_Short_Functions">
                <span title="Write Short Functions">関数は短く</span>
            </h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Prefer small and focused functions.
                        </span>
                        関数は、短く、焦点を絞ったものにしましょう。
                    </span>
                </p>
            </div>

            <div class="stylebody">
                <p>
                    <span>
                        <span class="src">
                            We recognize that long functions are sometimes
                            appropriate, so no hard limit is placed on functions
                            length.
                        </span>
                        時には長い関数の方が適切なこともあるため、関数の長さに関する固定の限界値は定めません。
                    </span>
                    <span>
                        <span class="src">
                            If a function exceeds about 40 lines, think about
                            whether it can be broken up without harming the structure
                            of the program.
                        </span>
                        だいたい40行程度を超えるようであれば、プログラムの構造を破壊することなく関数を分割できないか考えてみてください。
                    </span>
                </p>

                <p>
                    <span>
                        <span class="src">
                            Even if your long function works perfectly now,
                            someone modifying it in a few months may add new
                            behavior.
                        </span>
                        長い関数が、現時点では完璧に動いていたとしても、1～2ヶ月後に誰かがそれを変更し、新しい動作を足すかもしれません。
                    </span>
                    <span>
                        <span class="src">
                            This could result in bugs that are hard to
                            find.
                        </span>
                        その結果として見つけるのが困難なバグを引き起こすかもしれません。
                    </span>
                    <span>
                        <span class="src">
                            Keeping your functions short and simple makes it
                            easier for other people to read and modify your code.
                        </span>
                        関数を短くシンプルであるように保つことで、コードをより読みやすく、より変更しやすくできるのです。
                    </span>
                </p>

                <p>
                    <span>
                        <span class="src">
                            You could find long and complicated functions when
                            working with
                            some code.
                        </span>
                        作業をしていると、長い複雑なコードに出くわすこともあるでしょう。
                    </span>
                    <span>
                        <span class="src">
                            Do not be
                            intimidated by modifying existing code: if working with
                            such a function proves to be difficult, you find that
                            errors are hard to debug, or you want to use a piece of
                            it in several different contexts, consider breaking up
                            the function into smaller and more manageable pieces.
                        </span>
                        既存のコードを変更することにおびえてはいけません。
                        そのコードを使って仕事を進めることが困難であることがわかった場合、エラーのデバッグが難しいことがわかった場合、あるいは別の文脈においてその関数の一部分だけを切り出して使いたくなった場合、関数をより小さく扱いやすい複数の断片に分割することを検討してください。
                    </span>
                </p>

            </div>

            <h3 id="Reference_Arguments">
                <span title="Reference Arguments">参照渡し</span>
            </h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            All parameters passed by reference must be labeled
                            <code>const</code>.
                            参照渡しされる引数は必ず<code>const</code>でなくてはなりません。
                        </span>
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        <span>
                            <span class="src">
                                In C, if a
                                function needs to modify a variable, the parameter must
                                use a pointer, eg <code>int foo(int *pval)</code>.
                            </span>
                            C言語において、関数が変数を変更する必要があるときは、引数にポインタを使わなくてはなりません(例: <code>int foo(int *pval)</code>)。
                        </span>
                        <span>
                            <span class="src">
                                In
                                C++, the function can alternatively declare a reference
                                parameter: <code>int foo(int &amp;val)</code>.
                            </span>
                            C++においては、他の方法として、参照渡しを使って関数を宣言することもできます(例:<code>int foo(int &amp;val)</code>)。
                        </span>
                    </p>
                </div>

                <div class="pros">
                    <p>
                        <span>
                            <span class="src">
                                Defining a parameter as reference avoids ugly code like
                                <code>(*pval)++</code>.
                            </span>
                            引数を参照にすることで、<code>(*pval)++</code>のような醜いコードを避けられます。
                        </span>
                        <span>
                            <span class="src">
                                Necessary for some applications
                                like copy constructors.
                            </span>
                            参照渡しは、コピーコンストラクタなど、それを必要する場面があります。
                        </span>
                        <span>
                            <span class="src">
                                Makes it clear, unlike with
                                pointers, that a null pointer is not a possible
                                value.
                            </span>
                            参照渡しは、ポインタと違って、ヌルポインタが渡せないことが明確になります。
                        </span>
                    </p>
                </div>

                <div class="cons">
                    <p>
                        <span>
                            <span class="src">
                                References can be confusing, as they have value syntax
                                but pointer semantics.
                            </span>
                            参照は、値型と同じ文法のまま、ポインタと同じような意味を持つため、混乱しやすいです。
                        </span>
                    </p>
                </div>

                <div class="decision">
                    <p>
                        <span>
                            <span class="src">
                                Within function parameter lists all references must be
                                <code>const</code>:
                            </span>
                            関数の引数リストにおいては、以下の例のように、すべての参照は<code>const</code>でなくてはなりません。
                        </span>
                    </p>

<pre>void Foo(const string &amp;in, string *out);
</pre>

                    <p>
                        <span>
                            <span class="src">
                                In fact it is a very strong convention in Google code
                                that input arguments are values or <code>const</code>
                                references while output arguments are pointers.
                            </span>
                            実際、入力引数が値渡しか<code>const</code>参照であり、出力引数がポインタであるということは、Googleのコードにおいて非常に強いしきたりになっています。
                        </span>
                        <span>
                            <span class="src">
                                Input
                                parameters may be <code>const</code> pointers, but we
                                never allow non-<code>const</code> reference parameters
                                except when required by convention, e.g.,
                                <code>swap()</code>.
                            </span>
                            入力引数に<code>const</code>ポインタが使われることはありますが、非<code>const</code>な参照は、<code>swap()</code>のような習慣的な要求がある場合を除いて、認められることはありません。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                However, there are some instances where using
                                <code>const T*</code> is preferable to <code>
                                    const
                                    T&amp;
                                </code> for input parameters.
                            </span>
                            入力引数に<code>const T&amp;</code>より<code>const T*</code> を使う方がよい場面もあります。
                        </span>
                        <span>
                            <span class="src">
                                For example:
                            </span>
                            たとえば、
                        </span>
                    </p>

                    <ul>
                        <li>
                            <span>
                                <span class="src">
                                    You want to pass in a null pointer.
                                </span>
                                ヌルポインタを渡したいとき や
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    The function saves a pointer or reference to the
                                    input.
                                </span>
                                関数が入力にポインタか参照を保存したいとき です。
                            </span>
                        </li>
                    </ul>

                    <p>
                        <span>
                            <span class="src">
                                Remember that most of the time input
                                parameters are going to be specified as <code>
                                    const
                                    T&amp;
                                </code>.
                                ほとんどの場合、入力引数は<code>const T&amp;</code>のように特殊化されます。
                            </span>
                        </span>
                        <span>
                            <span class="src">
                                Using <code>const T*</code> instead
                                communicates to the reader that the input is somehow
                                treated differently.
                            </span>
                            <code>const T*</code>という表現を使うことは、コードの読者に、ここでは入力に対して何かしら普段と違う扱い方をしますよと伝えていることになります。
                        </span>
                        <span>
                            <span class="src">
                                So if you choose <code>
                                    const
                                    T*
                                </code> rather than <code>const T&amp;</code>, do so
                                for a concrete reason; otherwise it will likely confuse
                                readers by making them look for an explanation that
                                doesn't exist.
                            </span>
                            あなたが、<code>const T&amp;</code>ではなく、<code>const T*</code>を選ぶときは具体的な理由が必要です。さもなくば、コードの読者が、(ポインタを使っている)ありもしない理由を探そうとしてしまうかもしれず、混乱を招くかもしれません。
                        </span>
                    </p>
                </div>

            </div>

            <h3 id="Function_Overloading">
                <span title="Function Overloading">関数のオーバーロード</span>
            </h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Use overloaded functions (including constructors) only if a
                            reader looking at a call site can get a good idea of what
                            is happening without having to first figure out exactly
                            which overload is being called.
                        </span>
                        コンストラクタを含む関数のオーバーロードは、コードの読者が、その呼び出し元を読んだときに、具体的にどのオーバーロードが呼び出されるか正確に把握していなくとも、何が起こるか理解できるであろう場合にのみ使用できます。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        <span>
                            <span class="src">
                                You may write a function that takes a <code>
                                    const
                                    string&amp;
                                </code> and overload it with another that
                                takes <code>const char*</code>.
                            </span>
                            <code>const string&amp;</code>を引数にとる関数と、<code>const char*</code>を引数にとるオーバーロードとを書くことができます。
                        </span>
                    </p>

<pre>class MyClass {
 public:
  void Analyze(const string &amp;text);
  void Analyze(const char *text, size_t textlen);
};
</pre>
                </div>

                <div class="pros">
                    <p>
                        <span>
                            <span class="src">
                                Overloading can make code more intuitive by allowing an
                                identically-named function to take different arguments.
                            </span>
                            オーバーロードによって、同一名の関数に異なる引数をとらせることができるため、コードがより直感的になります。
                        </span>
                        <span>
                            <span class="src">
                                It may be necessary for templatized code, and it can be
                                convenient for Visitors.
                            </span>
                            この機能は、テンプレート化されたコードにおいて必要とされ、また、ビジターパターンにおいても有用となるでしょう。
                        </span>
                    </p>
                </div>

                <div class="cons">
                    <p>
                        <span>
                            <span class="src">
                                If a function is overloaded by the argument types alone,
                                a reader may have to understand C++'s complex matching
                                rules in order to tell what's going on.
                            </span>
                            ある関数が引数の型だけでオーバーロードされている場合、コードの読者がそこで実際に起きることを知るためには、C++の複雑なマッチングルールについて理解していなくてはなりません。
                        </span>
                        <span>
                            <span class="src">
                                Also many people
                                are confused by the semantics of inheritance if a derived
                                class overrides only some of the variants of a
                                function.
                            </span>
                            また、複数のオーバーロードを持つ仮想関数を、派生先で部分的にオーバーライドした場合の挙動は、多くの人を困惑させています。
                        </span>
                    </p>
                </div>

                <div class="decision">
                    <p>
                        <span>
                            <span class="src">
                                If you want to overload a function, consider qualifying
                                the name with some information about the arguments, e.g.,
                                <code>AppendString()</code>, <code>AppendInt()</code>
                                rather than just <code>Append()</code>.
                            </span>
                            関数をオーバーロードしたくなったら、まずは名前に引数の情報をつける(たとえば、<code>Append()</code>の代わりに、<code>AppendString()</code>や<code>AppendInt()</code>とする)やり方を検討してください。
                        </span>
                        <span>
                            <span class="src">
                                If you are
                                overloading a function to support variable number of
                                arguments of the same type, consider making it take a
                                <code>std::vector</code> so that the user can use an
                                <a href="#Braced_Initializer_List">
                                    initializer list
                                </a> to specify the arguments.
                            </span>
                            また、型は同一でも、その型の引数をいくつとるかによってオーバーロードを定義したいときは、<code>std::vector</code>を引数にとるようにするやり方を検討してください。その方法ならば、ユーザは<a href="#Braced_Initializer_List">初期化子リスト</a>の形で引数を渡せます。
                        </span>
                    </p>
                </div>

            </div>

            <h3 id="Default_Arguments">
                <span title="Default Arguments">引数のデフォルト値</span>
            </h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Default arguments are allowed on non-virtual functions
                            when the default is guaranteed to always have the same
                            value.
                        </span>
                        引数にデフォルトの値を与えられるのは、その関数が仮想関数ではなく、かつ、値が常に同じ値になることを保証できる場合に限ります。
                    </span>
                    <span>
                        <span class="src">
                            Follow the same restrictions as for <a href="#Function_Overloading">function overloading</a>, and
                            prefer overloaded functions if the readability gained with
                            default arguments doesn't outweigh the downsides below.
                        </span>
                        <a href="#Function_Overloading">関数のオーバーロード</a>と同様の制限に従ってください。また、引数にデフォルト値を与えることによって得られる可読性よりも、以下に述べるマイナス面の方が勝る場合、代わりに関数のオーバーロードを使いましょう。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <div class="pros">
                    <p>
                        <span>
                            <span class="src">
                                Often you have a function that uses default values, but
                                occasionally you want to override the defaults.
                            </span>
                            普段はデフォルトの値で使っている関数でも、時々別の値に変えて呼び出したくなることがあります。
                        </span>
                        <span>
                            <span class="src">
                                Default
                                parameters allow an easy way to do this without having to
                                define many functions for the rare exceptions.
                            </span>
                            引数にデフォルト値を与えることは、このような"時々"のための関数をたくさん定義することなく、簡単にやりたいことを実現するための手段の一つです。
                        </span>
                        <span>
                            <span class="src">
                                Compared
                                to overloading the function, default arguments have a
                                cleaner syntax, with less boilerplate and a clearer
                                distinction between 'required' and 'optional'
                                arguments.
                            </span>
                            関数のオーバーロードと比較して、このやり方は、文法的にきれいで、より少ない例で済み、さらに、引数が必須か任意かをより明確に区別できるようにもなります。
                        </span>
                    </p>
                </div>

                <div class="cons">
                    <p>
                        <span>
                            <span class="src">
                                Defaulted arguments are another way to achieve the
                                semantics of overloaded functions, so all the <a href="#Function_Overloading">
                                    reasons not to overload
                                    functions
                                </a> apply.
                            </span>
                            引数にデフォルト値を与える方法は、関数のオーバーロードでできることを実現する別の方法でもあるため、すべての<a href="#Function_Overloading">関数をオーバーロードしない理由</a>を適用します。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                The defaults for arguments in a virtual function call are
                                determined by the static type of the target object, and
                                there's no guarantee that all overrides of a given function
                                declare the same defaults.
                            </span>
                            仮想関数呼び出しにおける引数のデフォルト値は、オブジェクトの静的な型に基づいて決定されますが、その関数のすべてのオーバーライドが、同じデフォルト値とともに宣言されている保証はどこにもありません。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Default parameters are re-evaluated at each call site,
                                which can bloat the generated code.
                            </span>
                            引数のデフォルト値は、呼び出されるごとに評価されるため、生成されるコードの量がふくれます。
                        </span>
                        <span>
                            <span class="src">
                                Readers may also expect
                                the default's value to be fixed at the declaration instead
                                of varying at each call.
                            </span>
                            また、コードの読者は、関数が呼び出されるたびにデフォルト値が変わるのではなく、宣言時点で決まった値に固定されていることを期待するかもしれません。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Function pointers are confusing in the presence of
                                default arguments, since the function signature often
                                doesn't match the call signature.
                            </span>
                            関数ポインタを引数のデフォルト値として与えると混乱の元になります。関数のシグネチャはしばしば、呼び出す際のシグネチャと一致しないことがあるからです。
                        </span>
                        <span>
                            <span class="src">
                                Adding
                                function overloads avoids these problems.
                            </span>
                            関数のオーバーロードであれば、これらの問題は回避することができます。
                        </span>
                    </p>
                </div>

                <div class="decision">
                    <p>
                        <span>
                            <span class="src">
                                Default arguments are banned on virtual functions, where
                                they don't work properly, and in cases where the specified
                                default might not evaluate to the same value depending on
                                when it was evaluated.
                            </span>
                            仮想関数における引数にデフォルト値を与えても、それらは意図した通りに動作しないため禁止とします。また、デフォルト値が評価のタイミングによって必ず同じ値にならない場合についても禁止とします。
                        </span>
                        <span>
                            <span class="src">
                                (For example, don't write <code>
                                    void
                                    f(int n = counter++);
                                </code>.)
                            </span>
                            (たとえば、次のように書いてはいけません: <code>void f(int n = counter++);</code>)
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                In some other cases, default arguments can improve the
                                readability of their function declarations enough to
                                overcome the downsides above, so they are allowed.
                            </span>
                            その他のいくつかの場合において、引数にデフォルト値を与えることで、ここまで述べた悪い点を差し引いても十分に関数宣言の可読性を高めることができる場合があります。このとき、それらの使用が認められます。
                        </span>
                        <span>
                            <span class="src">
                                When in
                                doubt, use overloads.
                            </span>
                            迷ったときは関数のオーバーロードを選択します。
                        </span>
                    </p>
                </div>

            </div>

            <h3 id="trailing_return">
                <span title="Trailing Return Type Syntax">戻り値の型を後置する関数宣言構文</span>
            </h3>
            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Use trailing return types only where using the ordinary syntax (leading
                            return types) is impractical or much less readable.
                        </span>
                        戻り値の型を後置する関数宣言構文は、普通の構文(戻り値の型から始まる構文)を使うことができない場合か、普通の構文では可読性に劣ってしまう場合にのみ使用します。
                    </span>
                </p>
            </div>

            <div class="definition">
                <p>
                    <span>
                        <span class="src">
                            C++ allows two different forms of function declarations.
                        </span>
                        C++では、2種類の異なる関数宣言の構文が認められています。
                    </span>
                    <span>
                        <span class="src">
                            In the older
                            form, the return type appears before the function name. For example:
                        </span>
                        古い形では、次の例のように、戻り値の型が関数名より先にきます。
                    </span>
                </p>
<pre>int foo(int x);
</pre>
                <p>
                    <span>
                        <span class="src">
                            The new form, introduced in C++11, uses the <code>auto</code>
                            keyword before the function name and a trailing return type after
                            the argument list.
                        </span>
                        C++で導入された新しい形は、<code>auto</code>キーワードを関数名の前に置き、戻り値の型を引数リストの後に置きます。
                    </span>
                    <span>
                        <span class="src">
                            For example, the declaration above could
                            equivalently be written:
                        </span>
                        例として、先ほどの宣言と等価な宣言は次のようになります。
                    </span>
                </p>
<pre>auto foo(int x) -&gt; int;
</pre>
                <p>
                    <span>
                        <span class="src">
                            The trailing return type is in the function's scope.
                        </span>
                        この戻り値の型は関数内スコープとなります。
                    </span>
                    <span>
                        <span class="src">
                            This doesn't
                            make a difference for a simple case like <code>int</code> but it matters
                            for more complicated cases, like types declared in class scope or
                            types written in terms of the function parameters.
                        </span>
                        <code>int</code>のように単純な場合はこれらに違いはありませんが、型がより複雑な場合にはこれは重要となってきます。
                        たとえば、型がクラススコープで宣言されている場合や、型が関数の引数によって決まったりする場合です。
                    </span>
                </p>
            </div>

            <div class="stylebody">
                <div class="pros">
                    <p>
                        <span>
                            <span class="src">
                                Trailing return types are the only way to explicitly specify the
                                return type of a <a href="#Lambda_expressions">lambda expression</a>.
                            </span>
                            戻り値の型を後置する構文は、<a href="#Lambda_expressions">ラムダ式</a>の戻り値の型を明示できる唯一の方法です。
                        </span>
                        <span>
                            <span class="src">
                                In some cases the compiler is able to deduce a lambda's return type,
                                but not in all cases.
                            </span>
                            コンパイラはラムダ式の戻り値の型を推論できる場合がありますが、常にそれができるわけではありません。
                        </span>
                        <span>
                            <span class="src">
                                Even when the compiler can deduce it automatically,
                                sometimes specifying it explicitly would be clearer for readers.
                            </span>
                            コンパイラが自動的に型を推論できる場合であっても、型を明示することでコードの可読性を向上させる場合もあります。
                        </span>
                    </p>
                    <p>
                        <span>
                            <span class="src">
                                Sometimes it's easier and more readable to specify a return type
                                after the function's parameter list has already appeared.
                            </span>
                            時に、戻り値の型を関数の引数の後ろに明示することで、より簡単で可読性が高くなることがあります。
                        </span>
                        <span>
                            <span class="src">
                                This is
                                particularly true when the return type depends on template parameters.
                            </span>
                            特に、戻り値の型がテンプレートパラメータによって決まる場合にはこのことが言えます。
                        </span>
                        <span>
                            <span class="src">
                                For example:
                            </span>
                            次の例を見てください。
                        </span>
                    </p>
                    <pre>template &lt;class T, class U&gt; auto add(T t, U u) -&gt; decltype(t + u);</pre>
                    <span>
                        <span class="src">
                            versus
                        </span>
                        対
                    </span>
                    <pre>template &lt;class T, class U&gt; decltype(declval&lt;T&amp;&gt;() + declval&lt;U&amp;&gt;()) add(T t, U u);</pre>
                </div>

                <div class="cons">
                    <p>
                        <span>
                            <span class="src">
                                Trailing return type syntax is relatively new and it has no
                                analogue in C++-like languages like C and Java, so some readers may
                                find it unfamiliar.
                            </span>
                            戻り値の型を後置する構文は、比較的新しく、C++系言語(C言語やJavaなど)には類似の構文がありません。このため、コードの読者にとってなじみが薄いかもしれません。
                        </span>
                    </p>
                    <p>
                        <span>
                            <span class="src">
                                Existing code bases have an enormous number of function
                                declarations that aren't going to get changed to use the new syntax,
                                so the realistic choices are using the old syntax only or using a mixture
                                of the two.
                            </span>
                            既存のコードベースには既に膨大な数の関数宣言があり、それらが新しい構文に替わることはないでしょう。このため、現実的には、古い構文と新しい構文との両方を混合させて使っていくという道を選択することになります。
                        </span>
                        <span>
                            <span class="src">
                                Using a single version is better for uniformity of style.
                            </span>
                            スタイルの一様性のためには、1種類だけを使うことが好ましいです。
                        </span>
                    </p>
                </div>

                <div class="decision">
                    <p>
                        <span>
                            <span class="src">
                                In most cases, continue to use the older style of function
                                declaration where the return type goes before the function name.
                            </span>
                            ほとんどの場合において、旧来からある、戻り値の型が関数名より先に来る関数宣言の構文を使い続けてください。
                        </span>
                        <span>
                            <span class="src">
                                Use the new trailing-return-type form only in cases where it's
                                required (such as lambdas) or where, by putting the type after the
                                function's parameter list, it allows you to write the type in a much
                                more readable way.
                            </span>
                            新しい構文を使用してよいのは、それがどうしても必要な場合(ラムダ式のような)と、引数のリストの後ろに戻り値の型を置くことで可読性を大きく向上させられる場合に限定します。
                        </span>
                        <span>
                            <span class="src">
                                The latter case should be rare; it's mostly an
                                issue in fairly complicated template code, which is
                                <a href="#Template_metaprogramming">discouraged in most cases</a>.
                            </span>
                            後者の状況はまれです。というのも、大抵、複雑すぎるテンプレートのコードが問題なのであって、<a href="#Template_metaprogramming">それらのほとんどは解消できる</a>からです。
                        </span>
                    </p>
                </div>
            </div>

            <h2 id="Google-Specific_Magic">
                <span title="Google-Specific Magic">Google特有のマジック</span>
            </h2>



            <p>
                <span>
                    <span class="src">
                        There are various tricks and utilities that
                        we use to make C++ code more robust, and various ways we use
                        C++ that may differ from what you see elsewhere.
                    </span>
                    我々はC++のコードをより堅牢にするためのトリックやユーティリティを使用しています。
                    我々が使用する様々な手法は、一般的に見られるC++の使い方とは異なっているかもしれません。
                </span>
            </p>



            <h3 id="Ownership_and_Smart_Pointers">
                <span title="Ownership and Smart Pointers">スマートポインタの所有権</span>
            </h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Prefer to have single, fixed owners for dynamically
                            allocated objects.
                        </span>
                        動的に確保されるオブジェクトの所有者は、単一かつ固定されるようにしましょう。
                    </span>
                    <span>
                        <span class="src">
                            Prefer to transfer ownership with smart
                            pointers.
                        </span>
                        オブジェクトの所有権を移すときは、スマートポインタを使用しましょう。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        <span>
                            <span class="src">
                                "Ownership" is a bookkeeping technique for managing
                                dynamically allocated memory (and other resources).
                            </span>
                            "所有権"は、動的に確保されるメモリ(や他のリソース)を管理するための帳簿的なテクニックの一つです。
                        </span>
                        <span>
                            <span class="src">
                                The
                                owner of a dynamically allocated object is an object or
                                function that is responsible for ensuring that it is
                                deleted when no longer needed.
                            </span>
                            動的に確保されるオブジェクトの所有者は、1つのオブジェクトか関数であり、オブジェクトが不要になったときにそれを解放する責任を負います。
                        </span>
                        <span>
                            <span class="src">
                                Ownership can sometimes be
                                shared, in which case the last owner is typically
                                responsible for deleting it.
                            </span>
                            所有権は時には共有されることもあります。その場合、一般的に最後の所有者が解放の責任を負います。
                        </span>
                        <span>
                            <span class="src">
                                Even when ownership is not
                                shared, it can be transferred from one piece of code to
                                another.
                            </span>
                            所有権は、共有まではされない場合でも、あるコードから他のコードへと移されることがあります。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                "Smart" pointers are classes that act like pointers,
                                e.g. by overloading the <code>*</code> and
                                <code>-&gt;</code> operators.
                            </span>
                            "スマート"ポインタとは、ポインタのように振る舞うクラスです(たとえば演算子<code>*</code>と<code>-&gt;</code>をオーバーロードしています)。
                        </span>
                        <span>
                            <span class="src">
                                Some smart pointer types
                                can be used to automate ownership bookkeeping, to ensure
                                these responsibilities are met.
                            </span>
                            いくつかのスマートポインタは、このような解放の責任を確実にするための所有権管理を自動的に行うために使われるものがあります。
                        </span>
                        <span>
                            <span class="src">
                                <a href="http://en.cppreference.com/w/cpp/memory/unique_ptr">
                                    <code>std::unique_ptr</code>
                                </a> is a smart pointer type
                                introduced in C++11, which expresses exclusive ownership
                                of a dynamically allocated object; the object is deleted
                                when the <code>std::unique_ptr</code> goes out of scope.
                            </span>
                            <a href="http://en.cppreference.com/w/cpp/memory/unique_ptr"><code>std::unique_ptr</code></a>は、スマートポインタの一種で、C++11で導入されました。このスマートポインタは、動的に確保されたオブジェクトに対する排他的な所有権を表します。<code>std::unique_ptr</code>によって所有されるオブジェクトは、<code>std::unique_ptr</code>がスコープの外に出たときにdeleteされます。
                        </span>
                        <span>
                            <span class="src">
                                It cannot be copied, but can be <em>moved</em> to
                                represent ownership transfer.
                            </span>
                            <code>std::unique_ptr</code>をコピーすることはできませんが、担当する所有権を<em>移動</em>させることはできます。
                        </span>
                        <span>
                            <span class="src">
                                <a href="http://en.cppreference.com/w/cpp/memory/shared_ptr">
                                    <code>std::shared_ptr</code>
                                </a> is a smart pointer type
                                that expresses shared ownership of
                                a dynamically allocated object.
                            </span>
                            <a href="http://en.cppreference.com/w/cpp/memory/shared_ptr"><code>std::shared_ptr</code></a>は、動的に確保されたオブジェクトの所有権を他者と共有することを表すために使われるスマートポインタです。
                        </span>

                        <span>
                            <span class="src">
                                <code>std::shared_ptr</code>s
                                can be copied; ownership of the object is shared among
                                all copies, and the object is deleted when the last
                                <code>std::shared_ptr</code> is destroyed.
                            </span>
                            <code>std::shared_ptr</code>はコピーすることができます。オブジェクトの所有権はすべてのコピーの間で共有され、オブジェクトは最後の<code>std::shared_ptr</code>が破壊されるときにdeleteされます。
                        </span>
                    </p>
                </div>

                <div class="pros">
                    <ul>
                        <li>
                            <span>
                                <span class="src">
                                    It's virtually impossible to manage dynamically
                                    allocated memory without some sort of ownership
                                    logic.
                                </span>
                                所有権の概念がなければ、動的に確保されるメモリを管理するのは実質的に不可能です。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Transferring ownership of an object can be cheaper
                                    than copying it (if copying it is even possible).
                                </span>
                                所有権を移すだけであれば、オブジェクトをコピーするよりも低コストとなるでしょう。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Transferring ownership can be simpler than
                                    'borrowing' a pointer or reference, because it reduces
                                    the need to coordinate the lifetime of the object
                                    between the two users.
                                </span>
                                オブジェクトの所有権を移すことは、参照やポインタを「借りてくる」よりも単純です。なぜならば、そのオブジェクトを扱う二者間での、オブジェクトの生存期間に関する認識合わせの必要性を減らすからです。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Smart pointers can improve readability by making
                                    ownership logic explicit, self-documenting, and
                                    unambiguous.
                                </span>
                                スマートポインタは、所有権を明示化し、それ自体にドキュメントの意味合いを持たせられるため、可読性が向上します。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Smart pointers can eliminate manual ownership
                                    bookkeeping, simplifying the code and ruling out large
                                    classes of errors.
                                </span>
                                スマートポインタは手作業による所有権管理をなくし、コードを単純化し、エラーのうち大きな分類を除外することができます。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    For const objects, shared ownership can be a simple
                                    and efficient alternative to deep copying.
                                </span>
                                constなオブジェクトについていえば、所有権を共有することは、単純かつ効率的なディープコピーの代替手段となります。
                            </span>
                        </li>
                    </ul>
                </div>

                <div class="cons">
                    <ul>
                        <li>
                            <span>
                                <span class="src">
                                    Ownership must be represented and transferred via
                                    pointers (whether smart or plain).
                                </span>
                                所有権は、スマートポインタであろうと生のポインタであろうと、何らかのポインタによって扱われ、ポインタ間で受け渡しが行われます。
                            </span>
                            <span>
                                <span class="src">
                                    Pointer semantics
                                    are more complicated than value semantics, especially
                                    in APIs: you have to worry not just about ownership,
                                    but also aliasing, lifetime, and mutability, among
                                    other issues.
                                </span>
                                ポインタの概念は値を直接扱うよりも複雑で、特にAPIの層では、所有権だけではなく、エイリアシング、ライフタイム、ミュータビリティ、などについても気にしなくてはなりません。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    The performance costs of value semantics are often
                                    overestimated, so the performance benefits of ownership
                                    transfer might not justify the readability and
                                    complexity costs.
                                </span>
                                値を直接扱うときのパフォーマンスコストはしばしば想定よりも高く見積もられがちです。所有権を移す方法を選択することで得られるパフォーマンス上のメリットは、それによる可読性の低下や複雑化のコストに見合わないかもしれません。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    APIs that transfer ownership force their clients
                                    into a single memory management model.
                                </span>
                                所有権を移すAPIは、その使用者にシングルメモリマネジメントモデルを強制します。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Code using smart pointers is less explicit about
                                    where the resource releases take place.
                                </span>
                                スマートポインタ使っているコードは、リソースがいつどこで解放されるかの明示性が低下します。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    <code>std::unique_ptr</code> expresses ownership
                                    transfer using C++11's move semantics, which are
                                    relatively new and may confuse some programmers.
                                </span>
                                <code>std::unique_ptr</code> は、C+11のムーブのセマンティクスを使って所有権を移します。ムーブの概念は比較的新しいため、プログラマを混乱させるかもしれません。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Shared ownership can be a tempting alternative to
                                    careful ownership design, obfuscating the design of a
                                    system.
                                </span>
                                所有権に関するデザインを注意深く行うのに比べて、単純に所有権を共有させて済ませてしまうことは、魅惑的な代替手段に見える場合があります。そして、それはシステムのデザインを曖昧にしてしまうことに繋がります。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Shared ownership requires explicit bookkeeping at
                                    run-time, which can be costly.
                                </span>
                                所有権を共有させると、実行時に明示的な所有権を管理を行うことになり、このためのコストが高くつく場合があります。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    In some cases (e.g. cyclic references), objects
                                    with shared ownership may never be deleted.
                                </span>
                                たとえば循環参照のように、所有権を共有されたオブジェクトが決してdeleteされない状態に陥ることがあります。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Smart pointers are not perfect substitutes for
                                    plain pointers.
                                </span>
                                スマートポインタは生のポインタに対する完璧な代替手段ではありません。
                            </span>
                        </li>
                    </ul>
                </div>

                <div class="decision">
                    <p>
                        <span>
                            <span class="src">
                                If dynamic allocation is necessary, prefer to keep
                                ownership with the code that allocated it.
                            </span>
                            動的なオブジェクトの確保が必要な場合、その所有権はそれを確保したコードが持つようにしましょう。
                        </span>
                        <span>
                            <span class="src">
                                If other code
                                needs access to the object, consider passing it a copy,
                                or passing a pointer or reference without transferring
                                ownership.
                            </span>
                            他のコードがそのオブジェクトにアクセスする必要がある場合は、単にオブジェクトのコピーを渡すか、所有権の移動なしにポインタや参照を渡す方法を検討してください。
                        </span>
                        <span>
                            <span class="src">
                                Prefer to use <code>std::unique_ptr</code> to
                                make ownership transfer explicit.
                            </span>
                            所有権の移動を明示的に行うためには、<code>std::unique_ptr</code>を使うようにしましょう。
                        </span>
                        <span>
                            <span class="src">
                                For example:
                            </span>
                            以下に例を示します。
                        </span>
                    </p>

<pre>std::unique_ptr&lt;Foo&gt; FooFactory();
void FooConsumer(std::unique_ptr&lt;Foo&gt; ptr);
</pre>

                    <p>
                        <span>
                            <span class="src">
                                Do not design your code to use shared ownership
                                without a very good reason.
                            </span>
                            非常に良い理由がない限り、オブジェクトの所有権を共有させるデザインにしてはいけません。
                        </span>
                        <span>
                            <span class="src">
                                One such reason is to avoid
                                expensive copy operations, but you should only do this if
                                the performance benefits are significant, and the
                                underlying object is immutable (i.e.
                                <code>std::shared_ptr&lt;const Foo&gt;</code>).
                            </span>
                            そのような理由としては、高価なコピーを避けるためといったものがあげられますが、所有権の共有は、パフォーマンス上の利益が大きく、かつ対象のオブジェクトが不変である場合にのみ行ってください(言い換えると、<code>std::shared_ptr&lt;const Foo&gt;</code>)。
                        </span>
                        <span>
                            <span class="src">
                                If you
                                do use shared ownership, prefer to use
                                <code>std::shared_ptr</code>.
                            </span>
                            所有権を共有したい場合、<code>std::shared_ptr</code>を使いましょう。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Never use <code>std::auto_ptr</code>.
                            </span>
                            <code>std::auto_ptr</code>を使ってはなりません。
                        </span>
                        <span>
                            <span class="src">
                                Instead, use
                                <code>std::unique_ptr</code>.
                            </span>
                            代わりに、<code>std::unique_ptr</code>を使いましょう。
                        </span>
                    </p>
                </div>

            </div>

            <h3 id="cpplint">
                <span title="cpplint">cpplint</span>
            </h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Use <code>cpplint.py</code>
                            to detect style errors.
                        </span>
                        スタイルに関する問題を検出するため、<code>cpplint.py</code>を使ってください。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <p>
                    <span>
                        <span class="src">
                            <code>cpplint.py</code>
                            is a tool that reads a source file and identifies many
                            style errors.
                        </span>
                        <code>cpplint.py</code>は、ソースファイルを読み、スタイルに関するたくさんのエラーを識別してくれるツールです。
                    </span>
                    <span>
                        <span class="src">
                            It is not perfect, and has both false
                            positives and false negatives, but it is still a valuable
                            tool.
                        </span>
                        このツールは完璧ではなく、誤診もありますが、それでも価値があります。
                    </span>
                    <span>
                        <span class="src">
                            False positives can be ignored by putting <code>
                                //
                                NOLINT
                            </code> at the end of the line or
                            <code>// NOLINTNEXTLINE</code> in the previous line.
                        </span>
                        偽陽性の診断される場合は、行末に<code>// NOLINT</code>を書くか、前の行に<code>// NOLINTNEXTLINE</code>を記載すれば、無視されます。
                    </span>
                </p>



                <p>
                    <span>
                        <span class="src">
                            Some projects have instructions on
                            how to run <code>cpplint.py</code> from their project
                            tools.
                        </span>
                        いくつかのプロジェクトにおいては、プロジェクトのツールから<code>cpplint.py</code>を起動するやり方が用意されています。
                    </span>
                    <span>
                        <span class="src">
                            If the project you are contributing to does not,
                            you can download
                            <a href="https://raw.githubusercontent.com/google/styleguide/gh-pages/cpplint/cpplint.py">
                                <code>cpplint.py</code>
                            </a> separately.
                        </span>
                        あなたのプロジェクトでそのような環境が用意されていない場合は<a href="https://raw.githubusercontent.com/google/styleguide/gh-pages/cpplint/cpplint.py"><code>cpplint.py</code></a>から個別にダウンロードすることができます。
                    </span>
                </p>

            </div>



            <h2 id="Other_C++_Features">
                <span title="Other C++ Features">その他のC++の機能</span>
            </h2>

            <h3 id="Rvalue_references">
                <span title="Rvalue References">右辺値参照</span>
            </h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Use rvalue references only to define move constructors and move assignment
                            operators, or for perfect forwarding.
                        </span>
                        右辺値参照はムーブコンストラクタとムーブ代入演算子を定義するときと、Perfect Forwardingを行う場合のみに使用できます。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        <span>
                            <span class="src">
                                Rvalue references
                                are a type of reference that can only bind to temporary
                                objects.
                            </span>
                            右辺値参照とは、一時オブジェクトにのみ紐付く参照のことです。
                        </span>
                        <span>
                            <span class="src">
                                The syntax is similar to traditional reference
                                syntax.
                            </span>
                            文法は従来からある参照に似ています。
                        </span>
                        <span>
                            <span class="src">
                                For example, <code>
                                    void f(string&amp;&amp;
                                    s);
                                </code> declares a function whose argument is an
                                rvalue reference to a string.
                            </span>
                            たとえば、<code>void f(string&amp;&amp; s);</code>は、stringの右辺値参照を引数にとる関数を宣言しています。
                        </span>
                    </p>
                </div>

                <div class="pros">
                    <ul>
                        <li>
                            <span>
                                <span class="src">
                                    Defining a move constructor (a constructor taking
                                    an rvalue reference to the class type) makes it
                                    possible to move a value instead of copying it.
                                </span>
                                ムーブコンストラクタ(クラスの右辺値参照をとるコンストラクタ)を定義すると、値をコピーではなくムーブすることができるようになります。
                            </span>
                            <span>
                                <span class="src">
                                    If
                                    <code>v1</code> is a <code>std::vector&lt;string&gt;</code>,
                                    for example, then <code>auto v2(std::move(v1))</code>
                                    will probably just result in some simple pointer
                                    manipulation instead of copying a large amount of data.
                                </span>
                                <code>v1</code>が<code>std::vector&lt;string&gt;</code>であるとき、たとえば、<code>auto v2(std::move(v1))</code>は、大量のデータをコピーする代わりに、単なるポインタ操作だけで済ませることができるでしょう。
                            </span>
                            <span>
                                <span class="src">
                                    In some cases this can result in a major performance
                                    improvement.
                                </span>
                                いくつかの場合において、これらは大きなパフォーマンス向上に繋がります。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Rvalue references make it possible to write a
                                    generic function wrapper that forwards its arguments to
                                    another function, and works whether or not its
                                    arguments are temporary objects. (This is sometimes called
                                    "perfect forwarding".)
                                </span>
                                右辺値参照によって、引数を転送(forward)する汎用的な関数のラッパーを書くことができるようになります。これは、引数が一時オブジェクトであるか否かにかかわらず動作します。これをPerfect Forwardingと呼ぶこともあります。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Rvalue references make it possible to implement
                                    types that are movable but not copyable, which can be
                                    useful for types that have no sensible definition of
                                    copying but where you might still want to pass them as
                                    function arguments, put them in containers, etc.
                                </span>
                                右辺値参照によって、ムーブはできるがコピーできない型を作ることができるようになります。このような型は、細やかなコピー操作の定義を持たないにも関わらず、関数の引数に渡したり、コンテナに格納したりできるため便利です。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    <code>std::move</code> is necessary to make
                                    effective use of some standard-library types, such as
                                    <code>std::unique_ptr</code>.
                                </span>
                                <code>std::move</code>は、<code>std::unique_ptr</code>のような、いくつかの標準ライブラリを効率的に使うために必要とされます。
                            </span>
                        </li>
                    </ul>
                </div>

                <div class="cons">
                    <ul>
                        <li>
                            <span>
                                <span class="src">
                                    Rvalue references are a relatively new feature
                                    (introduced as part of C++11), and not yet widely
                                    understood.
                                </span>
                                右辺値参照は、C++11の一部として導入された比較的新しい機能のため、まだ広く理解されていません。
                            </span>
                            <span>
                                <span class="src">
                                    Rules like reference collapsing, and
                                    automatic synthesis of move constructors, are
                                    complicated.
                                </span>
                                参照が破壊される、ムーブコンストラクタが自動生成されるなどのルールは難しいものです。
                            </span>
                        </li>
                    </ul>
                </div>

                <div class="decision">
                    <p>
                        <span>
                            <span class="src">
                                Use rvalue references only to define move constructors and move assignment
                                operators (as described in <a href="#Copyable_Movable_Types">
                                    Copyable and
                                    Movable Types
                                </a>) and, in conjunction with <code><a href="http://en.cppreference.com/w/cpp/utility/forward">std::forward</a></code>,
                                to support perfect forwarding.
                            </span>
                            右辺値参照は、ムーブコンストラクタ・ムーブ代入演算子(詳細は<a href="#Copyable_Movable_Types">コピー可能な型・ムーブ可能な型</a>)を定義するため、もしくは、Perfect Forwardingをサポートするために<a href="http://en.cppreference.com/w/cpp/utility/forward">std::forward</a>とあわせて使う場合にのみ使用してください。
                        </span>
                        <span>
                            <span class="src">
                                You may use <code>std::move</code> to express
                                moving a value from one object to another rather than copying it.
                            </span>
                            オブジェクトからオブジェクトへ、値が(コピーではなく)ムーブすることを表現するために<code>std::move</code>を使用しても構いません。
                        </span>
                    </p>
                </div>

            </div>

            <h3 id="Friends"><a title="Friends">フレンド</a></h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            We allow use of <code>friend</code> classes and functions,
                            within reason.
                        </span>
                        それが理に叶っている場合、<code>friend</code>クラスや<code>friend</code>関数を使用できます。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <p>
                    <span>
                        <span class="src">
                            Friends should usually be defined in the same file so
                            that the reader does not have to look in another file to
                            find uses of the private members of a class.
                        </span>
                        コードの読者が、クラスのprivateメンバーの扱い方を、他のファイルまで探しに行かなくてもいいように、通常は、クラスのフレンドは同じファイル内に定義してください。
                    </span>
                    <span>
                        <span class="src">
                            A common use
                            of <code>friend</code> is to have a
                            <code>FooBuilder</code> class be a friend of
                            <code>Foo</code> so that it can construct the inner state
                            of <code>Foo</code> correctly, without exposing this
                            state to the world.
                        </span>
                        <code>friend</code>のよくある使い方は、<code>FooBuilder</code>を<code>Foo</code>のフレンドにして、<code>FooBuilder</code>が<code>Foo</code>の内部状態を(publicに晒すことなく)正しく構築できるようにするといったようなものです。
                    </span>
                    <span>
                        <span class="src">
                            In some cases it may be useful to
                            make a unittest class a friend of the class it tests.
                        </span>
                        あるいは、クラスのユニットテストを行う別のクラスがフレンドに指定されていると便利な場合もあります。
                    </span>
                </p>

                <p>
                    <span>
                        <span class="src">
                            Friends extend, but do not break, the encapsulation
                            boundary of a class.
                        </span>
                        フレンドはクラスのカプセル化の壁を壊さないように拡張します。
                    </span>
                    <span>
                        <span class="src">
                            In some cases this is better than
                            making a member public when you want to give only one
                            other class access to it.
                        </span>
                        この方法は、クラスのメンバーをある特定のクラスにだけアクセスさせたい場合に、単にそれをpublicにするよりも優れています。
                    </span>
                    <span>
                        <span class="src">
                            However, most classes should
                            interact with other classes solely through their public
                            members.
                        </span>
                        しかし、ほとんどのクラスはpublicメンバを通してのみ他のクラスとやりとりすべきです。
                    </span>
                </p>

            </div>

            <h3 id="Exceptions"><span title="Exceptions">例外</span></h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            We do not use C++ exceptions.
                        </span>
                        C++の例外は使いません。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <div class="pros">
                    <ul>
                        <li>
                            <span>
                                <span class="src">
                                    Exceptions allow higher levels of an application to
                                    decide how to handle "can't happen" failures in deeply
                                    nested functions, without the obscuring and error-prone
                                    bookkeeping of error codes.
                                </span>
                                例外の仕組みを用いると、曖昧で取り違えやすいエラーコードの表を使わずに、深くネストされた関数の中で起きた「起こらないはずの」失敗に対する扱い方を、アプリケーションの高レベルの層で決めることができるようになります。
                            </span>
                        </li>



                        <li>
                            <span>
                                <span class="src">
                                    Exceptions are used by most other
                                    modern languages.
                                </span>
                                例外は、多くのモダンな言語で取り入れられています。
                            </span>
                            <span>
                                <span class="src">
                                    Using them in C++ would make it more
                                    consistent with Python, Java, and the C++ that others
                                    are familiar with.
                                </span>
                                C++でそれらを使えば、PythonやJavaやその他のC++に似た言語との一貫性が高くなります。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Some third-party C++ libraries use exceptions, and
                                    turning them off internally makes it harder to
                                    integrate with those libraries.
                                </span>
                                サードパーティのC++ライブラリの中には例外を使っているものもあります。例外を使わないと、それらのライブラリとの統合が難しくなります。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Exceptions are the only way for a constructor to
                                    fail.
                                </span>
                                例外はコンストラクタでおきた失敗を伝える唯一の方法です。
                            </span>
                            <span>
                                <span class="src">
                                    We can simulate this with a factory function or
                                    an <code>Init()</code> method, but these require heap
                                    allocation or a new "invalid" state, respectively.
                                </span>
                                コンストラクタの役割は、ファクトリ関数や<code>Init()</code>メソッドで担うこともできますが、その場合は、ヒープの確保を要したり、「不正」を表す新しい状態を必要としたりします。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Exceptions are really handy in testing
                                    frameworks.
                                </span>
                                例外はテストフレームワークにおいては非常に扱いやすいものです。
                            </span>
                        </li>
                    </ul>
                </div>

                <div class="cons">
                    <ul>
                        <li>
                            <span>
                                <span class="src">
                                    When you add a <code>throw</code> statement to an
                                    existing function, you must examine all of its
                                    transitive callers.
                                </span>
                                既に存在している関数に<code>throw</code>文を加えるときには、その関数の呼び出し元をすべてを確認しなくてはなりません。
                            </span>
                            <span>
                                <span class="src">
                                    Either they must make at least the
                                    basic exception safety guarantee, or they must never
                                    catch the exception and be happy with the program
                                    terminating as a result.
                                </span>
                                それらは、最低限の基本的な例外安全が保証しているか、あるいは、例外を一切キャッチせずに結果的にプログラムを終了させてしまうかのどちらかでしょう。
                            </span>
                            <span>
                                <span class="src">
                                    For instance, if
                                    <code>f()</code> calls <code>g()</code> calls
                                    <code>h()</code>, and <code>h</code> throws an
                                    exception that <code>f</code> catches, <code>g</code>
                                    has to be careful or it may not clean up properly.
                                </span>
                                たとえば、<code>f()</code>が<code>g()</code>を呼び、<code>g()</code>が<code>h()</code>を呼び出していて、<code>h</code>が例外を投げ<code>f</code>がキャッチするような場合においては、<code>g</code>を注意深く確かめないと、<code>g</code>の持つリソースが解放されないままになってしまうかもしれません。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    More generally, exceptions make the control flow of
                                    programs difficult to evaluate by looking at code:
                                    functions may return in places you don't expect.
                                </span>
                                より一般的には、例外を使用すると、プログラムのコードからコントロールフローを評価するのが難しくなります。
                            </span>
                            <span>
                                <span class="src">
                                    This
                                    causes maintainability and debugging difficulties.
                                </span>
                                これは、そのままメンテナンスやデバッグの難しさにつながります。
                            </span>
                            <span>
                                <span class="src">
                                    You
                                    can minimize this cost via some rules on how and where
                                    exceptions can be used, but at the cost of more that a
                                    developer needs to know and understand.
                                </span>
                                例外の扱い方に関するルールを設けることで、こういったコストは低くすることができるかもしれません。しかし、プログラマがそのルールを知り理解するためにはより多くのコストが掛かってしまいます。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Exception safety requires both RAII and different
                                    coding practices.
                                </span>
                                例外安全なプログラムを組むためには、RAIIとそれと異なるコーディングプラクティスとの両方を必要とします。
                            </span>
                            <span>
                                <span class="src">
                                    Lots of supporting machinery is
                                    needed to make writing correct exception-safe code
                                    easy.
                                </span>
                                例外安全なコードを正しく簡単に書けるようにするためには、それをサポートするための多くの仕組みが必要となります。
                            </span>
                            <span>
                                <span class="src">
                                    Further, to avoid requiring readers to understand
                                    the entire call graph, exception-safe code must isolate
                                    logic that writes to persistent state into a "commit"
                                    phase.
                                </span>
                                さらに、コードの読者に全体の呼び出しグラフを理解してもらう必要を避けるために、例外安全なコードはmust isolate
                                    logic that writes to persistent state into a "commit"
                                    phase.
                            </span>
                            <span>
                                <span class="src">
                                    This will have both benefits and costs (perhaps
                                    where you're forced to obfuscate code to isolate the
                                    commit).
                                </span>
                                これには、いい面と悪い面があるでしょう(おそらく、コミットを分離するために、コードをわかりにくくせざるを得なくなります)。
                            </span>
                            <span>
                                <span class="src">
                                    Allowing exceptions would force us to always
                                    pay those costs even when they're not worth it.
                                </span>
                                例外の使用を認めると、たとえ価値が見合わない場合ですら、常にこれらのコストを支払わないといけなくなってしまいます。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Turning on exceptions adds data to each binary
                                    produced, increasing compile time (probably slightly)
                                    and possibly increasing address space pressure.
                                </span>
                                例外を有効にすると、各バイナリにデータが追加され、(わずかですが)コンパイル時間が延びます。使用できるアドレス空間も減ることになるかもしれません。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    The availability of exceptions may encourage
                                    developers to throw them when they are not appropriate
                                    or recover from them when it's not safe to do so.
                                </span>
                                例外は、それが使えることで、本来適切でないときに例外を投げたり、安全でないにもかかわらず復旧を試みたりするようなことを、開発者に促してしまうかもしれません。
                            </span>
                            <span>
                                <span class="src">
                                    For
                                    example, invalid user input should not cause exceptions
                                    to be thrown.
                                </span>
                                たとえば、ユーザの入力が不正だった場合には、例外を投げるべきではありません。
                            </span>
                            <span>
                                <span class="src">
                                    We would need to make the style guide
                                    even longer to document these restrictions!
                                </span>
                                例外を認めると、このような制限を書くために、本ガイドをさらに長くしなくてはなりません。
                            </span>
                        </li>
                    </ul>
                </div>

                <div class="decision">
                    <p>
                        <span>
                            <span class="src">
                                On their face, the benefits of using exceptions
                                outweigh the costs, especially in new projects.
                            </span>
                            特に新しいプロジェクトの場合は、例外を扱うコストよりも、その恩恵が上回るでしょう。
                        </span>
                        <span>
                            <span class="src">
                                However,
                                for existing code, the introduction of exceptions has
                                implications on all dependent code.
                            </span>
                            しかし、既存のコードに例外を導入すると、すべての従属するコードに影響を及ぼします。
                        </span>
                        <span>
                            <span class="src">
                                If exceptions can be
                                propagated beyond a new project, it also becomes
                                problematic to integrate the new project into existing
                                exception-free code.
                            </span>
                            例外が新しいプロジェクトから波及してくる場合、そのプロジェクトを既存の例外安全なコードに統合するのが難しくなります。
                        </span>
                        <span>
                            <span class="src">
                                Because most existing C++ code at
                                Google is not prepared to deal with exceptions, it is
                                comparatively difficult to adopt new code that generates
                                exceptions.
                            </span>
                            GoogleのほとんどのC++コードは例外を扱えるように作られていないため、例外を生成する新しいコードに適応するのは非常に難しいことです。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Given that Google's existing code is not
                                exception-tolerant, the costs of using exceptions are
                                somewhat greater than the costs in a new project.
                            </span>
                            Googleの既存のコードは例外を許容できないため、例外を扱うコストは、新規プロジェクトのそれよりも、いくぶん大きいです。
                        </span>
                        <span>
                            <span class="src">
                                The
                                conversion process would be slow and error-prone.
                            </span>
                            それへの対応は遅く、ミスも起こしやすいでしょう。
                        </span>
                        <span>
                            <span class="src">
                                We
                                don't believe that the available alternatives to
                                exceptions, such as error codes and assertions, introduce
                                a significant burden.
                            </span>
                            私たちは、例外の代わりにエラーコードやアサーションといった代替品を使うことが、大きな負担になるとは考えていません。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Our advice against using exceptions is not predicated
                                on philosophical or moral grounds, but practical ones.
                            </span>
                            我々の例外の使用に対するアドバイスは、哲学的あるいは道徳的背景に基づくものではなく、あくまで実践的なものとしての話です。
                        </span>
                        <span>
                            <span class="src">
                                Because we'd like to use our open-source
                                projects at Google and it's difficult to do so if those
                                projects use exceptions, we need to advise against
                                exceptions in Google open-source projects as well.
                            </span>
                            我々は、Googleのオープンソースプロジェクトを使いたいのですが、もしそれらのプロジェクトが例外を使っていたら、そうするのは難しくなってしまいます。そのため、我々はGoogleのオープンソースプロジェクトに対しても、この例外に対するアドバイスをしています。
                        </span>
                        <span>
                            <span class="src">
                                Things would probably be different if we had to do it all
                                over again from scratch.
                            </span>
                            もし、スクラッチからすべてのことをやり直さなくてはならないのであれば、何かが違っていたかもしれません。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                This prohibition also applies to the exception-related
                                features added in C++11, such as <code>noexcept</code>,
                                <code>std::exception_ptr</code>, and
                                <code>std::nested_exception</code>.
                            </span>
                            この禁止はC++11で導入された例外に関連する機能(<code>noexcept</code>や<code>std::exception_ptr</code>、<code>std::nested_exception</code>など)についても同様に適用されます。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                There is an <a href="#Windows_Code">exception</a> to
                                this rule (no pun intended) for Windows code.
                            </span>
                            これらのルールには<a href="#Windows_Code">Windowsのコードに関する例外</a>があります(ダジャレじゃないですよ)。
                        </span>
                    </p>
                </div>

            </div>

            <h3 id="Run-Time_Type_Information__RTTI_"><span title="Run-Time Type Information (RTTI)">実行時型情報(RTTI)</span></h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Avoid using Run Time Type Information (RTTI).
                        </span>
                        実行時型情報(RTTI)は使わないでください。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        <span>
                            <span class="src">
                                RTTI allows a
                                programmer to query the C++ class of an object at run
                                time.
                            </span>
                            実行時型情報によって、実行時にオブジェクトの型を調べられるようになります。
                        </span>
                        <span>
                            <span class="src">
                                This is done by use of <code>typeid</code> or
                                <code>dynamic_cast</code>.
                            </span>
                            これは、<code>typeid</code>や<code>dynamic_cast</code>を使うことで行われます。
                        </span>
                    </p>
                </div>

                <div class="cons">
                    <p>
                        <span>
                            <span class="src">
                                Querying the type of an object at run-time frequently
                                means a design problem.
                            </span>
                            実行時にオブジェクトの型を調べるのは、大抵の場合、プログラムにデザイン上の問題があることを意味しています。
                        </span>
                        <span>
                            <span class="src">
                                Needing to know the type of an
                                object at runtime is often an indication that the design
                                of your class hierarchy is flawed.
                            </span>
                            実行時にオブジェクトの型を知る必要があるということは、クラス階層構造のデザインに欠陥があることを示しています。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Undisciplined use of RTTI makes code hard to maintain.
                            </span>
                            実行時型情報を雑に扱っていると、コードのメンテナンスが難しくなります。
                        </span>
                        <span>
                            <span class="src">
                                It can lead to type-based decision trees or switch
                                statements scattered throughout the code, all of which
                                must be examined when making further changes.
                            </span>
                            実行時型情報を扱うことで、型による分岐やswitch文がコード中に点在してしまうと、将来コードを変更したときに、それらのすべてを試験しなくてはならなくなってしまいます。
                        </span>
                    </p>
                </div>

                <div class="pros">
                    <p>
                        <span>
                            <span class="src">
                                The standard alternatives to RTTI (described below)
                                require modification or redesign of the class hierarchy
                                in question.
                            </span>
                            実行時型情報ではなく、その標準的な代替手段(後述します)を使うと、クラスの階層構造を変更したりデザインしなおしたりする必要があります。
                        </span>
                        <span>
                            <span class="src">
                                Sometimes such modifications are infeasible
                                or undesirable, particularly in widely-used or mature
                                code.
                            </span>
                            そして、特にそのコードが既に広く使われている場合、そのような変更を施すことは不可能、あるいは望ましくない場合場あります。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                RTTI can be useful in some unit tests.
                            </span>
                            実行時型情報はユニットテストにおいて都合が良い場合があります。
                        </span>
                        <span>
                            <span class="src">
                                For example, it
                                is useful in tests of factory classes where the test has
                                to verify that a newly created object has the expected
                                dynamic type.
                            </span>
                            たとえば、ファクトリクラスをテストする場合において、生成されたオブジェクトが正しい型であるか確認するためには、実行時型情報は有用です。
                        </span>
                        <span>
                            <span class="src">
                                It is also useful in managing the
                                relationship between objects and their mocks.
                            </span>
                            また、オブジェクトとそのモックとの関係を管理するのにも便利です。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                RTTI is useful when considering multiple abstract
                                objects.
                            </span>
                            実行時型情報は、多数の抽象オブジェクトを考えるときにも有用です。
                        </span>
                        <span>
                            <span class="src">
                                Consider
                            </span>
                            以下の例を見てください。
                        </span>
                    </p>

<pre>bool Base::Equal(Base* other) = 0;
bool Derived::Equal(Base* other) {
  Derived* that = dynamic_cast&lt;Derived*&gt;(other);
  if (that == NULL)
    return false;
  ...
}
</pre>
                </div>

                <div class="decision">
                    <p>
                        <span>
                            <span class="src">
                                RTTI has legitimate uses but is prone to abuse, so you
                                must be careful when using it.
                            </span>
                            実行時型情報には妥当な使い方もあります。ただ、その妥当性から逸脱した使われ方をする傾向もあります。実行時型情報を使うときには十分注意してください。
                        </span>
                        <span>
                            <span class="src">
                                You may use it freely in
                                unittests, but avoid it when possible in other code.
                            </span>
                            実行時型情報はユニットテストにおいては自由に使ってもかまいません。それ以外のコードにおいては可能な限り避けてください。
                        </span>
                        <span>
                            <span class="src">
                                In
                                particular, think twice before using RTTI in new code.
                            </span>
                            特に、新しいコードで実行時型情報を使おうとする前には、もう一度よく考えてください。
                        </span>
                        <span>
                            <span class="src">
                                If
                                you find yourself needing to write code that behaves
                                differently based on the class of an object, consider one
                                of the following alternatives to querying the type:
                            </span>
                            もし、オブジェクトの型によって動作が変わるようなコードを書く必要があるとわかったときには、次に示す代替手段を検討してください。
                        </span>
                    </p>

                    <ul>
                        <li>
                            <span>
                                <span class="src">
                                    Virtual methods are the preferred way of executing
                                    different code paths depending on a specific subclass
                                    type.
                                </span>
                                仮想関数を使えば、派生クラスの型によって実行するコードパスを変えることができます。
                            </span>
                            <span>
                                <span class="src">
                                    This puts the work within the object itself.
                                </span>
                               この方法は、分岐する処理をオブジェクト内に書くことができます。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    If the work belongs outside the object and instead
                                    in some processing code, consider a double-dispatch
                                    solution, such as the Visitor design pattern.
                                </span>
                                その作業がオブジェクト外に属しており、処理コードも多数ある場合、Visitorパターンのような二重ディスパッチが使えないかを検討してください。
                            </span>
                            <span>
                                <span class="src">
                                    This
                                    allows a facility outside the object itself to
                                    determine the type of class using the built-in type
                                    system.
                                </span>
                                この方法は、オブジェクトの外にある設備が、組み込みの型システムで、型を決定することができます。
                            </span>
                        </li>
                    </ul>

                    <p>
                        <span>
                            <span class="src">
                                When the logic of a program guarantees that a given
                                instance of a base class is in fact an instance of a
                                particular derived class, then a
                                <code>dynamic_cast</code> may be used freely on the
                                object.
                            </span>
                            プログラムの構造的に、ある基底クラスのインスタンスが特定の派生クラスのものであると保証されている場合、<code>dynamic_cast</code>を使うことができるでしょう。
                        </span>
                        <span>
                            <span class="src">
                                Usually one
                                can use a <code>static_cast</code> as an alternative in
                                such situations.
                            </span>
                            通常、このような場合においては、代替手段として<code>static_cast</code>を使うこともできます。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Decision trees based on type are a strong indication
                                that your code is on the wrong track.
                            </span>
                            型に基づく分岐が出てきたときには、そのコードは間違った方向に進んでいることを強く示しています。
                        </span>
                    </p>

<pre class="badcode">if (typeid(*data) == typeid(D1)) {
  ...
} else if (typeid(*data) == typeid(D2)) {
  ...
} else if (typeid(*data) == typeid(D3)) {
...
</pre>

                    <p>
                        <span>
                            <span class="src">
                                Code such as this usually breaks when additional
                                subclasses are added to the class hierarchy.
                            </span>
                            このようなコードは、大抵の場合、クラスの階層構造に新たな派生クラスが増えたときに崩壊してしまいます。
                        </span>
                        <span>
                            <span class="src">
                                Moreover,
                                when properties of a subclass change, it is difficult to
                                find and modify all the affected code segments.
                            </span>
                            また、派生クラスの性質が変わったときには、その影響があるすべてのコードを検索し、それを変更することも難しいでしょう。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Do not hand-implement an RTTI-like workaround.
                            </span>
                            実行時型情報のようなものを自前で実装するのもやめてください。
                        </span>
                        <span>
                            <span class="src">
                                The
                                arguments against RTTI apply just as much to workarounds
                                like class hierarchies with type tags.
                            </span>
                            ここまでしてきた実行時型情報に関する議論は、オブジェクトに型を表すタグをつけるような手法にも同様に当てはまります。
                        </span>
                        <span>
                            <span class="src">
                                Moreover,
                                workarounds disguise your true intent.
                            </span>
                            その上、このような手法は、あなたの真の意図を隠してしまいます。
                        </span>
                    </p>
                </div>

            </div>

            <h3 id="Casting"><span title="Casting">キャスト</span></h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Use C++-style casts
                            like <code>static_cast&lt;float&gt;(double_value)</code>, or brace
                            initialization for conversion of arithmetic types like
                            <code>int64 y = int64{1} &lt;&lt; 42</code>.
                        </span>
                        <code>static_cast&lt;float&gt;(double_value)</code>のようなC++スタイルのキャストや、<code>int64 y = int64{1} &lt;&lt; 42</code>のような算術型の変換には波括弧による初期化を使ってください。
                    </span>
                    <span>
                        <span class="src">
                            Do not use
                            cast formats like
                            <code>int y = (int)x</code> or <code>int y = int(x)</code> (but the latter
                            is okay when invoking a constructor of a class type).
                        </span>
                        <code>int y = (int)x</code>や<code>int y = int(x)</code>のようなキャストは使わないでください(ただし、クラスのコンストラクタを呼ぶ意図であれば後者はOKです)。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        <span>
                            <span class="src">
                                C++ introduced a
                                different cast system from C that distinguishes the types
                                of cast operations.
                            </span>
                            C++には、C言語とは異なり、操作の種類によって区別されるキャストの仕組みが導入されています。
                        </span>
                    </p>
                </div>

                <div class="pros">
                    <p>
                        <span>
                            <span class="src">
                                The problem with C casts is the ambiguity of the operation;
                                sometimes you are doing a <em>conversion</em>
                                (e.g., <code>(int)3.5</code>) and sometimes you are doing
                                a <em>cast</em> (e.g., <code>(int)"hello"</code>).
                            </span>
                            C言語のキャストの問題点は、操作が曖昧ということです。ときに<em>変換</em>(例:<code>(int)3.5</code>)であり、ときに<em>キャスト</em>(例:<code>(int)"hello"</code>)を表しています。
                        </span>
                        <span>
                            <span class="src">
                                Brace
                                initialization and C++ casts can often help avoid this
                                ambiguity.
                            </span>
                            波括弧による初期化とC++のキャストは、この曖昧さを回避するための役に立ちます。
                        </span>
                        <span>
                            <span class="src">
                                Additionally, C++ casts are more visible when searching for
                                them.
                            </span>
                            加えて、C++のキャストは検索性も高いです。
                        </span>
                    </p>
                </div>

                <div class="cons">
                    <p>
                        <span>
                            <span class="src">
                                The C++-style cast syntax is verbose and cumbersome.
                            </span>
                            C++のキャストは長くて面倒くさいです。
                        </span>
                    </p>
                </div>

                <div class="decision">
                    <p>
                        <span>
                            <span class="src">
                                Do not use C-style casts.
                            </span>
                            C言語スタイルのキャストを使わないでください。
                        </span>
                        <span>
                            <span class="src">
                                Instead, use these C++-style casts when
                                explicit type conversion is necessary.
                            </span>
                            明示的な型変換が必要な場合は、C言語スタイルのキャストの代わりに、C++スタイルのキャストを使ってください。
                        </span>
                    </p>

                    <ul>
                        <li>
                            <span>
                                <span class="src">
                                    Use brace initialization to convert arithmetic types
                                    (e.g. <code>int64{x}</code>).
                                </span>
                                算術型の変換には、波括弧による初期化を使用してください(例:<code>int64{x}</code>)。
                            </span>
                            <span>
                                <span class="src">
                                    This is the safest approach because code
                                    will not compile if conversion can result in information loss.
                                </span>
                                この方法は、型変換によって情報が失われる場合にコンパイルエラーとなるため、最も安全です。
                            </span>
                            <span>
                                <span class="src">
                                    The
                                    syntax is also concise.
                                </span>
                                文法も簡単です。
                            </span>
                        </li>



                        <li>
                            <span>
                                <span class="src">
                                    Use <code>static_cast</code> as the equivalent of a C-style cast
                                    that does value conversion, when you need to
                                    explicitly up-cast a pointer from a class to its superclass, or when
                                    you need to explicitly cast a pointer from a superclass to a
                                    subclass.
                                </span>
                                あるクラスのポインタを基底クラスのポインタに変換する明示的なアップキャストや、基底クラスのポインタを派生クラスのポインタに明示的にキャストするダウンキャストを行いたい場合には、値の変換を行うC言語スタイルのキャストと等価な、<code>static_cast</code>を使用してください。
                            </span>
                            <span>
                                <span class="src">
                                    In this last case, you must be sure your object is
                                    actually an instance of the subclass.
                                </span>
                                ダウンキャストを行う場合は、オブジェクトが実際にその派生クラスのインスタンスであることが確信できていないといけません。
                            </span>
                        </li>



                        <li>
                            <span>
                                <span class="src">
                                    Use <code>const_cast</code> to remove the
                                    <code>const</code> qualifier (see <a href="#Use_of_const">const</a>).
                                </span>
                                <code>const</code>修飾子(<a href="#Use_of_const">const</a>を参照)を外すためには<code>const_cast</code>を使用してください。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Use <code>reinterpret_cast</code> to do unsafe
                                    conversions of pointer types to and from integer and
                                    other pointer types.
                                </span>
                                ポインタ型と整数型や他の型のポインタ型との間で変換するような、安全でない変換を行う場合は<code>reinterpret_cast</code>を使用してください。
                            </span>
                            <span>
                                <span class="src">
                                    Use this only if you know what you
                                    are doing and you understand the aliasing issues.
                                </span>
                                ただし、<code>reinterpret_cast</code>は、あなたが何をしようとしているのかわかっていて、エイリアシングの問題についても十分理解している場合に限って使用するようにしてください。
                            </span>
                        </li>


                    </ul>

                    <p>
                        <span>
                            <span class="src">
                                See the <a href="#Run-Time_Type_Information__RTTI_">
                                    RTTI section
                                </a> for guidance on the use of
                                <code>dynamic_cast</code>.
                            </span>
                            <code>dynamic_cast</code>の扱い方については<a href="#Run-Time_Type_Information__RTTI_">実行時型情報のセクション</a>も参照してください。
                        </span>
                    </p>
                </div>

            </div>

            <h3 id="Streams"><span title="Streams">ストリーム</span></h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Use streams where appropriate, and stick to "simple"
                            usages.
                        </span>
                        ストリームは、それを使うのが適切な場合に、シンプルな使い方に限定して、使用してください。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        <span>
                            <span class="src">
                                Streams are the standard I/O abstraction in C++, as
                                exemplified by the standard header <code>&lt;iostream&gt;</code>.
                            </span>
                            ストリームは、標準ヘッダ<code>&lt;iostream&gt;</code>で例示されるように、C++における標準的な入出力の抽象概念です。
                        </span>
                        <span>
                            <span class="src">
                                They are widely used in Google code, but only for debug logging
                                and test diagnostics.
                            </span>
                            デバッグログやテスト診断のために限ってですが、Googleのコードでは広く使われています。
                        </span>
                    </p>
                </div>

                <div class="pros">
                    <p>
                        <span>
                            <span class="src">
                                The <code>&lt;&lt;</code> and <code>&gt;&gt;</code>
                                stream operators provide an API for formatted I/O that
                                is easily learned, portable, reusable, and extensible.
                            </span>
                            ストリーム演算子<code>&lt;&lt;</code>と<code>&gt;&gt;</code>はフォーマットされた入出力のためのAPIを提供します。これらは、学びやすく、移植性があり、再利用可能で拡張性もあります。
                        </span>
                        <span>
                            <span class="src">
                                <code>printf</code>, by contrast, doesn't even support
                                <code>string</code>, to say nothing of user-defined types,
                                and is very difficult to use portably.
                            </span>
                            <code>printf</code>は、それとは対照的に、<code>string</code>をサポートしませんし、ユーザ定義型もサポートしません。また、移植性の面では非常に難があります。
                        </span>
                        <span>
                            <span class="src">
                                <code>printf</code> also obliges you to choose among the
                                numerous slightly different versions of that function,
                                and navigate the dozens of conversion specifiers.
                            </span>
                            <code>printf</code>はまた、微妙に異なるたくさんの関数のバージョンがあり、さらに、たくさんの変換指定子があり、それらの中から適切なものを選ばなくてはなりません。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Streams provide first-class support for console I/O
                                via <code>std::cin</code>, <code>std::cout</code>,
                                <code>std::cerr</code>, and <code>std::clog</code>.
                            </span>
                            ストリームは、<code>std::cin</code>や<code>std::cout</code>、<code>std::cerr</code>、<code>std::clog</code>を通して、一級のコンソール入出力サポートを提供します。
                        </span>
                        <span>
                            <span class="src">
                                The C APIs do as well, but are hampered by the need to
                                manually buffer the input.
                            </span>
                            C言語のAPIでも同様のことができますが、入力は手動でバッファする必要があるため、面倒です。
                        </span>
                    </p>
                </div>

                <div class="cons">
                    <ul>
                        <li>
                            <span>
                                <span class="src">
                                    Stream formatting can be configured by mutating the
                                    state of the stream.
                                </span>
                                ストリームの書式化はストリームの状態を変更することで設定できます。
                            </span>
                            <span>
                                <span class="src">
                                    Such mutations are persistent, so
                                    the behavior of your code can be affected by the entire
                                    previous history of the stream, unless you go out of your
                                    way to restore it to a known state every time other code
                                    might have touched it.
                                </span>
                                この変更は持続するため、ストリームに関するあなたのコードの挙動は、他のコードがストリームに触れるたびに毎回それを既知の状態に戻す独自の方法でも踏まない限り、そこまでのストリーム操作の履歴すべての影響を受けることになります。
                            </span>
                            <span>
                                <span class="src">
                                    User code can not only modify the
                                    built-in state, it can add new state variables and behaviors
                                    through a registration system.
                                </span>
                                ユーザコードによって、組み込みの状態を変更することはできません。新しい状態変数や動作の追加は、登録の仕組みを通して行えます。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    It is difficult to precisely control stream output, due
                                    to the above issues, the way code and data are mixed in
                                    streaming code, and the use of operator overloading (which
                                    may select a different overload than you expect).
                                </span>
                                ストリームの出力を正確に制御するのは難しいです。ここまで述べた問題の他、ストリームを扱うコードにおいてはコードとデータが混ざり合ってしまうこと、さらに、演算子のオーバーロードの扱い方も関わっています(意図に反するオーバーロードが選択されてしまうかもしれません)。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    The practice of building up output through chains
                                    of <code>&lt;&lt;</code> operators interferes with
                                    internationalization, because it bakes word order into the
                                    code, and streams' support for localization is <a href="http://www.boost.org/doc/libs/1_48_0/libs/locale/doc/html/rationale.html#rationale_why">
                                        flawed
                                    </a>.
                                </span>
                                <code>&lt;&lt;</code>演算子による連結によって出力を構築する方法は、国際化対応を妨げます。なぜならば、このやり方は、語順を固定しなくてはならず、ストリームの多言語対応自体にも<a href="http://www.boost.org/doc/libs/1_48_0/libs/locale/doc/html/rationale.html#rationale_why">欠陥がある</a>からです。
                            </span>
                        </li>





                        <li>
                            <span>
                                <span class="src">
                                    The streams API is subtle and complex, so programmers must
                                    develop experience with it in order to use it effectively.
                                </span>
                                ストリームAPIは繊細で複雑なため、プログラマがそれらを効率的に扱うためにはストリームに関するそれなりの経験を要します。
                            </span>
                            <span>
                                <span class="src">
                                    However, streams were historically banned in Google code (except
                                    for logging and diagnostics), so Google engineers tend not to
                                    have that experience.
                                </span>
                                しかしながら、Googleのコードにおいては、歴史的にストリームは禁止されていました(ログと診断用のコードを除く)。このため、Googleのエンジニアはストリームにあまり詳しくない傾向があります。
                            </span>
                            <span>
                                <span class="src">
                                    Consequently, streams-based code is likely
                                    to be less readable and maintainable by Googlers than code based
                                    on more familiar abstractions.
                                </span>
                                したかって、Googleの人間にとっては、他の、より馴染み深い抽象概念に基づいているものと比べて、ストリームの概念に基づくコードは可読性やメンテナンス性が高くありません。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Resolving the many overloads of <code>&lt;&lt;</code> is
                                    extremely costly for the compiler.
                                </span>
                                <code>&lt;&lt;</code>演算子のたくさんのオーバーロードがある中から、それを解決するのは、コンパイラにとって非常にコストの掛かる仕事です。
                            </span>
                            <span>
                                <span class="src">
                                    When used pervasively in a
                                    large code base, it can consume as much as 20% of the parsing
                                    and semantic analysis time.
                                </span>
                                大きなコードベースであまねくそれが使われたとき、構文解析と意味解析の時間のうちの20％を消費し得ます。
                            </span>
                        </li>
                    </ul>
                </div>

                <div class="decision">
                    <p>
                        <span>
                            <span class="src">
                                Use streams only when they are the best tool for the job.
                            </span>
                            ストリームは、その仕事をするために、それが最適なツールとなる場合のみ使用してください。
                        </span>
                        <span>
                            <span class="src">
                                This is typically the case when the I/O is ad-hoc, local,
                                human-readable, and targeted at other developers rather than
                                end-users.
                            </span>
                            これは、典型的には、エンドユーザではなく、開発者たちのために、アドホックで、局所的で、ヒューマンリーダブルな入出力を行いたいときのことを指します。
                        </span>
                        <span>
                            <span class="src">
                                Be consistent with the code around you, and with the
                                codebase as a whole; if there's an established tool for
                                your problem, use that tool instead.
                            </span>
                            周りのコードやコードベース全体と一貫性を持たせてください。もし、この問題に対応するためのツールが既にあるのならば、それを使うようにしてください。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Avoid using streams for I/O that faces external users or
                                handles untrusted data.
                            </span>
                            ストリームを外部のユーザとの入出力のために使用してはいけません。また、ストリームでは信頼できないデータを扱ってはいけません。
                        </span>
                        <span>
                            <span class="src">
                                Instead, find and use the appropriate
                                templating libraries to handle issues like internationalization,
                                localization, and security hardening.
                            </span>
                            これら場合には、ストリームの代わりに、多言語化の問題に対応し、セキュリティに強固な、より適切なテンプレート化ライブラリを探して、それを使うようにしてください。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                If you do use streams, avoid the stateful parts of the
                                streams API (other than error state), such as <code>imbue()</code>,
                                <code>xalloc()</code>, and <code>register_callback()</code>.
                            </span>
                            ストリームを使うことにした場合でも、ストリームAPIのうち、エラー状態を除いて、ステートフルなものは使用しないでください。
                            たとえば、<code>imbue()</code>や<code>xalloc()</code>、<code>register_callback()</code>などが当てはまります。
                        </span>
                        <span>
                            <span class="src">
                                Use explicit formatting functions  rather than
                                stream manipulators or formatting flags to control formatting
                                details such as number base, precision, or padding.
                            </span>
                            基数や精度、出力幅などの制御のためには、マニピュレータやフラグではなく、明示的なフォーマット関数を使用してください。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Overload <code>&lt;&lt;</code> as a streaming operator
                                for your type only if your type represents a value, and
                                <code>&lt;&lt;</code> writes out a human-readable string
                                representation of that value.
                            </span>
                            独自の型でストリーム演算子として<code>&lt;&lt;</code>をオーバーロードしてよいのは、
                            その型が値を表現したものであり、かつ、<code>&lt;&lt;</code>がヒューマンリーダブルな文字列を出力する場合のみに限定してください。
                        </span>
                        <span>
                            <span class="src">
                                Avoid exposing implementation
                                details in the output of <code>&lt;&lt;</code>; if you need to print
                                object internals for debugging, use named functions instead
                                (a method named <code>DebugString()</code> is the most common
                                convention).
                            </span>
                            <code>&lt;&lt;</code>の出力で、クラスの内部実装を公開してしまわないようにしてください。オブジェクトの内部状態をデバッグのために出力したい場合は、名前をつけた関数を用意してください(慣習的には<code>DebugString()</code>という名前がもっともよく使われます)。
                        </span>
                    </p>
                </div>

            </div>

            <h3 id="Preincrement_and_Predecrement"><span title="Preincrement and Predecrement">前置インクリメントと前置デクリメント</span></h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Use prefix form (<code>++i</code>) of the increment and
                            decrement operators with iterators and other template
                            objects.
                        </span>
                        イテレータやテンプレートオブジェクトのインクリメントとデクリメント演算子は前置(<code>++i</code>)の形を使用してください。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        <span>
                            <span class="src">
                                When a variable
                                is incremented (<code>++i</code> or <code>i++</code>) or
                                decremented (<code>--i</code> or <code>i--</code>) and
                                the value of the expression is not used, one must decide
                                whether to preincrement (decrement) or postincrement
                                (decrement).
                            </span>
                            変数がインクリメント(<code>++i</code>もしくは<code>i++</code>)あるいはデクリメント(<code>--i</code>もしくは<code>i--</code>)され、かつ、その式の結果が使われないとき、前置インクリメント(デクリメント)を使うか後置インクリメント(デクリメント)を使うかを決めねばなりません。
                        </span>
                    </p>
                </div>

                <div class="pros">
                    <p>
                        <span>
                            <span class="src">
                                When the return value is ignored, the "pre" form
                                (<code>++i</code>) is never less efficient than the
                                "post" form (<code>i++</code>), and is often more
                                efficient.
                            </span>
                            式の結果が無視される場合、「前置」の形(<code>++i</code>)が「後置」(<code>i++</code>)よりも非効率になることはありません。そして大抵は前置のほうが効率的です。
                        </span>
                        <span>
                            <span class="src">
                                This is because post-increment (or decrement)
                                requires a copy of <code>i</code> to be made, which is
                                the value of the expression.
                            </span>
                            なぜならば、後置の形は、式の値となる<code>i</code>のコピーを作る必要があるためです。
                        </span>
                        <span>
                            <span class="src">
                                If <code>i</code> is an
                                iterator or other non-scalar type, copying <code>i</code>
                                could be expensive.
                            </span>
                            もし、<code>i</code>が、イテレータやスカラー値でない型の場合、<code>i</code>のコピーは高価になり得ます。
                        </span>
                        <span>
                            <span class="src">
                                Since the two types of increment
                                behave the same when the value is ignored, why not just
                                always pre-increment?
                            </span>
                            これら2種類のインクリメントは、式の値が無視される場合においてはまったく等価です。だったら、常に前置インクリメントだけを使わない理由が一体全体どこにあるっていうのさ？
                        </span>
                    </p>
                </div>

                <div class="cons">
                    <p>
                        <span>
                            <span class="src">
                                The tradition developed, in C, of using post-increment
                                when the expression value is not used, especially in
                                <code>for</code> loops.
                            </span>
                            C言語において、<code>for</code>ループなど、式の結果が使われないときは、伝統的に後置が使われていました。
                        </span>
                        <span>
                            <span class="src">
                                Some find post-increment easier
                                to read, since the "subject" (<code>i</code>) precedes
                                the "verb" (<code>++</code>), just like in English.
                            </span>
                            後置インクリメントは、英語と同じように、主語(<code>i</code>)の後に述語(<code>++</code>)と続くため、読みやすいと感じる人もいます。
                        </span>
                    </p>
                </div>

                <div class="decision">
                    <p>
                        <span>
                            <span class="src">
                                For simple scalar
                                (non-object) values there is no reason to prefer one form
                                and we allow either.
                            </span>
                            単純なスカラー(オブジェクトでない)の値については、1つの形に絞る理由がないため、どちらの形を使ってもかまいません。
                        </span>
                        <span>
                            <span class="src">
                                For iterators and other template
                                types, use pre-increment.
                            </span>
                            イテレータやその他の型については、前置を使用してください。
                        </span>
                    </p>
                </div>

            </div>

            <h3 id="Use_of_const"><span title="Use of const">constの使い方</span></h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Use <code>const</code> whenever it makes sense.
                        </span>
                        理にかなっているのならば、常に<code>const</code>を使ってください。
                    </span>
                    <span>
                        <span class="src">
                            With C++11,
                            <code>constexpr</code> is a better choice for some uses of
                            const.
                        </span>
                        C++11では、いくつかの<code>const</code>は、<code>constexpr</code>を使うほうがよりよい選択です。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        <span>
                            <span class="src">
                                Declared variables and parameters can be preceded
                                by the keyword <code>const</code> to indicate the variables
                                are not changed (e.g., <code>const int foo</code>).
                            </span>
                            変数や引数の宣言には、その変数が変更されないことを示すために、<code>const</code>キーワードを前置することができます(例:<code>const int foo</code>)。
                        </span>
                        <span>
                            <span class="src">
                                Class
                                functions can have the <code>const</code> qualifier to
                                indicate the function does not change the state of the
                                class member variables (e.g., <code>
                                    class Foo { int
                                    Bar(char c) const; };
                                </code>).
                            </span>
                            クラスのメンバ関数には、その関数がクラスのメンバ変数の状態を変更しないということを示すために、<code>const</code>修飾子を持つことができます(例:<code>class Foo { int Bar(char c) const; };</code>)。
                        </span>
                    </p>
                </div>

                <div class="pros">
                    <p>
                        <span>
                            <span class="src">
                                Easier for people to understand how variables are being
                                used.
                            </span>
                            constは変数の扱われ方に関する理解の助けとなります。
                        </span>
                        <span>
                            <span class="src">
                                Allows the compiler to do better type checking,
                                and, conceivably, generate better code.
                            </span>
                            constはコンパイラの型チェックを助け、場合によってはよりよいコードを生成できるようにします。
                        </span>
                        <span>
                            <span class="src">
                                Helps people
                                convince themselves of program correctness because they
                                know the functions they call are limited in how they can
                                modify your variables.
                            </span>
                            関数にconstがあることで、その関数が変数の変更に対して制限されていることがわかり、それはプログラムの正しさを納得するための助けになります。
                        </span>
                        <span>
                            <span class="src">
                                Helps people know what functions
                                are safe to use without locks in multi-threaded
                                programs.
                            </span>
                            constは、マルチスレッド下において、どの関数がロックなしで呼び出してもよいかを知る手助けにもなります。
                        </span>
                    </p>
                </div>

                <div class="cons">
                    <p>
                        <span>
                            <span class="src">
                                <code>const</code> is viral: if you pass a
                                <code>const</code> variable to a function, that function
                                must have <code>const</code> in its prototype (or the
                                variable will need a <code>const_cast</code>).
                            </span>
                            <code>const</code>は感染します。<code>const</code>な変数を関数に渡すとき、関数はそのプロトタイプで<code>const</code>を持っていなくてはなりません(あるいは、変数は<code>const_cast</code>される必要があるでしょう)。
                        </span>
                        <span>
                            <span class="src">
                                This can
                                be a particular problem when calling library
                                functions.
                            </span>
                            これは、特に、ライブラリ関数を呼び出すときに問題になることもあります。
                        </span>
                    </p>
                </div>

                <div class="decision">
                    <p>
                        <span>
                            <span class="src">
                                <code>const</code> variables, data members, methods
                                and arguments add a level of compile-time type checking;
                                it is better to detect errors as soon as possible.
                            </span>
                            <code>const</code>な変数、データメンバ、メンバ関数、引数は、コンパイル時に追加のチェックを行うことができ、これは問題の早期発見のために役立ちます。
                        </span>
                        <span>
                            <span class="src">
                                Therefore we strongly recommend that you use
                                <code>const</code> whenever it makes sense to do so:
                            </span>
                            このため、次のような場合を含め、適切な場合はいつでも<code>const</code>を使うのを強く推奨します。
                        </span>
                    </p>

                    <ul>
                        <li>
                            <span>
                                <span class="src">
                                    If a function guarantees that it will not modify an argument
                                    passed by reference or by pointer, the corresponding function parameter
                                    should be a reference-to-const (<code>const T&amp;</code>) or
                                    pointer-to-const (<code>const T*</code>), respectively.
                                </span>
                                関数が、参照渡しあるいはポインタ渡しされる引数を変更するつもりがない場合、その引数は、const参照(<code>const T&amp;</code>)かconstポインタ(<code>const T*</code>)でないといけません。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Declare methods to be <code>const</code> whenever
                                    possible.
                                </span>
                                メンバ関数は、可能な場合は常に、<code>const</code>で宣言します。
                            </span>
                            <span>
                                <span class="src">
                                    Accessors should almost always be
                                    <code>const</code>.
                                </span>
                                メンバ変数に対するGetterはほとんど常に<code>const</code>なはずです。
                            </span>
                            <span>
                                <span class="src">
                                    Other methods should be const if
                                    they do not modify any data members, do not call any
                                    non-<code>const</code> methods, and do not return a
                                    non-<code>const</code> pointer or
                                    non-<code>const</code> reference to a data member.
                                </span>
                                その他のメンバ関数は、いずれのデータメンバを変更しない、かつ、<code>const</code>でないメンバ関数を呼ばず、<code>const</code>でないポインタや<code>const</code>でない参照を返さない場合、<code>const</code>で宣言します。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Consider making data members <code>const</code>
                                    whenever they do not need to be modified after
                                    construction.
                                </span>
                                あるデータメンバがコンストラクタ以外で変更されない場合、常にそのデータメンバを<code>const</code>とすることを検討してください。
                            </span>
                        </li>
                    </ul>

                    <p>
                        <span>
                            <span class="src">
                                The <code>mutable</code> keyword is allowed but is
                                unsafe when used with threads, so thread safety should be
                                carefully considered first.
                            </span>
                            <code>mutable</code>キーワードも使用が認められていますが、複数のスレッドとともに扱われた場合安全ではなくなります。<code>mutable</code>キーワードをつける前に、スレッドセーフに関して十分検討してください。
                        </span>
                    </p>
                </div>

                <div class="stylepoint_subsection">
                    <h4><span title="Where to put the const">constをどこに置くか</span></h4>

                    <p>
                        <span>
                            <span class="src">
                                Some people favor the form <code>int const *foo</code>
                                to <code>const int* foo</code>.
                            </span>
                            プログラマの中には、<code>const int* foo</code>という形より<code>int const *foo</code>という形を好む人もいます。
                        </span>
                        <span>
                            <span class="src">
                                They argue that this is
                                more readable because it's more consistent: it keeps the
                                rule that <code>const</code> always follows the object
                                it's describing.
                            </span>
                            彼らの主張は「<code>const</code>は常にその特徴付けをするオブジェクトの後に続くというルールを一貫して保てるため、可読性が高い」というものです。
                        </span>
                        <span>
                            <span class="src">
                                However, this consistency argument
                                doesn't apply in codebases with few deeply-nested pointer
                                expressions since most <code>const</code> expressions
                                have only one <code>const</code>, and it applies to the
                                underlying value.
                            </span>
                            しかしながら、この一貫性に対する主張は、深くネストされたポインタの表現には適用されません。ほとんどの<code>const</code>表現は、1つの<code>const</code>のみが書かれ、それはポインタが指し示す値に対して適用されるからです。
                        </span>
                        <span>
                            <span class="src">
                                In such cases, there's no consistency
                                to maintain.
                            </span>
                            このような場合、もはや一貫性は保たれません。
                        </span>
                        <span>
                            <span class="src">
                                Putting the <code>const</code> first is
                                arguably more readable, since it follows English in
                                putting the "adjective" (<code>const</code>) before the
                                "noun" (<code>int</code>).
                            </span>
                            <code>const</code>を前置するほうが、おそらく可読性が高まります。これは、英語の文法の「形容詞(<code>const</code>)が名詞(<code>int</code>)の前にくる」と一致しているからです。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                That said, while we encourage putting
                                <code>const</code> first, we do not require it.
                            </span>
                            以上より、我々は、<code>const</code>を先に書くのを推奨しますが、これを必須のルールとはしません。
                        </span>
                        <span>
                            <span class="src">
                                But be
                                consistent with the code around you!
                            </span>
                            ただし、周囲のコードとの一貫性は保つようにしてください。
                        </span>
                    </p>
                </div>

            </div>

            <h3 id="Use_of_constexpr"><span title="Use of constexpr">constexprの使い方</span></h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            In C++11, use <code>constexpr</code> to define true
                            constants or to ensure constant initialization.
                        </span>
                        C++11では、真の定数を定義するときや、定数初期化を保証するときに、<code>constexpr</code>を使用してください。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        <span>
                            <span class="src">
                                Some variables can be declared <code>constexpr</code>
                                to indicate the variables are true constants, i.e. fixed at
                                compilation/link time.
                            </span>
                            変数を<code>constexpr</code>として宣言することで、それが真の定数(コンパイル時かリンク時に決定)されることを示すことができます。
                        </span>
                        <span>
                            <span class="src">
                                Some functions and constructors
                                can be declared <code>constexpr</code> which enables them
                                to be used in defining a <code>constexpr</code>
                                variable.
                            </span>
                            また、関数やコンストラクタをは<code>constexpr</code>として宣言することで、それを<code>constexpr</code>変数の定義のために使えるようにすることができます。
                        </span>
                    </p>
                </div>

                <div class="pros">
                    <p>
                        <span>
                            <span class="src">
                                Use of <code>constexpr</code> enables definition of
                                constants with floating-point expressions rather than
                                just literals; definition of constants of user-defined
                                types; and definition of constants with function
                                calls.
                            </span>
                            <code>constexpr</code>を使うことで、ただのリテラルではない浮動小数点式を定数として宣言できるようになります。また、<code>constexpr</code>によって、ユーザ定義の型を定数として宣言したり、関数呼び出しの結果を定数として定義することができるようになります。
                        </span>
                    </p>
                </div>

                <div class="cons">
                    <p>
                        <span>
                            <span class="src">
                                Prematurely marking something as constexpr may cause
                                migration problems if later on it has to be downgraded.
                            </span>
                            早まって何かをconstexprで宣言してしまうと、後でダウングレードする必要がでてきた場合、マイグレーション時の問題となるかもしれません。
                        </span>
                        <span>
                            <span class="src">
                                Current restrictions on what is allowed in constexpr
                                functions and constructors may invite obscure workarounds
                                in these definitions.
                            </span>
                            現時点では、関数やコンストラクタにconstexprをつけることが認められていますが、それによってそれらの定義に、まだあまり知られていない手法を引き込んでしまうかもしれません。
                        </span>
                    </p>
                </div>

                <div class="decision">
                    <p>
                        <span>
                            <span class="src">
                                <code>constexpr</code> definitions enable a more
                                robust specification of the constant parts of an
                                interface.
                            </span>
                            <code>constexpr</code>によって、インターフェースの定数に関する部分を、より堅牢なものにできます。
                        </span>
                        <span>
                            <span class="src">
                                Use <code>constexpr</code> to specify true
                                constants and the functions that support their
                                definitions.
                            </span>
                            真の定数を決めるときや、関数が真の定数の定義をサポートするときは、<code>constexpr</code>を使用してください。
                        </span>
                        <span>
                            <span class="src">
                                Avoid complexifying function definitions to
                                enable their use with <code>constexpr</code>.
                            </span>
                            ただし、<code>constexpr</code>を使いたいがためだけに、関数定義を複雑化させるのは避けてください。
                        </span>
                        <span>
                            <span class="src">
                                Do not use
                                <code>constexpr</code> to force inlining.
                            </span>
                            また、インライン化を強制する目的では<code>constexpr</code>を使用してはいけません。
                        </span>
                    </p>
                </div>

            </div>

            <h3 id="Integer_Types"><span title="Integer Types">整数型</span></h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Of the built-in C++ integer types, the only one used
                            is
                            <code>int</code>.
                        </span>
                        C++における組み込みの整数型の中で、最も使われているのは<code>int</code>です。
                    </span>
                    <span>
                        <span class="src">
                            If a program needs a variable of a
                            different size, use
                            a precise-width integer type from
                            <code>&lt;stdint.h&gt;</code>, such as
                            <code>int16_t</code>.
                        </span>
                        プログラムが異なるサイズの変数を必要とするときは、<code>&lt;stdint.h&gt;</code>から、<code>int16_t</code>のような、サイズが明示された整数型を使うようにしてください。
                    </span>
                    <span>
                        <span class="src">
                            If your variable represents a
                            value that could ever be greater than or equal to 2^31
                            (2GiB), use a 64-bit type such as
                            <code>int64_t</code>.
                        </span>
                        変数が、2^31 (2GiB)以上の値を示すかもしれない場合、<code>int64_t</code>のような64ビットの型を使ってください。
                    </span>
                    <span>
                        <span class="src">
                            Keep in mind that even if your value won't ever be too large
                            for an <code>int</code>, it may be used in intermediate
                            calculations which may require a larger type.
                        </span>
                        また、変数が<code>int</code>の範囲を超えることがないとわかっている場合でも、その中間の計算において、より大きな型が必要とされることもあるため、そのことを常に念頭に置くようにしてください。
                    </span>
                    <span>
                        <span class="src">
                            When in doubt,
                            choose a larger type.
                        </span>
                        迷ったときには大きな型を選んでください。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        <span>
                            <span class="src">
                                C++ does not specify the sizes of its integer types.
                            </span>
                            C++において、整数型のサイズは仕様として決められていません。
                        </span>
                        <span>
                            <span class="src">
                                Typically people assume that <code>short</code> is 16 bits,
                                <code>int</code> is 32 bits, <code>long</code> is 32 bits
                                and <code>long long</code> is 64 bits.
                            </span>
                            多くの場合、<code>short</code>が16ビット、<code>int</code>が32ビット、<code>long</code>が32ビット、<code>long long</code>は64ビットであると仮定されています。
                        </span>
                    </p>
                </div>

                <div class="pros">
                    <p>
                        <span>
                            <span class="src">
                                Uniformity of declaration.
                            </span>
                            宣言が画一的です。
                        </span>
                    </p>
                </div>

                <div class="cons">
                    <p>
                        <span>
                            <span class="src">
                                The sizes of integral types in C++ can vary based on
                                compiler and architecture.
                            </span>
                            C++における整数型のサイズは、そのコンパイラやアーキテクチャに基づいて異なります。
                        </span>
                    </p>
                </div>

                <div class="decision">

                    <p>
                        <span>
                            <span class="src">
                                <code>&lt;stdint.h&gt;</code> defines types
                                like <code>int16_t</code>, <code>uint32_t</code>,
                                <code>int64_t</code>, etc.
                            </span>
                            <code>&lt;stdint.h&gt;</code>は、<code>int16_t</code>や<code>uint32_t</code>、<code>int64_t</code>などのような型を定義しています。
                        </span>
                        <span>
                            <span class="src">
                                You should always use
                                those in preference to <code>short</code>, <code>
                                    unsigned
                                    long long
                                </code> and the like, when you need a guarantee
                                on the size of an integer.
                            </span>
                            整数型のサイズを保証する必要がある場合は、<code>short</code>や<code>unsigned long long</code>等ではなく、常に<code>int16_t</code>や<code>uint64_t</code>を優先して使ってください。
                        </span>
                        <span>
                            <span class="src">
                                Of the C integer types, only
                                <code>int</code> should be used.
                            </span>
                            C言語の整数型は、<code>int</code>のみが使用できます。
                        </span>
                        <span>
                            <span class="src">
                                When appropriate, you
                                are welcome to use standard types like
                                <code>size_t</code> and <code>ptrdiff_t</code>.
                            </span>
                            また、それが適切な場合は、<code>size_t</code>や<code>ptrdiff_t</code>などの標準の型を使用してもかまいません。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                We use <code>int</code> very often, for integers we
                                know are not going to be too big, e.g., loop counters.
                            </span>
                            たとえばループカウンタなど、そんなに大きくならないとわかっている整数について、<code>int</code>は非常によく使われます。
                        </span>
                        <span>
                            <span class="src">
                                Use plain old <code>int</code> for such things.
                            </span>
                            このような場合は、Plain Old な<code>int</code>を使ってください。
                        </span>
                        <span>
                            <span class="src">
                                You
                                should assume that an <code>int</code> is

                                at least 32 bits, but don't
                                assume that it has more than 32 bits.
                            </span>
                            <code>int</code>は最低でも32ビットあると仮定して構いません。
                            ただし、32ビットよりも大きいという仮定を行ってはいけません。
                        </span>
                        <span>
                            <span class="src">
                                If you need a 64-bit
                                integer type, use
                                <code>int64_t</code>
                                or
                                <code>uint64_t</code>.
                            </span>
                            もし64ビットの整数型を必要とする場合は、<code>int64_t</code>か<code>uint64_t</code>を使ってください。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                For integers we know can be "big",
                                use
                                <code>int64_t</code>.
                            </span>
                            大きくなるかもしれないことがわかっている整数については、<code>int64_t</code>を使ってください。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                You should not use the unsigned integer types such as
                                <code>uint32_t</code>, unless there is a valid
                                reason such as representing a bit pattern rather than a
                                number, or you need defined overflow modulo 2^N.
                            </span>
                            <code>uint32_t</code>等のunsignedな整数型は、明確な理由がない限り使用すべきではありません。たとえば、変数が数値ではなくビットパターンを表している場合や、意図的にオーバーフローさせて2^Nによる剰余がほしい場合などが当てはまります。
                        </span>
                        <span>
                            <span class="src">
                                In
                                particular, do not use unsigned types to say a number
                                will never be negative.
                            </span>
                            特に、整数が絶対に負にならないということを表す目的ではunsigned型を使ってはいけません。
                        </span>
                        <span>
                            <span class="src">
                                Instead, use
                                assertions for this.
                            </span>
                            そのような目的には、assertionを使用してください。
                        </span>
                    </p>



                    <p>
                        <span>
                            <span class="src">
                                If your code is a container that returns a size, be
                                sure to use a type that will accommodate any possible
                                usage of your container.
                            </span>
                            もしあなたがコンテナを作っているところで、そのサイズを返そうとしている場合には、そのコンテナがどのように扱われても対応できるであろう型を選んでください。
                        </span>
                        <span>
                            <span class="src">
                                When in doubt, use a larger type
                                rather than a smaller type.
                            </span>
                            迷ったら、小さな型よりも大きな型を使いましょう。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Use care when converting integer types.
                            </span>
                            整数型の変換には注意してください。
                        </span>
                        <span>
                            <span class="src">
                                Integer
                                conversions and promotions can cause non-intuitive
                                behavior.
                            </span>
                            整数型の変換や型の拡張は、ときに直感に反する挙動を示す場合があります。
                        </span>
                    </p>
                </div>

                <div class="stylepoint_subsection">

                    <h4><span title="On Unsigned Integers">unsignedな整数</span></h4>

                    <p>
                        <span>
                            <span class="src">
                                Some people, including some textbook authors,
                                recommend using unsigned types to represent numbers that
                                are never negative.
                            </span>
                            著名な本の著者も含めて、プログラマの中には、絶対に負の値をとらない変数にはunsignedな型を使うのを推奨する人もいます。
                        </span>
                        <span>
                            <span class="src">
                                This is intended as a form of
                                self-documentation.
                            </span>
                            これは、それ自体がドキュメントの働きをすることを狙ったものです。
                        </span>
                        <span>
                            <span class="src">
                                However, in C, the advantages of such
                                documentation are outweighed by the real bugs it can
                                introduce.
                            </span>
                            しかし、C言語においては、このようなドキュメント化のメリットよりも、現実のバグを引き込むリスクの方が高いです。
                        </span>
                        <span>
                            <span class="src">
                                Consider:
                            </span>
                            次のコードを考えてみてください。
                        </span>
                    </p>

<pre>for (unsigned int i = foo.Length()-1; i &gt;= 0; --i) ...
</pre>

                    <p>
                        <span>
                            <span class="src">
                                This code will never terminate!
                            </span>
                            そう、無限ループです。
                        </span>
                        <span>
                            <span class="src">
                                Sometimes gcc will
                                notice this bug and warn you, but often it will not.
                            </span>
                            GCCはこのようなバグに気づいて警告してくれることもありますが、してくれないことも多いです。
                        </span>
                        <span>
                            <span class="src">
                                Equally bad bugs can occur when comparing signed and
                                unsigned variables.
                            </span>
                            同様の残念なバグは、signed変数とunsigned変数との比較でも発生し得ます。
                        </span>
                        <span>
                            <span class="src">
                                Basically, C's type-promotion scheme
                                causes unsigned types to behave differently than one
                                might expect.
                            </span>
                            基本的に、C言語の型の拡張のスキームは、unsigned型に対して期待していたものとは異なる動作を引き起こします。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                So, document that a variable is non-negative using
                                assertions.
                            </span>
                            変数が負にならないことをドキュメント化するためには、assertionを使ってください。
                        </span>
                        <span>
                            <span class="src">
                                Don't use an unsigned
                                type.
                            </span>
                            unsigned型は使ってはいけません。
                        </span>
                    </p>
                </div>

            </div>

            <h3 id="64-bit_Portability"><span title="64-bit Portability">64ビットへの移植性</span></h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Code should be 64-bit and 32-bit friendly.
                        </span>
                        コードは64ビットと32ビットの両方にフレンドリーであるべきです。
                    </span>
                    <span>
                        <span class="src">
                            Bear in mind
                            problems of printing, comparisons, and structure alignment.
                        </span>
                        printするとき、比較するとき、構造体のアラインメントの問題を常に心にとめておいてください。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <ul>
                    <li>
                        <p>
                            <span>
                                <span class="src">
                                    <code>printf()</code> specifiers for some types
                                    are not cleanly portable between 32-bit and 64-bit
                                    systems.
                                </span>
                                <code>printf()</code>の仕様は、32ビットシステムと64ビットシステムの間で、きれいに互換がとれていません。
                            </span>
                            <span>
                                <span class="src">
                                    C99 defines some portable format specifiers.
                                </span>
                                C99で、移植性のあるいくつか書式指定子の定義が行われました。
                            </span>
                            <span>
                                <span class="src">
                                    Unfortunately, MSVC 7.1 does not understand some of
                                    these specifiers and the standard is missing a few,
                                    so we
                                    have to define our own ugly versions in some cases
                                    (in the style of the standard include file
                                    <code>inttypes.h</code>):
                                </span>
                                しかし、MSVC 7.1はそれらの仕様を理解せず、標準的なものもいくつか欠けています。そこで、我々は、以下に示すような、独自の醜いバージョンを定義する必要がありました(標準インクルードファイルである<code>inttypes.h</code>と同じスタイル):。
                            </span>
                        </p>

                        <div>
                            <span>
                                <span class="src">
                                    <pre>// printf macros for size_t, in the style of inttypes.h
#ifdef _LP64
#define __PRIS_PREFIX "z"
#else
#define __PRIS_PREFIX
#endif

// Use these macros after a % in a printf format string
// to get correct 32/64 bit behavior, like this:
// size_t size = records.size();
// printf("%" PRIuS "\n", size);

#define PRIdS __PRIS_PREFIX "d"
#define PRIxS __PRIS_PREFIX "x"
#define PRIuS __PRIS_PREFIX "u"
#define PRIXS __PRIS_PREFIX "X"
#define PRIoS __PRIS_PREFIX "o"
  </pre>
                                </span>
                                <pre>// size_t の printf 用マクロ
#ifdef _LP64
#define __PRIS_PREFIX "z"
#else
#define __PRIS_PREFIX
#endif

// これらのマクロを、printfの書式指定文字列の中の%の後ろで使うことで、
// 32ビットと64ビットで正しい挙動が得られる。
// 例: 
//   size_t size = records.size();
//   printf("%" PRIuS "\n", size);

#define PRIdS __PRIS_PREFIX "d"
#define PRIxS __PRIS_PREFIX "x"
#define PRIuS __PRIS_PREFIX "u"
#define PRIXS __PRIS_PREFIX "X"
#define PRIoS __PRIS_PREFIX "o"
  </pre>
                            </span>
                        </div>

                        <table border="1" summary="portable printf specifiers">
                            <tbody>
                                <tr align="center">
                                    <th><span title="Type">型</span></th>
                                    <th><span title="DO NOT use">使わない</span></th>
                                    <th><span title="DO use">使う</span></th>
                                    <th><span title="Notes">備考</span></th>
                                </tr>

                                <tr align="center">
                                    <td>
                                        <code>void *</code> (or any pointer)
                                    </td>
                                    <td>
                                        <code>%lx</code>
                                    </td>
                                    <td>
                                        <code>%p</code>
                                    </td>
                                    <td></td>
                                </tr>



                                <tr align="center">
                                    <td>
                                        <code>int64_t</code>
                                    </td>
                                    <td>
                                        <code>%qd</code>,
                                        <code>%lld</code>
                                    </td>
                                    <td>
                                        <code>%" PRId64 "</code>
                                    </td>
                                    <td></td>
                                </tr>



                                <tr align="center">
                                    <td>
                                        <code>uint64_t</code>
                                    </td>
                                    <td>
                                        <code>%qu</code>,
                                        <code>%llu</code>,
                                        <code>%llx</code>
                                    </td>
                                    <td>
                                        <code>%" PRIu64 "</code>,
                                        <code>%" PRIx64 "</code>
                                    </td>
                                    <td></td>
                                </tr>



                                <tr align="center">
                                    <td>
                                        <code>size_t</code>
                                    </td>
                                    <td>
                                        <code>%u</code>
                                    </td>
                                    <td>
                                        <code>%" PRIuS "</code>,
                                        <code>%" PRIxS "</code>
                                    </td>
                                    <td>
                                        <span title="C99 specifies">C99の仕様では</span>
                                        <code>%zu</code>
                                    </td>
                                </tr>

                                <tr align="center">
                                    <td>
                                        <code>ptrdiff_t</code>
                                    </td>
                                    <td>
                                        <code>%d</code>
                                    </td>
                                    <td>
                                        <code>%" PRIdS "</code>
                                    </td>
                                    <td>
                                        <span title="C99 specifies">C99の仕様では</span>
                                        <code>%td</code>
                                    </td>
                                </tr>


                            </tbody>
                        </table>

                        <p>
                            <span>
                                <span class="src">
                                    Note that the <code>PRI*</code> macros expand to
                                    independent strings which are concatenated by the
                                    compiler.
                                </span>
                                各<code>PRI*</code>マクロは、独立した文字列に展開され、コンパイラにより連結されます。
                            </span>
                            <span>
                                <span class="src">
                                    Hence if you are using a non-constant
                                    format string, you need to insert the value of the
                                    macro into the format, rather than the name.
                                </span>
                                ゆえに、書式指定文字列にリテラルを使っていない場合は、マクロの名前ではなく、マクロを展開した値を挿入する必要があります。
                            </span>
                            <span>
                                <span class="src">
                                    Note also
                                    that spaces are required around the macro identifier to
                                    separate it from the string literal.
                                </span>
                                また、マクロの識別子の前後には、文字列リテラルと分離するためのスペースが必要なことも注意してください。
                            </span>
                            <span>
                                <span class="src">
                                    It is
                                    still possible, as usual, to include length
                                    specifiers, etc., after the <code>%</code> when using
                                    the <code>PRI*</code> macros.
                                    
                                </span>
                                これらを使う場合でも、普段通り、幅指定子などを含めることができます。<code>%</code>の後ろに、<code>PRI*</code>を使う前に挿入します。
                            </span>
                            <span>
                                <span class="src">
                                    So, e.g.
                                    <code>printf("x = %30" PRIuS "\n", x)</code> would
                                    expand on 32-bit Linux to <code>
                                        printf("x = %30" "u"
                                        "\n", x)
                                    </code>, which the compiler will treat as
                                    <code>printf("x = %30u\n", x)</code>.
                                </span>
                                たとえば、 <code>printf("x = %30" PRIuS "\n", x)</code>は、32ビットのLinuxでは、<code>printf("x = %30" "u" "\n", x)</code>と展開され、コンパイラはこれを<code>printf("x = %30u\n", x)</code>として扱うでしょう。
                            </span>
                        </p>



                    </li>

                    <li>
                        <span>
                            <span class="src">
                                Remember that <code>sizeof(void *)</code> !=
                                <code>sizeof(int)</code>.
                            </span>
                            <code>sizeof(void *)</code> != <code>sizeof(int)</code>であることを忘れないでください。
                        </span>
                        <span>
                            <span class="src">
                                Use <code>intptr_t</code> if
                                you want a pointer-sized integer.
                            </span>
                            ポインタと同じサイズの整数が必要なときは、<code>intptr_t</code>を使ってください。
                        </span>
                    </li>

                    <li>
                        <span>
                            <span class="src">
                                You may need to be careful with structure
                                alignments, particularly for structures being stored on
                                disk.
                            </span>
                            構造体のアラインメントに注意を払う必要があります(特に、構造体がディスクに保存される場合)。
                        </span>
                        <span>
                            <span class="src">
                                Any class/structure with a
                                <code>int64_t</code>/<code>uint64_t</code>
                                member will by default end up being 8-byte aligned on a
                                64-bit system.
                            </span>
                            64ビットシステムにおいて、<code>int64_t</code>か<code>uint64_t</code>を含むクラスや構造体は、デフォルトでは8バイト境界にアラインメントされます。
                        </span>
                        <span>
                            <span class="src">
                                If you have such structures being shared
                                on disk between 32-bit and 64-bit code, you will need
                                to ensure that they are packed the same on both
                                architectures.
                            </span>
                            もし、このような構造体をディスクに保存して32ビットのコードと64ビットのコードで共有する場合、両方のアーキテクチャで同じようにパックされることを保証する必要があるでしょう。
                        </span>
                        <span>
                            <span class="src">
                                Most compilers offer a way to
                                alter structure alignment.
                            </span>
                            ほとんどのコンパイラは、構造体のアラインメントを変える手段を提供しています。
                        </span>
                        <span>
                            <span class="src">
                                For gcc, you can use
                                <code>__attribute__((packed))</code>.
                            </span>
                            GCCでは、<code>__attribute__((packed))</code>が使えます。
                        </span>
                        <span>
                            <span class="src">
                                MSVC offers
                                <code>#pragma pack()</code> and
                                <code>__declspec(align())</code>.
                            </span>
                            MSVCは<code>#pragma pack()</code>と<code>__declspec(align())</code>を提供しています。
                        </span>
                    </li>

                    <li>
                        <p>
                            <span>
                                <span class="src">
                                    Use the <code>LL</code> or <code>ULL</code>
                                    suffixes as needed to create 64-bit constants.
                                </span>
                                64ビット定数を作るためには、<code>LL</code>か<code>ULL</code>といった接頭辞を使ってください。
                            </span>
                            <span>
                                <span class="src">
                                    For
                                    example:
                                </span>
                                例を挙げます。
                            </span>
                    </p>


<pre>int64_t my_value = 0x123456789LL;
uint64_t my_mask = 3ULL &lt;&lt; 48;
</pre>
                    </li>
                </ul>

            </div>

            <h3 id="Preprocessor_Macros"><span title="Preprocessor Macros">プリプロセッサマクロ</span></h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Avoid defining macros, especially in headers; prefer
                            inline functions, enums, and <code>const</code> variables.
                        </span>
                        マクロを定義してはいけません(特にヘッダでは)。
                        インライン関数や、列挙型、<code>const</code>変数を使いましょう。
                    </span>
                    <span>
                        <span class="src">
                            Name macros with a project-specific prefix.
                        </span>
                        マクロの名前にはプロジェクト固有の接頭辞をつけてください。
                    </span>
                    <span>
                        <span class="src">
                            Do not use
                            macros to define pieces of a C++ API.
                        </span>
                        C++ APIを定義するために、マクロを使わないでください。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <p>
                    <span>
                        <span class="src">
                            Macros mean that the code you see is not the same as
                            the code the compiler sees.
                        </span>
                        マクロによって、あなたが見ているコードとコンパイラから見たコードが同じではなくなります。
                    </span>
                    <span>
                        <span class="src">
                            This can introduce unexpected
                            behavior, especially since macros have global scope.
                        </span>
                        これによって、特に、マクロがグローバルスコープのとき、意図しない挙動を引き起こすことがあります。
                    </span>
                </p>

                <p>
                    <span>
                        <span class="src">
                            The problems introduced by macros are especially severe
                            when they are used to define pieces of a C++ API,
                            and still more so for public APIs.
                        </span>
                        マクロによって引き起こされる問題は、特に、マクロがC++APIとして、特にpublicなAPIとして定義されたときに重大です。
                    </span>
                    <span>
                        <span class="src">
                            Every error message from
                            the compiler when developers incorrectly use that interface
                            now must explain how the macros formed the interface.
                        </span>
                        開発者がインターフェースの使い方を間違えたときのコンパイラからのエラーメッセージは、マクロがどのようにインターフェースを形成しているかを説明しなくてはなりません。
                    </span>
                    <span>
                        <span class="src">
                            Refactoring and analysis tools have a dramatically harder
                            time updating the interface.
                        </span>
                        リファクタリングや解析のツールはインターフェースを更新するために劇的な時間が掛かるようになります。
                    </span>
                    <span>
                        <span class="src">
                            As a consequence, we
                            specifically disallow using macros in this way.
                        </span>
                        以上のことより、我々は明確に、マクロをこの方法で使用することを禁止します。
                    </span>
                    <span>
                        <span class="src">
                            For example, avoid patterns like:
                        </span>
                        たとえば、避けるべきパターンは次の通りです。
                    </span>
                </p>

<pre class="badcode">class WOMBAT_TYPE(Foo) {
  // ...

 public:
  EXPAND_PUBLIC_WOMBAT_API(Foo)

  EXPAND_WOMBAT_COMPARISONS(Foo, ==, &lt;)
};
</pre>

                <p>
                    <span>
                        <span class="src">
                            Luckily, macros are not nearly as necessary in C++ as
                            they are in C.
                        </span>
                        幸いにも、C++はC言語ほどマクロを必要としません。
                    </span>
                    <span>
                        <span class="src">
                            Instead of using a macro to inline
                            performance-critical code, use an inline function.
                        </span>
                        パフォーマンスクリティカルなコードをインライン化する時には、マクロではなくインライン関数を使ってください。
                    </span>
                    <span>
                        <span class="src">
                            Instead of using a macro to store a constant, use a
                            <code>const</code> variable.
                        </span>
                        定数を保存するためには、マクロではなく<code>const</code>変数を使ってください。
                    </span>
                    <span>
                        <span class="src">
                            Instead of using a macro to
                            "abbreviate" a long variable name, use a reference.
                        </span>
                        長い名前の変数の短縮形を作るためには、マクロではなく参照を使ってください。
                    </span>
                    <span>
                        <span class="src">
                            Instead of using a macro to conditionally compile code
                            ... well, don't do that at all (except, of course, for
                            the <code>#define</code> guards to prevent double
                            inclusion of header files).
                        </span>
                        状況によってコンパイルされるコードを変えるためには、マクロではなく……いや、そもそもそんなことをしてはいけません(もちろん、多重インクルードを防ぐためのインクルードガードは例外です)。
                    </span>
                    <span>
                        <span class="src">
                            It makes testing much more
                            difficult.
                        </span>
                        そのようなことをすると、テストが非常に難しくなります。
                    </span>
                </p>

                <p>
                    <span>
                        <span class="src">
                            Macros can do things these other techniques cannot,
                            and you do see them in the codebase, especially in the
                            lower-level libraries.
                        </span>
                        マクロは他の方法ではできないことを実現できるため、既存のコードベースにおいて、特に低レベルなライブラリでそれらを見かけることがあるかもしれません。
                    </span>
                    <span>
                        <span class="src">
                            And some of their special features
                            (like stringifying, concatenation, and so forth) are not
                            available through the language proper.
                        </span>
                        さらに、マクロには、文字列化や連結など特別な機能があり、それらの機能は言語では提供されません。
                    </span>
                    <span>
                        <span class="src">
                            But before using a
                            macro, consider carefully whether there's a non-macro way
                            to achieve the same result.
                        </span>
                        ただし、マクロを使う前に、マクロではない方法で同じ結果を達成する方法がないかよく検討してください。
                    </span>
                    <span>
                        <span class="src">
                            If you need to use a macro to
                            define an interface, contact
                            your project leads to request
                            a waiver of this rule.
                        </span>
                        もし、マクロを使ってインターフェースを定義する必要が生じた場合は、このルールを破棄するために、プロジェクトリーダーと相談してください。
                    </span>
                </p>

                <p>
                    <span>
                        <span class="src">
                            The following usage pattern will avoid many problems
                            with macros; if you use macros, follow it whenever
                            possible:
                        </span>
                        以下に示すようなマクロの使い方をすれば、多くの問題を避けることができます。マクロを定義しようとするときは可能な限りこれらに従ってください。
                    </span>
                </p>

                <ul>
                    <li>
                        <span>
                            <span class="src">
                                Don't define macros in a <code>.h</code> file.
                            </span>
                            <code>.h</code>ファイルでは、マクロを定義してはいけません。
                        </span>
                    </li>

                    <li>
                        <span>
                            <span class="src">
                                <code>#define</code> macros right before you use
                                them, and <code>#undef</code> them right after.
                            </span>
                            マクロは使う直前に<code>#define</code>し、使い終わったらすぐに<code>#undef</code>してください。
                        </span>
                    </li>

                    <li>
                        <span>
                            <span class="src">
                                Do not just <code>#undef</code> an existing macro
                                before replacing it with your own; instead, pick a name
                                that's likely to be unique.
                            </span>
                            既存のマクロを自分のものに置き換えるために、<code>#undef</code>してはいけません。
                            代わりに、あなたのマクロにユニークとなる前をつけてください。
                        </span>
                    </li>

                    <li>
                        <span>
                            <span class="src">
                                Try not to use macros that expand to unbalanced C++
                                constructs, or at least document that behavior
                                well.
                            </span>
                            C++の偏った構造を拡張するためにマクロを使おうとしないでください。あるいは、少なくとも、その挙動について十分なドキュメント化を行ってください。
                        </span>
                    </li>

                    <li>
                        <span>
                            <span class="src">
                                Prefer not using <code>##</code> to generate
                                function/class/variable names.
                            </span>
                            関数名やクラス名、変数名を生成するために<code>##</code>を使うのはやめましょう。
                        </span>
                    </li>
                </ul>

                <p>
                    <span>
                        <span class="src">
                            Exporting macros from headers (i.e. defining them in a header
                            without <code>#undef</code>ing them before the end of the header)
                            is extremely strongly discouraged.
                        </span>
                        ヘッダからマクロをエクスポートする(言い換えると、ヘッダでマクロを定義し、そのヘッダの終わりまで<code>#undef</code>しない)ことは、非常に強く非推奨です。 </span>
                    <span>
                        <span class="src">
                            If you do export a macro from a
                            header, it must have a globally unique name.
                        </span>
                        もし、そのようなマクロをヘッダからエクスポートする場合は、グローバルにユニークな名前でなくてはなりません。
                    </span>
                    <span>
                        <span class="src">
                            To achieve this, it
                            must be named with a prefix consisting of your project's namespace
                            name (but upper case).
                        </span>
                        そのため、必ずプロジェクトのnamespaceの名前を(すべて大文字で)マクロ名の頭につけるようにしてください。
                    </span>
                </p>

            </div>

            <h3 id="0_and_nullptr/NULL"><span title="0 and nullptr/NULL">0とnullptrとNULL</span></h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Use <code>0</code> for integers, <code>0.0</code> for
                            reals, <code>nullptr</code> (or <code>NULL</code>) for
                            pointers, and <code>'\0'</code> for chars.
                        </span>
                        整数には<code>0</code>、実数には<code>0.0</code>、ポインタには<code>nullptr</code>(か、<code>NULL</code>)、文字には<code>'\0'</code>を使ってください。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <p>
                    <span>
                        <span class="src">
                            Use <code>0</code> for integers and <code>0.0</code>
                            for reals.
                        </span>
                        整数には<code>0</code>、実数には<code>0.0</code>を使ってください。
                    </span>
                    <span>
                        <span class="src">
                            This is not controversial.
                        </span>
                        ここに議論の余地はありません。
                    </span>
                </p>

                <p>
                    <span>
                        <span class="src">
                            For
                            pointers (address values), there is a choice between
                            <code>0</code>, <code>NULL</code>, and
                            <code>nullptr</code>.
                        </span>
                        ポインタ(やアドレス)には、<code>0</code>か<code>NULL</code>か<code>nullptr</code>かという選択があります。
                    </span>
                    <span>
                        <span class="src">
                            For projects that allow C++11
                            features, use <code>nullptr</code>.
                        </span>
                        C++11が使えるプロジェクトにおいては、<code>nullptr</code>を使ってください。
                    </span>
                    <span>
                        <span class="src">
                            For C++03 projects,
                            we prefer <code>NULL</code> because it looks like a
                            pointer.
                        </span>
                        C++03のプロジェクトでは、見た目にポインタとわかるようにするため、<code>NULL</code>を使いましょう。
                    </span>
                    <span>
                        <span class="src">
                            In fact, some C++ compilers provide special
                            definitions of <code>NULL</code> which enable them to
                            give useful warnings, particularly in situations where
                            <code>sizeof(NULL)</code> is not equal to
                            <code>sizeof(0)</code>.
                        </span>
                        実際には、いくつかのC++コンパイラは、<code>NULL</code>の特別な定義を提供しており、特に、<code>sizeof(NULL)</code>と<code>sizeof(0)</code>とが一致しない場合などにおいて、有用な警告を発してくれます。
                    </span>
                </p>

                <p>
                    <span>
                        <span class="src">
                            Use <code>'\0'</code> for chars.
                        </span>
                        文字には<code>'\0'</code>を使います。
                    </span>
                    <span>
                        <span class="src">
                            This is the correct
                            type and also makes code more readable.
                        </span>
                        これは、正しい型であり、かつ可読性も向上します。
                    </span>
                </p>

            </div>

            <h3 id="sizeof"><span title="sizeof">sizeof</span></h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Prefer <code>sizeof(<var>varname</var>)</code> to
                            <code>sizeof(<var>type</var>)</code>.
                        </span>
                        <code>sizeof(<var>型</var>)</code>よりも<code>sizeof(<var>変数名</var>)</code>を使いましょう。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <p>
                    <span>
                        <span class="src">
                            Use <code>sizeof(<var>varname</var>)</code> when you
                            take the size of a particular variable.
                        </span>
                        具体的な変数のサイズを知りたいときには<code>sizeof(<var>変数名</var>)</code>を使ってください。
                    </span>
                    <span>
                        <span class="src">
                            <code>sizeof(<var>varname</var>)</code> will update
                            appropriately if someone changes the variable type either
                            now or later.
                        </span>
                        <code>sizeof(<var>変数名</var>)</code>であれば、変数の型に変更があった場合でも適切に追従してくれます。
                    </span>
                    <span>
                        <span class="src">
                            You may use
                            <code>sizeof(<var>type</var>)</code> for code unrelated
                            to any particular variable, such as code that manages an
                            external or internal data format where a variable of an
                            appropriate C++ type is not convenient.
                        </span>
                        具体的な変数に結びつかない場合は<code>sizeof(<var>型</var>)</code>を使ってもかまいません。たとえば、外部や内部のデータのフォーマットを管理したい場合で、かつC++の型の仕組みが不十分な場合などです。
                    </span>
                </p>
<pre>Struct data;
memset(&amp;data, 0, sizeof(data));
</pre>

                <span>
                    <span class="src">
<pre class="badcode">memset(&amp;data, 0, sizeof(Struct));
</pre>
                    </span>
                    <pre class="badcode">memset(&amp;data, 0, sizeof(Struct));  // これは避ける
</pre>
                </span>

<pre>if (raw_size &lt; sizeof(int)) {
  LOG(ERROR) &lt;&lt; "compressed record not big enough for count: " &lt;&lt; raw_size;
  return false;
}
</pre>
            </div>

            <h3 id="auto"><span title="auto">auto</span></h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Use <code>auto</code> to avoid type names that are noisy, obvious,
                            or unimportant - cases where the type doesn't aid in clarity for the
                            reader.
                        </span>
                        型の名前が騒がしい場合や、明確な場合、重要でない場合(＝型の名前が読者の理解の役に立たない場合)は<code>auto</code>を使ってください。
                    </span>
                    <span>
                        <span class="src">
                            Continue to use manifest type declarations when it helps
                            readability.
                        </span>
                        型名を明示することで可読性が向上する場合は、従来通り、型の名前を明示して宣言を行ってください。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <div class="pros">
                    <p>
                    </p>
                    <ul>
                        <li>
                            <span>
                                <span class="src">
                                    C++ type names can be long and cumbersome, especially when they
                                    involve templates or namespaces.
                                </span>
                                C++の型名は、特にテンプレートや名前空間を含んだ場合、長く面倒なものになりがちです。
                            </span>
                        </li>
                        <li>
                            <span>
                                <span class="src">
                                    When a C++ type name is repeated within a single declaration or a
                                    small code region, the repetition may not be aiding readability.
                                </span>
                                1つの宣言や小さなコードブロックの中で、C++の型名の繰り返されることは、可読性の助けにはなりません。
                            </span>
                        </li>
                        <li>
                            <span>
                                <span class="src">
                                    It is sometimes safer to let the type be specified by the type of
                                    the initialization expression, since that avoids the possibility of
                                    unintended copies or type conversions.
                                </span>
                                また、意図しないコピーや型変換を避けるために、変数の型を初期化式の型で決定するほうがより安全な場合もあります。
                            </span>
                        </li>
                    </ul>
                </div>
                <div class="cons">

                    <p>
                        <span>
                            <span class="src">
                                Sometimes code is clearer when types are manifest,
                                especially when a variable's initialization depends on
                                things that were declared far away.
                            </span>
                            型が明示された方がコードがわかりやすくなる場合があります。特に、初期化子が離れたところで宣言されたものに依存している場合などです。
                        </span>
                        <span>
                            <span class="src">
                                In expressions
                                like:
                            </span>
                            たとえば次のような式を考えてみます。
                        </span>
                    </p>

<pre class="badcode">auto foo = x.add_foo();
auto i = y.Find(key);
</pre>

                    <p>
                        <span>
                            <span class="src">
                                it may not be obvious what the resulting types are if the type
                                of <code>y</code> isn't very well known, or if <code>y</code> was
                                declared many lines earlier.
                            </span>
                            この式において、<code>y</code>の型が十分に知られていなかったり、<code>y</code>がずっと前に宣言されていたりした場合、式の結果の型が明確であるとはいえないでしょう。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Programmers have to understand the difference between
                                <code>auto</code> and <code>const auto&amp;</code> or
                                they'll get copies when they didn't mean to.
                            </span>
                            プログラマは<code>auto</code>と<code>const auto&amp;</code>の違いについて理解していなければなりません。さもなくば、意図せずオブジェクトのコピーを得ることになってしまうかもしれません。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                If an <code>auto</code> variable is used as part of an
                                interface, e.g. as a constant in a header, then a
                                programmer might change its type while only intending to
                                change its value, leading to a more radical API change
                                than intended.
                            </span>
                            <code>auto</code>変数が、インターフェースの一部(ヘッダにおける定数など)として使われていた場合、プログラマはその値を変えるだけのつもりで、型も変えてしまうかもしれません。これによって意図した変更よりも根本的なAPIの変更を招いてしまうかもしれません。
                        </span>
                    </p>
                </div>

                <div class="decision">

                    <p>
                        <span>
                            <span class="src">
                                <code>auto</code> is permitted when it increases readability,
                                particularly as described below.
                            </span>
                            <code>auto</code>は、特に次に述べるような、可読性を向上させる場合にのみ使うことができます。
                        </span>
                        <span>
                            <span class="src">
                                Never initialize an <code>auto</code>-typed
                                variable with a braced initializer list.
                            </span>
                            <code>auto</code>変数を初期化子リストで初期化してはいけません。
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Specific cases where <code>auto</code> is allowed or encouraged:
                            </span>
                            <code>auto</code>が認められる、または推奨されるのは次のような場合です。
                        </span>
                    </p>
                    <ul>
                        <li>
                            <span>
                                <span class="src">
                                    (Encouraged) For iterators and other long/cluttery type names, particularly
                                    when the type is clear from context (calls
                                    to <code>find</code>, <code>begin</code>, or <code>end</code> for
                                    instance).
                                </span>
                                (推奨) イテレータやそのほかの長い型名、特に<code>find</code>や<code>begin</code>、<code>end</code>の呼び出し時など、型が文脈から明らかにわかる場合。
                            </span>
                        </li>
                        <li>
                            <span>
                                <span class="src">
                                    (Allowed) When the type is clear from local context (in the same expression
                                    or within a few lines).
                                </span>
                                (許可) 局所的な文脈(同じ式の中か、1～2行の範囲内)から型が明らかなとき。
                            </span>
                            <span>
                                <span class="src">
                                    Initialization of a pointer or smart pointer
                                    with calls
                                    to <code>new</code>
                                    commonly falls into this category, as does use of <code>auto</code> in
                                    a range-based loop over a container whose type is spelled out
                                    nearby.
                                </span>
                                <code>new</code>を伴うポインタやスマートポインタの初期化がこのカテゴリに属します。また、近くに型が書かれているコンテナに対する、レンジベースのループの<code>auto</code>も同様です。
                            </span>
                        </li>
                        <li>
                            <span>
                                <span class="src">
                                    (Allowed) When the type doesn't matter because it isn't being used for
                                    anything other than equality comparison.
                                </span>
                                (許可) 型が重要でないとき。等価比較以外の目的で使われていない場合など。
                            </span>
                        </li>
                        <li>
                            <span>
                                <span class="src">
                                    (Encouraged) When iterating over a map with a range-based loop
                                    (because it is often assumed that the correct type
                                    is <code>std::pair&lt;KeyType, ValueType&gt;</code> whereas it is actually
                                    <code>std::pair&lt;const KeyType, ValueType&gt;</code>).
                                </span>
                                (推奨) レンジベースのループでmapをイテレートする場合のイテレータ。(このイテレータの本当の型は<code>std::pair&lt;const KeyType, ValueType&gt;</code>であるにも関わらず、型が<code>std::pair&lt;KeyType, ValueType&gt;</code>であると誤認されるため)。
                            </span>
                            <span>
                                <span class="src">
                                    This is
                                    particularly well paired with local <code>key</code>
                                    and <code>value</code> aliases for <code>.first</code>
                                    and <code>.second</code> (often const-ref).
                                </span>
                                これは特に、局所変数<code>key</code>と<code>value</code>が<code>.first</code>と<code>.second</code>への別名として定義される場合とセットの場合に言えます。
                            </span>
                            <span>
                                <span class="src">
<pre class="code">for (const auto&amp; item : some_map) {
  const KeyType&amp; key = item.first;
  const ValType&amp; value = item.second;
  // The rest of the loop can now just refer to key and value,
  // a reader can see the types in question, and we've avoided
  // the too-common case of extra copies in this iteration.
}
</pre>
                                </span>
                                <pre class="code">for (const auto&amp; item : some_map) {
  const KeyType&amp; key = item.first;
  const ValType&amp; value = item.second;
  // ループの残りの部分では key と value を参照します。
  // コードの読み手は対象の型を見ることができ、
  // 書き手はこのイテレーションにおいてよくあるコピーの問題を回避できています。
}
</pre>
                            </span>
                        </li>
                    </ul>

                </div>

            </div>

            <h3 id="Braced_Initializer_List"><span title="Braced Initializer List">波括弧による初期化子リスト</span></h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            You may use braced initializer lists.
                        </span>
                        波括弧による初期化リストを使ってもよいです。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <p>
                    <span>
                        <span class="src">
                            In C++03, aggregate types (arrays and structs with no
                            constructor) could be initialized with braced initializer lists.
                        </span>
                        C++03では、aggregateな型(配列や、コンストラクタを持たない構造体)が、波括弧による初期化子リストで初期化できました。
                    </span>
                </p>

<pre>struct Point { int x; int y; };
Point p = {1, 2};
</pre>

                <p>
                    <span>
                        <span class="src">
                            In C++11, this syntax was generalized, and any object type can now
                            be created with a braced initializer list, known as a
                            <i>braced-init-list</i> in the C++ grammar.
                        </span>
                        C++11では、この文法はより一般化され、C++の文法における<i>初期化子リスト</i>として知られているように、どのようなオブジェクトもこの波括弧で囲まれた初期化子のリストで初期化できるようになりました。
                    </span>
                    <span>
                        <span class="src">
                            Here are a few examples
                            of its use.
                        </span>
                        それらの使用例を以下に示します。
                    </span>
                </p>
                <span>
                    <span class="src">
<pre>// Vector takes a braced-init-list of elements.
std::vector&lt;string&gt; v{"foo", "bar"};

// Basically the same, ignoring some small technicalities.
// You may choose to use either form.
std::vector&lt;string&gt; v = {"foo", "bar"};

// Usable with 'new' expressions.
auto p = new vector&lt;string&gt;{"foo", "bar"};

// A map can take a list of pairs. Nested braced-init-lists work.
std::map&lt;int, string&gt; m = {{1, "one"}, {2, "2"}};

// A braced-init-list can be implicitly converted to a return type.
std::vector&lt;int&gt; test_function() { return {1, 2, 3}; }

// Iterate over a braced-init-list.
for (int i : {-1, -2, -3}) {}

// Call a function using a braced-init-list.
void TestFunction2(std::vector&lt;int&gt; v) {}
TestFunction2({1, 2, 3});
</pre>
                    </span>
                    <pre>// vector はその要素となる初期化子リストをとります。.
std::vector&lt;string&gt; v{"foo", "bar"};

// 細則を無視すれば、上記と基本的には同じです。
// どちらの形を使用してもかまいません。
std::vector&lt;string&gt; v = {"foo", "bar"};

// newとともに使うこともできます。
auto p = new vector&lt;string&gt;{"foo", "bar"};

// mapは、ペアのリストをとります。初期化子リストはネストすることができます。
std::map&lt;int, string&gt; m = {{1, "one"}, {2, "2"}};

// 初期化子リストは戻り値の型に暗黙的に変換されます。
std::vector&lt;int&gt; test_function() { return {1, 2, 3}; }

// 初期化子リストをイテレートすることもできます。
for (int i : {-1, -2, -3}) {}

// 初期化子リストを用いて関数を呼ぶこともできます。
void TestFunction2(std::vector&lt;int&gt; v) {}
TestFunction2({1, 2, 3});
</pre>
                </span>
                <p>
                    <span>
                        <span class="src">
                            A user-defined type can also define a constructor and/or assignment operator
                            that take <code>std::initializer_list&lt;T&gt;</code>, which is automatically
                            created from <i>braced-init-list</i>:
                        </span>
                        ユーザ定義の型は、<code>std::initializer_list&lt;T&gt;</code>を引数にとるコンストラクタや代入演算子を定義することで、<i>初期化子リスト</i>からオブジェクトを生成することができます。以下に例を示します。
</span>
                </p>
                <span>
                    <span class="src">
<pre>class MyType {
 public:
  // std::initializer_list references the underlying init list.
  // It should be passed by value.
  MyType(std::initializer_list&lt;int&gt; init_list) {
    for (int i : init_list) append(i);
  }
  MyType&amp; operator=(std::initializer_list&lt;int&gt; init_list) {
    clear();
    for (int i : init_list) append(i);
  }
};
MyType m{2, 3, 5, 7};
</pre>
                    </span>
                    <pre>class MyType {
 public:
  // std::initializer_list は、渡された初期化子リストを参照します。
  // これは値渡しになります。
  MyType(std::initializer_list&lt;int&gt; init_list) {
    for (int i : init_list) append(i);
  }
  MyType&amp; operator=(std::initializer_list&lt;int&gt; init_list) {
    clear();
    for (int i : init_list) append(i);
  }
};
MyType m{2, 3, 5, 7};
</pre>
                </span>
                <p>
                    <span>
                        <span class="src">
                            Finally, brace initialization can also call ordinary
                            constructors of data types, even if they do not have
                            <code>std::initializer_list&lt;T&gt;</code> constructors.
                        </span>
                        最後になりますが、初期化子リストは、<code>std::initializer_list&lt;T&gt;</code>のコンストラクタを持たないふつうのデータ型のコンストラクタを呼ぶこともできます。
                    </span>
                </p>
                <span>
                    <span class="src">
<pre>double d{1.23};
// Calls ordinary constructor as long as MyOtherType has no
// std::initializer_list constructor.
class MyOtherType {
 public:
  explicit MyOtherType(string);
  MyOtherType(int, string);
};
MyOtherType m = {1, "b"};
// If the constructor is explicit, you can't use the "= {}" form.
MyOtherType m{"b"};
</pre>
                    </span>
                    <pre>double d{1.23};
// MyOtherTypeはstd::initializer_listのコンストラクタを持っていないため、
// 通常のコンストラクタが呼び出されます。
class MyOtherType {
 public:
  explicit MyOtherType(string);
  MyOtherType(int, string);
};
MyOtherType m = {1, "b"};
// もし、コンストラクタがexplicitでマークされていた場合、
// 「= {}」の形を使用することはできません。
MyOtherType m{"b"};
</pre>
                </span>
                <p>
                    <span>
                        <span class="src">
                            Never assign a <i>braced-init-list</i> to an auto
                            local variable.
                        </span>
                        初期化子リストでautoなローカル変数を割り当ててはいけません。
                    </span>
                    <span>
                        <span class="src">
                            In the single element case, what this
                            means can be confusing.
                        </span>
                        要素が1つの場合、その意味がわかりません。
                    </span>
                </p>
                <span>
                    <span class="src">
<pre class="badcode">auto d = {1.23};        // d is a std::initializer_list&lt;double&gt;
</pre>
                    </span>
                    <pre class="badcode">auto d = {1.23};        // d は std::initializer_list&lt;double&gt;
</pre>
                </span>
                <span>
                    <span class="src">
<pre>auto d = double{1.23};  // Good -- d is a double, not a std::initializer_list.
</pre>
                    </span>
                    <pre>auto d = double{1.23};  // これはOK。dはdouble。std::initializer_listにはなりません。
</pre>
                </span>
                <p>
                    <span>
                        <span class="src">
                            See <a href="#Braced_Initializer_List_Format">Braced_Initializer_List_Format</a> for formatting.
                        </span>
                        フォーマットについては<a href="#Braced_Initializer_List_Format">波括弧による初期化子リスト</a>も参照してください。
                    </span>
                </p>

            </div>

            <h3 id="Lambda_expressions"><span title="Lambda expressions">ラムダ式</span></h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Use lambda expressions where appropriate.
                        </span>
                        ラムダ式は、それが適切な場合に、使用してください。
                    </span>
                    <span>
                        <span class="src">
                            Prefer explicit captures
                            when the lambda will escape the current scope.
                        </span>
                        ラムダ式が現在のスコープの外に出て行くときは、明示的に変数をキャプチャしましょう。
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">

                    <p>
                        <span>
                            <span class="src">
                                Lambda expressions are a concise way of creating anonymous
                                function objects.
                            </span>
                            ラムダ式は、匿名関数オブジェクトを作るための簡潔な方法です。
                        </span>
                        <span>
                            <span class="src">
                                They're often useful when passing
                                functions as arguments. For example:
                            </span>
                            ラムダ式は、関数の引数として渡す場合にも便利です。例を見てみましょう。
                        </span>
                    </p>

<pre>std::sort(v.begin(), v.end(), [](int x, int y) {
  return Weight(x) &lt; Weight(y);
});
</pre>

                    <p>
                        <span>
                            <span class="src">
                                They further allow capturing variables from the enclosing scope either
                                explicitly by name, or implicitly using a default capture.
                            </span>
                            ラムダ式は、自身を囲むスコープから変数をキャプチャすることができます。変数をキャプチャは、明示的に名前を指定するか、暗黙的なデフォルトのキャプチャを使うかのどちらかによって行われます。
                        </span>
                        <span>
                            <span class="src">
                                Explicit captures
                                require each variable to be listed, as
                                either a value or reference capture:
                            </span>
                            明示的なキャプチャのためには、次のように、各変数を、値とするか参照とするかを指定しつつリストに並べます。
                        </span>
                    </p>
                    <span>
                        <span class="src">
<pre>int weight = 3;
int sum = 0;
// Captures `weight` by value and `sum` by reference.
std::for_each(v.begin(), v.end(), [weight, &amp;sum](int x) {
  sum += weight * x;
});
</pre>
                        </span>
                        <pre>int weight = 3;
int sum = 0;
// weigthは値として、sumは参照としてキャプチャしています。
std::for_each(v.begin(), v.end(), [weight, &amp;sum](int x) {
  sum += weight * x;
});
</pre>
                    </span>
                    <span>
                        <span class="src">
                            Default captures implicitly capture any variable referenced in the
                            lambda body, including <code>this</code> if any members are used:
                        </span>
                        デフォルトのキャプチャは暗黙的にラムダ式の本体で参照されたすべての変数をキャプチャします。何らかのメンバが使われている場合は<code>this</code>もキャプチャされます。
                    </span>
                       <span>
                        <span class="src">
<pre>const std::vector&lt;int&gt; lookup_table = ...;
std::vector&lt;int&gt; indices = ...;
// Captures `lookup_table` by reference, sorts `indices` by the value
// of the associated element in `lookup_table`.
std::sort(indices.begin(), indices.end(), [&amp;](int a, int b) {
  return lookup_table[a] &lt; lookup_table[b];
});
</pre>
                        </span>
                           <pre>const std::vector&lt;int&gt; lookup_table = ...;
std::vector&lt;int&gt; indices = ...;
// lookup_tableを参照としてキャプチャし、
// lookup_tableの要素に関連づけられたindicesの値をソートしています。
std::sort(indices.begin(), indices.end(), [&amp;](int a, int b) {
  return lookup_table[a] &lt; lookup_table[b];
});
</pre>

                    </span>
                    <p>
                        <span>
                            <span class="src">
                                Lambdas were introduced in C++11 along with a set of utilities
                                for working with function objects, such as the polymorphic
                                wrapper <code>std::function</code>.
                            </span>
                            ラムダ式は、関数オブジェクトとともに動作するユーティリティ一式(たとえば、<code>std::function</code>など)とともにC++11で導入されました。
                        </span>
                    </p>
                </div>

                <div class="pros">
                    <ul>
                        <li>
                            <span>
                                <span class="src">
                                    Lambdas are much more concise than other ways of
                                    defining function objects to be passed to STL
                                    algorithms, which can be a readability
                                    improvement.
                                </span>
                                ラムダ式は、STLのアルゴリズムに渡すためには、関数オブジェクトを作るよりも遙かに簡潔な方法であり、可読性も向上させます。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Appropriate use of default captures can remove
                                    redundancy and highlight important exceptions from
                                    the default.
                                </span>
                                デフォルトキャプチャを適切に用いることで、余分な記述を減らせます。また、デフォルトとは異なる重要な例外を目立たせることもできます。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Lambdas, <code>std::function</code>, and
                                    <code>std::bind</code> can be used in combination as a
                                    general purpose callback mechanism; they make it easy
                                    to write functions that take bound functions as
                                    arguments.
                                </span>
                                ラムダ式や<code>std::function</code>、<code>std::bind</code>は、一般的なコールバックのメカニズムにとして組み合わせて使用することができます。これらを使うことで、引数に動作を示す関数をとるような関数が書きやすくなります。
                            </span>
                        </li>
                    </ul>
                </div>

                <div class="cons">
                    <ul>
                        <li>
                            <span>
                                <span class="src">
                                    Variable capture in lambdas can be a source of dangling-pointer
                                    bugs, particularly if a lambda escapes the current scope.
                                </span>
                                ラムダ式の変数のキャプチャは、ダングリングポインタバグの元になる危険があり、特にラムダ式がそのスコープの外に出ていくときは注意が必要です。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Default captures by value can be misleading because they do not prevent
                                    dangling-pointer bugs.
                                </span>
                                デフォルトでは値によるキャプチャが行われますが、これらがダングリングポインタのバグを防ぐことはないため、ミスリードも起こしやすいです。
                            </span>
                            <span>
                                <span class="src">
                                    Capturing a pointer by value doesn't cause a deep
                                    copy, so it often has the same lifetime issues as capture by reference.
                                </span>
                                ポインタを値でキャプチャしてもそれが自動的にディープコピーされることはありません。このため、参照でキャプチャした場合と同様に、オブジェクトの生存期間に関する問題をはらみます。
                            </span>
                            <span>
                                <span class="src">
                                    This is especially confusing when capturing 'this' by value, since the use
                                    of 'this' is often implicit.
                                </span>
                                特に、thisポインタを値でキャプチャした場合には混乱の元になりやすいです。thisは暗黙的に使用されることが多いからです。
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    It's possible for use of lambdas to get out of
                                    hand; very long nested anonymous functions can make
                                    code harder to understand.
                                </span>
                                ラムダ式は、手に余るような扱い方もできてしまいます。たとえば、非常に長い匿名の関数がネストされているような状況では、そのコードを理解するのは難しいでしょう。
                            </span>
                        </li>

                    </ul>
                </div>

                <div class="decision">
                    <ul>
                        <li>
                            <span>
                                <span class="src">
                                    Use lambda expressions where appropriate, with formatting as
                                    described <a href="#Formatting_Lambda_Expressions">below</a>.
                                </span>
                                ラムダ式は、適切な場合に限り、使用してください。その際の書式は<a href="#Formatting_Lambda_Expressions">ラムダ式の書式</a>に従ってください。
                            </span>
                        </li>
                        <li>
                            <span>
                                <span class="src">
                                    Prefer explicit captures if the lambda may escape the current scope.
                                </span>
                                ラムダ式が現在のスコープの外に出て行く場合は、明示的なキャプチャを使いましょう。
                            </span>
                            <span>
                                <span class="src">
                                    For example, instead of:
                                </span>
                                以下に例を示します。悪い例から。
                            </span>
                            <span>
                                <span class="src">
<pre class="badcode">{
  Foo foo;
  ...
  executor-&gt;Schedule([&amp;] { Frobnicate(foo); })
  ...
}
// BAD! The fact that the lambda makes use of a reference to `foo` and
// possibly `this` (if `Frobnicate` is a member function) may not be
// apparent on a cursory inspection. If the lambda is invoked after
// the function returns, that would be bad, because both `foo`
// and the enclosing object could have been destroyed.
</pre>
                                </span>
                                <pre class="badcode">{
  Foo foo;
  ...
  executor-&gt;Schedule([&amp;] { Frobnicate(foo); })
  ...
}
// これはダメ！
// ラムダ式において、fooとthis(Frobnicateがメンバ関数である場合)が
// 使用されていますが、それは大まかにみても明らかとは言えません。
// もし、Schedule関数から処理が戻った後に、ラムダ式が呼ばれることがあると、
// よくないことが起こるかもしれません。ラムダ式が呼び出されたとき、
// fooも、このラムダを取り囲んでいたオブジェクトも
// すでに存在していないかもしれないからです。
</pre>
                            </span>
                            <span>
                                <span class="src">
                                    prefer to write:
                                </span>
                                以下のように書きましょう。
                            </span>
                            <span>
                                <span class="src">
<pre>{
  Foo foo;
  ...
  executor-&gt;Schedule([&amp;foo] { Frobnicate(foo); })
  ...
}
// BETTER - The compile will fail if `Frobnicate` is a member
// function, and it's clearer that `foo` is dangerously captured by
// reference.
</pre>
                                </span>
                                        <pre>{
  Foo foo;
  ...
  executor-&gt;Schedule([&amp;foo] { Frobnicate(foo); })
  ...
}
// この方がマシ。
// Frobnicateがメンバ関数である場合、コンパイルに失敗します。
// また、fooが危険なキャプチャをされていることがより明確になります。
</pre>
                            </span>
                        </li>
                        <li>
                            <span>
                                <span class="src">
                                    Use default capture by reference ([&amp;]) only when the
                                    lifetime of the lambda is obviously shorter than any potential
                                    captures.
                                </span>
                                参照のデフォルトキャプチャ(<code>[&amp;]</code>)は、ラムダ式の寿命が、その潜在的なキャプチャのすべてよりも明らかに短いときにのみ使用してください。
                            </span>
                        </li>
                        <li>
                            <span>
                                <span class="src">
                                    Use default capture by value ([=]) only as a means of binding a
                                    few variables for a short lambda, where the set of captured
                                    variables is obvious at a glance.
                                </span>
                                値のデフォルトキャプチャは、短いラムダ式において1～2個の変数がキャプチャされる場合で、かつ、一目見ただけでどの変数がキャプチャされているかがわかるような場合にのみ使用してください。
                            </span>
                            <span>
                                <span class="src">
                                    Prefer not to write long or
                                    complex lambdas with default capture by value.
                                </span>
                                長いラムダ式や複雑なラムダ式には、値のデフォルトキャプチャは使わないようにしましょう。
                            </span>
                        </li>
                        <li>
                            <span>
                                <span class="src">
                                    Keep unnamed lambdas short.
                                </span>
                                無名のラムダ式は短く保ってください。
                            </span>
                            <span>
                                <span class="src">
                                    If a lambda body is more than
                                    maybe five lines long, prefer to give the lambda a name, or to
                                    use a named function instead of a lambda.
                                </span>
                                ラムダ式がおおむね5行を超えるような場合には、ラムダ式に名前をつけるか、ラムダ式ではなく名前のついたふつうの関数を使ってください。
                            </span>
                        </li>
                        <li>
                            <span>
                                <span class="src">
                                    Specify the return type of the lambda explicitly if that will
                                    make it more obvious to readers, as with
                                    <a href="#auto"><code>auto</code></a>.
                                </span>
                                ラムダ式の戻り値の型を明示的に記述した方が可読性が上がるという場合には、そうしてください。これは<a href="#auto"><code>auto</code></a>を使うときと同様です。
                            </span>
                        </li>

                    </ul>
                </div>

            </div>

            <h3 id="Template_metaprogramming">Template metaprogramming</h3>
            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Avoid complicated template programming.
                        </span>
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        <span>
                            <span class="src">
                                Template metaprogramming refers to a family of techniques that
                                exploit the fact that the C++ template instantiation mechanism is
                                Turing complete and can be used to perform arbitrary compile-time
                                computation in the type domain.
                            </span>
                        </span>
                    </p>
                </div>

                <div class="pros">
                    <p>
                        <span>
                            <span class="src">
                                Template metaprogramming allows extremely flexible interfaces that
                                are type safe and high performance.
                            </span>
                        </span>
                        <span>
                            <span class="src">
                                Facilities like

                                <a href="https://code.google.com/p/googletest/">Google Test</a>,
                                <code>std::tuple</code>, <code>std::function</code>, and
                                Boost.Spirit would be impossible without it.
                            </span>
                        </span>
                    </p>
                </div>

                <div class="cons">
                    <p>
                        <span>
                            <span class="src">
                                The techniques used in template metaprogramming are often obscure
                                to anyone but language experts.
                            </span>
                        </span>
                        <span>
                            <span class="src">
                                Code that uses templates in
                                complicated ways is often unreadable, and is hard to debug or
                                maintain.
                            </span>
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Template metaprogramming often leads to extremely poor compiler
                                time error messages: even if an interface is simple, the complicated
                                implementation details become visible when the user does something
                                wrong.
                            </span>
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Template metaprogramming interferes with large scale refactoring by
                                making the job of refactoring tools harder.
                            </span>
                        </span>
                        <span>
                            <span class="src">
                                First, the template code
                                is expanded in multiple contexts, and it's hard to verify that the
                                transformation makes sense in all of them.
                            </span>
                        </span>
                        <span>
                            <span class="src">
                                Second, some refactoring
                                tools work with an AST that only represents the structure of the code
                                after template expansion.
                            </span>
                        </span>
                        <span>
                            <span class="src">
                                It can be difficult to automatically work
                                back to the original source construct that needs to be
                                rewritten.
                            </span>
                        </span>
                    </p>
                </div>

                <div class="decision">
                    <p>
                        <span>
                            <span class="src">
                                Template metaprogramming sometimes allows cleaner and easier-to-use
                                interfaces than would be possible without it, but it's also often a
                                temptation to be overly clever.
                            </span>
                        </span>
                        <span>
                            <span class="src">
                                It's best used in a small number of
                                low level components where the extra maintenance burden is spread out
                                over a large number of uses.
                            </span>
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Think twice before using template metaprogramming or other
                                complicated template techniques; think about whether the average
                                member of your team will be able to understand your code well enough
                                to maintain it after you switch to another project, or whether a
                                non-C++ programmer or someone casually browsing the code base will be
                                able to understand the error messages or trace the flow of a function
                                they want to call.
                            </span>
                        </span>
                        <span>
                            <span class="src">
                                If you're using recursive template instantiations
                                or type lists or metafunctions or expression templates, or relying on
                                SFINAE or on the <code>sizeof</code> trick for detecting function
                                overload resolution, then there's a good chance you've gone too
                                far.
                            </span>
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                If you use template metaprogramming, you should expect to put
                                considerable effort into minimizing and isolating the complexity.
                            </span>
                        </span>
                        <span>
                            <span class="src">
                                You
                                should hide metaprogramming as an implementation detail whenever
                                possible, so that user-facing headers are readable, and you should
                                make sure that tricky code is especially well commented.
                            </span>
                        </span>
                        <span>
                            <span class="src">
                                You should
                                carefully document how the code is used, and you should say something
                                about what the "generated" code looks like.
                            </span>
                        </span>
                        <span>
                            <span class="src">
                                Pay extra attention to the
                                error messages that the compiler emits when users make mistakes.
                            </span>
                        </span>
                        <span>
                            <span class="src">
                                The
                                error messages are part of your user interface, and your code should
                                be tweaked as necessary so that the error messages are understandable
                                and actionable from a user point of view.
                            </span>
                        </span>
                    </p>

                </div>
            </div>


            <h3 id="Boost">Boost</h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Use only approved libraries from the Boost library
                            collection.
                        </span>
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        <span>
                            <span class="src">
                                The
                                <a href="https://www.boost.org/">
                                    Boost library collection
                                </a> is a popular collection of
                                peer-reviewed, free, open-source C++ libraries.
                            </span>
                        </span>
                    </p>
                </div>

                <div class="pros">
                    <p>
                        <span>
                            <span class="src">
                                Boost code is generally very high-quality, is widely
                                portable, and fills many important gaps in the C++
                                standard library, such as type traits and better binders.
                            </span>
                        </span>
                    </p>
                </div>

                <div class="cons">
                    <p>
                        <span>
                            <span class="src">
                                Some Boost libraries encourage coding practices which can
                                hamper readability, such as metaprogramming and other
                                advanced template techniques, and an excessively
                                "functional" style of programming.
                            </span>
                        </span>
                    </p>
                </div>

                <div class="decision">



                    <div>
                        <p>
                            <span>
                                <span class="src">
                                    In order to maintain a high level of readability for
                                    all contributors who might read and maintain code, we
                                    only allow an approved subset of Boost features.
                                </span>
                            </span>
                            <span>
                                <span class="src">
                                    Currently, the following libraries are permitted:
                                </span>
                            </span>
                        </p>

                        <ul>
                            <li>
                                <span>
                                    <span class="src">
                                        <a href="https://www.boost.org/libs/utility/call_traits.htm">
                                            Call Traits
                                        </a> from <code>boost/call_traits.hpp</code>
                                    </span>
                                </span>
                            </li>

                            <li>
                                <span>
                                    <span class="src">
                                        <a href="https://www.boost.org/libs/utility/compressed_pair.htm">
                                            Compressed Pair
                                        </a> from  <code>boost/compressed_pair.hpp</code>
                                    </span>
                                </span>
                            </li>

                            <li>
                                <span>
                                    <span class="src">
                                        <a href="https://www.boost.org/libs/graph/">
                                            The Boost Graph Library (BGL)
                                        </a> from <code>boost/graph</code>,
                                        except serialization (<code>adj_list_serialize.hpp</code>) and
                                        parallel/distributed algorithms and data structures
                                        (<code>boost/graph/parallel/*</code> and
                                        <code>boost/graph/distributed/*</code>).
                                    </span>
                                </span>
                            </li>

                            <li>
                                <span>
                                    <span class="src">
                                        <a href="https://www.boost.org/libs/property_map/">
                                            Property Map
                                        </a> from <code>boost/property_map</code>, except
                                        parallel/distributed property maps (<code>boost/property_map/parallel/*</code>).
                                    </span>
                                </span>
                            </li>

                            <li>
                                <span>
                                    <span class="src">
                                        <a href="https://www.boost.org/libs/iterator/">
                                            Iterator
                                        </a> from <code>boost/iterator</code>
                                    </span>
                                </span>
                            </li>

                            <li>
                                <span>
                                    <span class="src">
                                        The part of <a href="https://www.boost.org/libs/polygon/">
                                            Polygon
                                        </a> that deals with Voronoi diagram
                                        construction and doesn't depend on the rest of
                                        Polygon:
                                        <code>boost/polygon/voronoi_builder.hpp</code>,
                                        <code>boost/polygon/voronoi_diagram.hpp</code>, and
                                        <code>boost/polygon/voronoi_geometry_type.hpp</code>
                                    </span>
                                </span>
                            </li>

                            <li>
                                <span>
                                    <span class="src">
                                        <a href="https://www.boost.org/libs/bimap/">
                                            Bimap
                                        </a> from <code>boost/bimap</code>
                                    </span>
                                </span>
                            </li>

                            <li>
                                <span>
                                    <span class="src">
                                        <a href="https://www.boost.org/libs/math/doc/html/dist.html">
                                            Statistical Distributions and Functions
                                        </a> from
                                        <code>boost/math/distributions</code>
                                    </span>
                                </span>
                            </li>

                            <li>
                                <span>
                                    <span class="src">
                                        <a href="https://www.boost.org/libs/math/doc/html/special.html">
                                            Special Functions
                                        </a> from <code>boost/math/special_functions</code>
                                    </span>
                                </span>
                            </li>

                            <li>
                                <span>
                                    <span class="src">
                                        <a href="https://www.boost.org/libs/multi_index/">
                                            Multi-index
                                        </a> from <code>boost/multi_index</code>
                                    </span>
                                </span>
                            </li>

                            <li>
                                <span>
                                    <span class="src">
                                        <a href="https://www.boost.org/libs/heap/">
                                            Heap
                                        </a> from <code>boost/heap</code>
                                    </span>
                                </span>
                            </li>

                            <li>
                                <span>
                                    <span class="src">
                                        The flat containers from
                                        <a href="https://www.boost.org/libs/container/">Container</a>:
                                        <code>boost/container/flat_map</code>, and
                                        <code>boost/container/flat_set</code>
                                    </span>
                                </span>
                            </li>

                            <li>
                                <span>
                                    <span class="src">
                                        <a href="https://www.boost.org/libs/intrusive/">Intrusive</a>
                                        from <code>boost/intrusive</code>.
                                    </span>
                                </span>
                            </li>

                            <li>
                                <span>
                                    <span class="src">
                                        <a href="https://www.boost.org/libs/sort/">
                                            The
                                            <code>boost/sort</code> library
                                        </a>.
                                    </span>
                                </span>
                            </li>

                            <li>
                                <span>
                                    <span class="src">
                                        <a href="https://www.boost.org/libs/preprocessor/">Preprocessor</a>
                                        from <code>boost/preprocessor</code>.
                                    </span>
                                </span>
                            </li>
                        </ul>

                        <p>
                            <span>
                                <span class="src">
                                    We are actively considering adding other Boost
                                    features to the list, so this list may be expanded in
                                    the future.
                                </span>
                            </span>
                        </p>
                    </div>

                    <p>
                        <span>
                            <span class="src">
                                The following libraries are permitted, but their use
                                is discouraged because they've been superseded by
                                standard libraries in C++11:
                            </span>
                        </span>
                    </p>

                    <ul>
                        <li>
                            <span>
                                <span class="src">
                                    <a href="https://www.boost.org/libs/array/">
                                        Array
                                    </a> from <code>boost/array.hpp</code>: use
                                    <a href="http://en.cppreference.com/w/cpp/container/array">
                                        <code>std::array</code>
                                    </a> instead.
                                </span>
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    <a href="https://www.boost.org/libs/ptr_container/">
                                        Pointer Container
                                    </a> from <code>boost/ptr_container</code>: use containers of
                                    <a href="http://en.cppreference.com/w/cpp/memory/unique_ptr">
                                        <code>std::unique_ptr</code>
                                    </a> instead.
                                </span>
                            </span>
                        </li>
                    </ul>
                </div>

            </div>



            <h3 id="std_hash">std::hash</h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Do not define specializations of <code>std::hash</code>.
                        </span>
                    </span>
                </p>
            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        <span>
                            <span class="src">
                                <code>std::hash&lt;T&gt;</code> is the function object that the
                                C++11 hash containers use to hash keys of type <code>T</code>,
                                unless the user explicitly specifies a different hash function.
                            </span>
                        </span>
                        <span>
                            <span class="src">
                                For
                                example, <code>std::unordered_map&lt;int, string&gt;</code> is a hash
                                map that uses <code>std::hash&lt;int&gt;</code> to hash its keys,
                                whereas <code>std::unordered_map&lt;int, string, MyIntHash&gt;</code>
                                uses <code>MyIntHash</code>.
                            </span>
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                <code>std::hash</code> is defined for all integral, floating-point,
                                pointer, and <code>enum</code> types, as well as some standard library
                                types such as <code>string</code> and <code>unique_ptr</code>.
                            </span>
                        </span>
                        <span>
                            <span class="src">
                                Users
                                can enable it to work for their own types by defining specializations
                                of it for those types.
                            </span>
                        </span>
                    </p>
                </div>

                <div class="pros">
                    <p>
                        <span>
                            <span class="src">
                                <code>std::hash</code> is easy to use, and simplifies the code
                                since you don't have to name it explicitly.
                            </span>
                        </span>
                        <span>
                            <span class="src">
                                Specializing
                                <code>std::hash</code> is the standard way of specifying how to
                                hash a type, so it's what outside resources will teach, and what
                                new engineers will expect.
                            </span>
                        </span>
                    </p>
                </div>

                <div class="cons">
                    <p>
                        <span>
                            <span class="src">
                                <code>std::hash</code> is hard to specialize.
                            </span>
                        </span>
                        <span>
                            <span class="src">
                                It requires a lot
                                of boilerplate code, and more importantly, it combines responsibility
                                for identifying the hash inputs with responsibility for executing the
                                hashing algorithm itself.
                            </span>
                        </span>
                        <span>
                            <span class="src">
                                The type author has to be responsible for
                                the former, but the latter requires expertise that a type author
                                usually doesn't have, and shouldn't need.
                            </span>
                        </span>
                        <span>
                            <span class="src">
                                The stakes here are high
                                because low-quality hash functions can be security vulnerabilities,
                                due to the emergence of
                                <a href="https://emboss.github.io/blog/2012/12/14/breaking-murmur-hash-flooding-dos-reloaded/">
                                    hash flooding attacks
                                </a>.
                            </span>
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Even for experts, <code>std::hash</code> specializations are
                                inordinately difficult to implement correctly for compound types,
                                because the implementation cannot recursively call <code>std::hash</code>
                                on data members.
                            </span>
                        </span>
                        <span>
                            <span class="src">
                                High-quality hash algorithms maintain large
                                amounts of internal state, and reducing that state to the
                                <code>size_t</code> bytes that <code>std::hash</code>
                                returns is usually the slowest part of the computation, so it
                                should not be done more than once.
                            </span>
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                Due to exactly that issue, <code>std::hash</code> does not work
                                with <code>std::pair</code> or <code>std::tuple</code>, and the
                                language does not allow us to extend it to support them.
                            </span>
                        </span>
                    </p>
                </div>

                <div class="decision">
                    <p>
                        <span>
                            <span class="src">
                                You can use <code>std::hash</code> with the types that it supports
                                "out of the box", but do not specialize it to support additional types.
                            </span>
                        </span>
                        <span>
                            <span class="src">
                                If you need a hash table with a key type that <code>std::hash</code>
                                does not support, consider using legacy hash containers (e.g.
                                <code>hash_map</code>) for now; they use a different default hasher,
                                which is unaffected by this prohibition.
                            </span>
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                If you want to use the standard hash containers anyway, you will
                                need to specify a custom hasher for the key type, e.g.
                            </span>
                        </span>
                    </p>
                    <span>
                        <span class="src">
<pre>std::unordered_map&lt;MyKeyType, Value, MyKeyTypeHasher&gt; my_map;
</pre>
                        </span>
                    </span>
                    <p>
                        <span>
                            <span class="src">
                                Consult with the type's owners to see if there is an existing hasher
                                that you can use; otherwise work with them to provide one,
                                or roll your own.
                            </span>
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                We are planning to provide a hash function that can work with any type,
                                using a new customization mechanism that doesn't have the drawbacks of
                                <code>std::hash</code>.
                            </span>
                        </span>
                    </p>
                </div>

            </div>

            <h3 id="C++11">C++11</h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Use libraries and language extensions from C++11 when appropriate.
                        </span>
                    </span>
                    <span>
                        <span class="src">
                            Consider portability to other environments
                            before using C++11 features in your
                            project.
                        </span>
                    </span>
                </p>

            </div>

            <div class="stylebody">

                <div class="definition">
                    <p>
                        <span>
                            <span class="src">
                                C++11 contains <a href="https://en.wikipedia.org/wiki/C%2B%2B11">
                                    significant changes
                                </a> both to the language and
                                libraries.
                            </span>
                        </span>
                    </p>
                </div>

                <div class="pros">
                    <p>
                        <span>
                            <span class="src">
                                C++11 was the official standard until august 2014, and
                                is supported by most C++ compilers.
                            </span>
                        </span>
                        <span>
                            <span class="src">
                                It standardizes
                                some common C++ extensions that we use already, allows
                                shorthands for some operations, and has some performance
                                and safety improvements.
                            </span>
                        </span>
                    </p>
                </div>

                <div class="cons">
                    <p>
                        <span>
                            <span class="src">
                                The C++11 standard is substantially more complex than
                                its predecessor (1,300 pages versus 800 pages), and is
                                unfamiliar to many developers.
                            </span>
                        </span>
                        <span>
                            <span class="src">
                                The long-term effects of
                                some features on code readability and maintenance are
                                unknown.
                            </span>
                        </span>
                        <span>
                            <span class="src">
                                We cannot predict when its various features will
                                be implemented uniformly by tools that may be of
                                interest, particularly in the case of projects that are
                                forced to use older versions of tools.
                            </span>
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                As with <a href="#Boost">Boost</a>, some C++11
                                extensions encourage coding practices that hamper
                                readability&#8212;for example by removing
                                checked redundancy (such as type names) that may be
                                helpful to readers, or by encouraging template
                                metaprogramming.
                            </span>
                        </span>
                        <span>
                            <span class="src">
                                Other extensions duplicate functionality
                                available through existing mechanisms, which may lead to confusion
                                and conversion costs.
                            </span>
                        </span>
                    </p>


                </div>

                <div class="decision">

                    <p>
                        <span>
                            <span class="src">
                                C++11 features may be used unless specified otherwise.
                            </span>
                        </span>
                        <span>
                            <span class="src">
                                In addition to what's described in the rest of the style
                                guide, the following C++11 features may not be used:
                            </span>
                        </span>
                    </p>

                    <ul>








                        <li>
                            <span>
                                <span class="src">
                                    Compile-time rational numbers
                                    (<code>&lt;ratio&gt;</code>), because of concerns that
                                    it's tied to a more template-heavy interface
                                    style.
                                </span>
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    The <code>&lt;cfenv&gt;</code> and
                                    <code>&lt;fenv.h&gt;</code> headers, because many
                                    compilers do not support those features reliably.
                                </span>
                            </span>
                        </li>

                        <li>
                            <span>
                                <span class="src">
                                    Ref-qualifiers on member functions, such as <code>
                                        void X::Foo()
                                        &amp;
                                    </code> or <code>void X::Foo() &amp;&amp;</code>, because of concerns
                                    that they're an overly obscure feature.
                                </span>
                            </span>
                        </li>




                    </ul>
                </div>

            </div>

            <h3 id="Nonstandard_Extensions">Nonstandard Extensions</h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Nonstandard extensions to C++ may not be used unless otherwise specified.
                        </span>
                    </span>
                </p>
            </div>
            <div class="stylebody">
                <div class="definition">
                    <p>
                        <span>
                            <span class="src">
                                Compilers support various extensions that are not part of standard C++.
                            </span>
                        </span>
                        <span>
                            <span class="src">
                                Such
                                extensions include GCC's <code>__attribute__</code>, intrinsic functions such
                                as <code>__builtin_prefetch</code>, designated initializers (e.g.
                                <code>Foo f = {.field = 3}</code>), inline assembly, <code>__COUNTER__</code>,
                                <code>__PRETTY_FUNCTION__</code>, compound statement expressions (e.g.
                                <code>foo = ({ int x; Bar(&amp;x); x })</code>, variable-length arrays and
                                <code>alloca()</code>, and the <code>a?:b</code> syntax.
                            </span>
                        </span>
                    </p>
                </div>

                <div class="pros">
                    <ul>
                        <li>
                            <span>
                                <span class="src">
                                    Nonstandard extensions may provide useful features that do not exist
                                    in standard C++.
                                </span>
                            </span>
                            <span>
                                <span class="src">
                                    For example, some people think that designated
                                    initializers are more readable than standard C++ features like
                                    constructors.
                                </span>
                            </span>
                        </li>
                        <li>
                            <span>
                                <span class="src">
                                    Important performance guidance to the compiler can only be specified
                                    using extensions.
                                </span>
                            </span>
                        </li>
                    </ul>
                </div>

                <div class="cons">
                    <ul>
                        <li>
                            <span>
                                <span class="src">
                                    Nonstandard extensions do not work in all compilers.
                                </span>
                            </span>
                            <span>
                                <span class="src">
                                    Use of nonstandard
                                    extensions reduces portability of code.
                                </span>
                            </span>
                        </li>
                        <li>
                            <span>
                                <span class="src">
                                    Even if they are supported in all targeted compilers, the extensions
                                    are often not well-specified, and there may be subtle behavior differences
                                    between compilers.
                                </span>
                            </span>
                        </li>
                        <li>
                            <span>
                                <span class="src">
                                    Nonstandard extensions add to the language features that a reader must
                                    know to understand the code.
                                </span>
                            </span>
                        </li>
                    </ul>
                </div>

                <div class="decision">
                    <p>
                        <span>
                            <span class="src">
                                Do not use nonstandard extensions.
                            </span>
                        </span>
                        <span>
                            <span class="src">
                                You may use portability wrappers that
                                are implemented using nonstandard extensions, so long as those wrappers

                                are provided by a designated project-wide
                                portability header.
                            </span>
                        </span>
                    </p>
                </div>
            </div>

            <h3 id="Aliases">Aliases</h3>

            <div class="summary">
                <p>
                    <span>
                        <span class="src">
                            Public aliases are for the benefit of an API's user, and should be clearly documented.
                        </span>
                    </span>
                </p>
            </div>
            <div class="stylebody">
                <div class="definition">
                    <p>
                        <span>
                            <span class="src">
                                There are several ways to create names that are aliases of other entities:
                            </span>
                        </span>
                    </p>
<pre>typedef Foo Bar;
using Bar = Foo;
using other_namespace::Foo;
</pre>

                    <p>
                        <span>
                            <span class="src">
                                Like other declarations, aliases declared in a header file are part of that
                                header's public API unless they're in a function definition, in the private portion of a class,
                                or in an explicitly-marked internal namespace.
                            </span>
                        </span>
                        <span>
                            <span class="src">
                                Aliases in such areas or in .cc files are
                                implementation details (because client code can't refer to them), and are not restricted by this
                                rule.
                            </span>
                        </span>
                    </p>
                </div>

                <div class="pros">
                    <ul>
                        <li>
                            <span>
                                <span class="src">
                                    Aliases can improve readability by simplifying a long or complicated name.
                                </span>
                            </span>
                        </li>
                        <li>
                            <span>
                                <span class="src">
                                    Aliases can reduce duplication by naming in one place a type used repeatedly in an API,
                                    which <em>might</em> make it easier to change the type later.
                                </span>
                            </span>
                        </li>
                    </ul>
                </div>

                <div class="cons">
                    <ul>
                        <li>
                            <span>
                                <span class="src">
                                    When placed in a header where client code can refer to them, aliases increase the
                                    number of entities in that header's API, increasing its complexity.
                                </span>
                            </span>
                        </li>
                        <li>
                            <span>
                                <span class="src">
                                    Clients can easily rely on unintended details of public aliases, making
                                    changes difficult.
                                </span>
                            </span>
                        </li>
                        <li>
                            <span>
                                <span class="src">
                                    It can be tempting to create a public alias that is only intended for use
                                    in the implementation, without considering its impact on the API, or on maintainability.
                                </span>
                            </span>
                        </li>
                        <li>
                            <span>
                                <span class="src">
                                    Aliases can create risk of name collisions
                                </span>
                            </span>
                        </li>
                        <li>
                            <span>
                                <span class="src">
                                    Aliases can reduce readability by giving a familiar construct an unfamiliar name
                                </span>
                            </span>
                        </li>
                        <li>
                            <span>
                                <span class="src">
                                    Type aliases can create an unclear API contract:
                                    it is unclear whether the alias is guaranteed to be identical to the type it aliases,
                                    to have the same API, or only to be usable in specified narrow ways
                                </span>
                            </span>
                        </li>
                    </ul>
                </div>

                <div class="decision">
                    <p>
                        <span>
                            <span class="src">
                                Don't put an alias in your public API just to save typing in the implementation;
                                do so only if you intend it to be used by your clients.
                            </span>
                        </span>
                    </p>
                    <p>
                        <span>
                            <span class="src">
                                When defining a public alias, document the intent of
                                the new name, including whether it is guaranteed to always be the same as the type
                                it's currently aliased to, or whether a more limited compatibility is
                                intended.
                            </span>
                        </span>
                        <span>
                            <span class="src">
                                This lets the user know whether they can treat the types as
                                substitutable or whether more specific rules must be followed, and can help the
                                implementation retain some degree of freedom to change the alias.
                            </span>
                        </span>
                    </p>
                    <p>
                        <span>
                            <span class="src">
                                Don't put namespace aliases in your public API. (See also <a href="#Namespaces">Namespaces</a>).
                            </span>
                        </span>
                    </p>

                    <p>
                        <span>
                            <span class="src">
                                For example, these aliases document how they are intended to be used in client code:
                            </span>
                        </span>
                    </p>
                    <span>
                        <span class="src">
<pre>namespace a {
// Used to store field measurements. DataPoint may change from Bar* to some internal type.
// Client code should treat it as an opaque pointer.
using DataPoint = foo::bar::Bar*;

// A set of measurements. Just an alias for user convenience.
using TimeSeries = std::unordered_set&lt;DataPoint, std::hash&lt;DataPoint&gt;, DataPointComparator&gt;;
}  // namespace a
</pre>
                        </span>
                    </span>
                    <p>
                        <span>
                            <span class="src">
                                These aliases don't document intended use, and half of them aren't meant for client use:
                            </span>
                        </span>
                    </p>
                    <span>
                        <span class="src">
<pre class="badcode">namespace a {
// Bad: none of these say how they should be used.
using DataPoint = foo::bar::Bar*;
using std::unordered_set;  // Bad: just for local convenience
using std::hash;           // Bad: just for local convenience
typedef unordered_set&lt;DataPoint, hash&lt;DataPoint&gt;, DataPointComparator&gt; TimeSeries;
}  // namespace a
</pre>
                        </span>
                    </span>
                    <p>
                        <span>
                            <span class="src">
                                However, local convenience aliases are fine in function definitions, private sections of
                                classes, explicitly marked internal namespaces, and in .cc files:
                            </span>
                        </span>
                    </p>

                    <span>
                        <span class="src">
<pre>// In a .cc file
using std::unordered_set;
</pre>
                        </span>
                    </span>

                </div>
            </div>

            <h2 id="Naming">Naming</h2>

            <p>
                The most important consistency rules are those that govern
                naming. The style of a name immediately informs us what sort of
                thing the named entity is: a type, a variable, a function, a
                constant, a macro, etc., without requiring us to search for the
                declaration of that entity. The pattern-matching engine in our
                brains relies a great deal on these naming rules.
            </p>

            <p>
                Naming rules are pretty arbitrary, but
                we feel that
                consistency is more important than individual preferences in this
                area, so regardless of whether you find them sensible or not,
                the rules are the rules.
            </p>

            <h3 id="General_Naming_Rules">General Naming Rules</h3>

            <div class="summary">
                <p>Names should be descriptive; avoid abbreviation.</p>
            </div>

            <div class="stylebody">
                <p>
                    Give as descriptive a name as possible, within reason.
                    Do not worry about saving horizontal space as it is far
                    more important to make your code immediately
                    understandable by a new reader. Do not use abbreviations
                    that are ambiguous or unfamiliar to readers outside your
                    project, and do not abbreviate by deleting letters within
                    a word.
                </p>

<pre>int price_count_reader;    // No abbreviation.
int num_errors;            // "num" is a widespread convention.
int num_dns_connections;   // Most people know what "DNS" stands for.
</pre>

<pre class="badcode">int n;                     // Meaningless.
int nerr;                  // Ambiguous abbreviation.
int n_comp_conns;          // Ambiguous abbreviation.
int wgc_connections;       // Only your group knows what this stands for.
int pc_reader;             // Lots of things can be abbreviated "pc".
int cstmr_id;              // Deletes internal letters.
</pre>

                <p>
                    Note that certain universally-known abbreviations are OK, such as
                    <code>i</code> for an iteration variable and
                    <code>T</code> for a
                    template parameter.
                </p>

                <p>
                    Template parameters should follow the naming style for their
                    category: type template parameters should follow the rules for
                    <a href="#Type_Names">type names</a>, and non-type template
                    parameters should follow the rules for
                    <a href="#Variable_Names">
                        variable names
                    </a>.

                </p>
            </div>

            <h3 id="File_Names">File Names</h3>

            <div class="summary">
                <p>
                    Filenames should be all lowercase and can include
                    underscores (
                    <code>_</code>) or dashes (
                    <code>-</code>).
                    Follow the convention that your

                    project uses. If there is no consistent
                    local pattern to follow, prefer "_".
                </p>
            </div>

            <div class="stylebody">

                <p>Examples of acceptable file names:</p>

                <ul>
                    <li>
                        <code>my_useful_class.cc</code>
                    </li>
                    <li>
                        <code>my-useful-class.cc</code>
                    </li>
                    <li>
                        <code>myusefulclass.cc</code>
                    </li>
                    <li>
                        <code>myusefulclass_test.cc // _unittest and _regtest are deprecated.</code>
                    </li>
                </ul>

                <p>
                    C++ files should end in
                    <code>.cc</code> and header files should end in
                    <code>.h</code>. Files that rely on being textually included at specific points
                    should end in
                    <code>.inc</code> (see also the section on
                    <a href="#Self_contained_Headers">self-contained headers</a>).
                </p>

                <p>
                    Do not use filenames that already exist in
                    <code>/usr/include</code>, such as
                    <code>db.h</code>.
                </p>

                <p>
                    In general, make your filenames very specific. For
                    example, use
                    <code>http_server_logs.h</code> rather than
                    <code>logs.h</code>. A very common case is to have a pair
                    of files called, e.g.,
                    <code>foo_bar.h</code> and
                    <code>foo_bar.cc</code>, defining a class called
                    <code>FooBar</code>.
                </p>

                <p>
                    Inline functions must be in a
                    <code>.h</code> file. If
                    your inline functions are very short, they should go
                    directly into your
                    <code>.h</code> file.
                </p>

            </div>

            <h3 id="Type_Names">Type Names</h3>

            <div class="summary">
                <p>
                    Type names start with a capital letter and have a capital
                    letter for each new word, with no underscores:
                    <code>MyExcitingClass</code>,
                    <code>MyExcitingEnum</code>.
                </p>
            </div>

            <div class="stylebody">

                <p>
                    The names of all types &#8212; classes, structs, type aliases,
                    enums, and type template parameters &#8212; have the same naming convention.
                    Type names should start with a capital letter and have a capital letter
                    for each new word. No underscores. For example:
                </p>

<pre>// classes and structs
class UrlTable { ...
class UrlTableTester { ...
struct UrlTableProperties { ...

// typedefs
typedef hash_map&lt;UrlTableProperties *, string&gt; PropertiesMap;

// using aliases
using PropertiesMap = hash_map&lt;UrlTableProperties *, string&gt;;

// enums
enum UrlTableErrors { ...
</pre>

            </div>

            <h3 id="Variable_Names">Variable Names</h3>

            <div class="summary">
                <p>
                    The names of variables (including function parameters) and data members are
                    all lowercase, with underscores between words. Data members of classes (but not
                    structs) additionally have trailing underscores. For instance:
                    <code>a_local_variable</code>,
                    <code>a_struct_data_member</code>,
                    <code>a_class_data_member_</code>.
                </p>
            </div>

            <div class="stylebody">

                <h4 class="stylepoint_subsection">Common Variable names</h4>

                <p>For example:</p>

<pre>string table_name;  // OK - uses underscore.
string tablename;   // OK - all lowercase.
</pre>

<pre class="badcode">string tableName;   // Bad - mixed case.
</pre>

                <h4 class="stylepoint_subsection">Class Data Members</h4>

                <p>
                    Data members of classes, both static and non-static, are
                    named like ordinary nonmember variables, but with a
                    trailing underscore.
                </p>

<pre>class TableInfo {
  ...
 private:
  string table_name_;  // OK - underscore at end.
  string tablename_;   // OK.
  static Pool&lt;TableInfo&gt;* pool_;  // OK.
};
</pre>

                <h4 class="stylepoint_subsection">Struct Data Members</h4>

                <p>
                    Data members of structs, both static and non-static,
                    are named like ordinary nonmember variables. They do not have
                    the trailing underscores that data members in classes have.
                </p>

<pre>struct UrlTableProperties {
  string name;
  int num_entries;
  static Pool&lt;UrlTableProperties&gt;* pool;
};
</pre>


                <p>
                    See
                    <a href="#Structs_vs._Classes">
                        Structs vs.
                        Classes
                    </a> for a discussion of when to use a struct
                    versus a class.
                </p>

            </div>

            <h3 id="Constant_Names">Constant Names</h3>

            <div class="summary">
                <p>
                    Variables declared constexpr or const, and whose value is fixed for
                    the duration of the program, are named with a leading "k" followed
                    by mixed case.  For example:
                </p>
            </div>

<pre>const int kDaysInAWeek = 7;
</pre>

            <div class="stylebody">

                <p>
                    All such variables with static storage duration (i.e. statics and globals,
                    see
                    <a href="http://en.cppreference.com/w/cpp/language/storage_duration#Storage_duration">
                        Storage Duration
                    </a> for details) should be named this way.  This
                    convention is optional for variables of other storage classes, e.g. automatic
                    variables, otherwise the usual variable naming rules apply.
                </p>
                <p>

                </p>
            </div>

            <h3 id="Function_Names">Function Names</h3>

            <div class="summary">
                <p>
                    Regular functions have mixed case; accessors and mutators may be named
                    like variables.
                </p>
            </div>

            <div class="stylebody">

                <p>
                    Ordinarily, functions should start with a capital letter and have a
                    capital letter for each new word
                    (a.k.a. "
                    <a href="https://en.wikipedia.org/wiki/Camel_case">
                        Camel
                        Case
                    </a>" or "Pascal case"). Such names should not have
                    underscores. Prefer to capitalize acronyms as single words
                    (i.e.
                    <code>StartRpc()</code>, not
                    <code>StartRPC()</code>).
                </p>

<pre>AddTableEntry()
DeleteUrl()
OpenFileOrDie()
</pre>

                <p>
                    (The same naming rule applies to class- and namespace-scope
                    constants that are exposed as part of an API and that are intended to look
                    like functions, because the fact that they're
                    objects rather than functions is an unimportant implementation detail.)
                </p>

                <p>
                    Accessors and mutators (get and set functions) may be named like
                    variables. These often correspond to actual member variables, but this is
                    not required. For example,
                    <code>int count()</code> and
                    <code>
                        void
                        set_count(int count)
                    </code>.
                </p>

            </div>

            <h3 id="Namespace_Names">Namespace Names</h3>

            <div class="summary">
                Namespace names are all lower-case. Top-level namespace names are
                based on the project name
                . Avoid collisions
                between nested namespaces and well-known top-level namespaces.
            </div>

            <div class="stylebody">
                <p>
                    The name of a top-level namespace should usually be the
                    name of the project or team whose code is contained in that
                    namespace. The code in that namespace should usually be in
                    a directory whose basename matches the namespace name (or
                    subdirectories thereof).
                </p>





                <p>
                    Keep in mind that the
                    <a href="#General_Naming_Rules">
                        rule
                        against abbreviated names
                    </a> applies to namespaces just as much
                    as variable names. Code inside the namespace seldom needs to
                    mention the namespace name, so there's usually no particular need
                    for abbreviation anyway.
                </p>

                <p>
                    Avoid nested namespaces that match well-known top-level
                    namespaces. Collisions between namespace names can lead to surprising
                    build breaks because of name lookup rules. In particular, do not
                    create any nested
                    <code>std</code> namespaces. Prefer unique project
                    identifiers
                    (
                    <code>websearch::index</code>,
                    <code>websearch::index_util</code>)
                    over collision-prone names like
                    <code>websearch::util</code>.
                </p>

                <p>
                    For
                    <code>internal</code> namespaces, be wary of other code being
                    added to the same
                    <code>internal</code> namespace causing a collision
                    (internal helpers within a team tend to be related and may lead to
                    collisions). In such a situation, using the filename to make a unique
                    internal name is helpful
                    (
                    <code>websearch::index::frobber_internal</code> for use
                    in
                    <code>frobber.h</code>)
                </p>

            </div>

            <h3 id="Enumerator_Names">Enumerator Names</h3>

            <div class="summary">
                <p>
                    Enumerators (for both scoped and unscoped enums) should be named
                    <i>either</i> like
                    <a href="#Constant_Names">constants</a> or like
                    <a href="#Macro_Names">macros</a>: either
                    <code>kEnumName</code> or
                    <code>ENUM_NAME</code>.
                </p>
            </div>

            <div class="stylebody">

                <p>
                    Preferably, the individual enumerators should be named
                    like
                    <a href="#Constant_Names">constants</a>. However, it
                    is also acceptable to name them like
                    <a href="#Macro_Names">macros</a>.  The enumeration name,
                    <code>UrlTableErrors</code> (and
                    <code>AlternateUrlTableErrors</code>), is a type, and
                    therefore mixed case.
                </p>

<pre>enum UrlTableErrors {
  kOK = 0,
  kErrorOutOfMemory,
  kErrorMalformedInput,
};
enum AlternateUrlTableErrors {
  OK = 0,
  OUT_OF_MEMORY = 1,
  MALFORMED_INPUT = 2,
};
</pre>

                <p>
                    Until January 2009, the style was to name enum values
                    like
                    <a href="#Macro_Names">macros</a>. This caused
                    problems with name collisions between enum values and
                    macros. Hence, the change to prefer constant-style naming
                    was put in place. New code should prefer constant-style
                    naming if possible. However, there is no reason to change
                    old code to use constant-style names, unless the old
                    names are actually causing a compile-time problem.
                </p>



            </div>

            <h3 id="Macro_Names">Macro Names</h3>

            <div class="summary">
                <p>
                    You're not really going to
                    <a href="#Preprocessor_Macros">
                        define a macro
                    </a>, are you? If you do, they're like this:
                    <code>MY_MACRO_THAT_SCARES_SMALL_CHILDREN</code>.
                </p>
            </div>

            <div class="stylebody">

                <p>
                    Please see the
                    <a href="#Preprocessor_Macros">
                        description
                        of macros
                    </a>; in general macros should
                    <em>not</em> be used.
                    However, if they are absolutely needed, then they should be
                    named with all capitals and underscores.
                </p>

<pre>#define ROUND(x) ...
#define PI_ROUNDED 3.0
</pre>

            </div>

            <h3 id="Exceptions_to_Naming_Rules">Exceptions to Naming Rules</h3>

            <div class="summary">
                <p>
                    If you are naming something that is analogous to an
                    existing C or C++ entity then you can follow the existing
                    naming convention scheme.
                </p>
            </div>

            <div class="stylebody">

                <dl>
                    <dt><code>bigopen()</code></dt>
                    <dd>function name, follows form of <code>open()</code></dd>

                    <dt><code>uint</code></dt>
                    <dd><code>typedef</code></dd>

                    <dt><code>bigpos</code></dt>
                    <dd>
                        <code>struct</code> or <code>class</code>, follows
                        form of <code>pos</code>
                    </dd>

                    <dt><code>sparse_hash_map</code></dt>
                    <dd>STL-like entity; follows STL naming conventions</dd>

                    <dt><code>LONGLONG_MAX</code></dt>
                    <dd>a constant, as in <code>INT_MAX</code></dd>
                </dl>

            </div>

            <h2 id="Comments">Comments</h2>

            <p>
                Though a pain to write, comments are absolutely vital to
                keeping our code readable. The following rules describe what
                you should comment and where. But remember: while comments are
                very important, the best code is self-documenting. Giving
                sensible names to types and variables is much better than using
                obscure names that you must then explain through comments.
            </p>

            <p>
                When writing your comments, write for your audience: the
                next
                contributor who will need to
                understand your code. Be generous &#8212; the next
                one may be you!
            </p>

            <h3 id="Comment_Style">Comment Style</h3>

            <div class="summary">
                <p>
                    Use either the
                    <code>//</code> or
                    <code>/* */</code>
                    syntax, as long as you are consistent.
                </p>
            </div>

            <div class="stylebody">

                <p>
                    You can use either the
                    <code>//</code> or the
                    <code>
                        /*
                        */
                    </code> syntax; however,
                    <code>//</code> is
                    <em>much</em> more common. Be consistent with how you
                    comment and what style you use where.
                </p>

            </div>

            <h3 id="File_Comments">File Comments</h3>

            <div class="summary">
                <p>Start each file with license boilerplate.</p>

                <p>
                    File comments describe the contents of a file. If a file declares,
                    implements, or tests exactly one abstraction that is documented by a comment
                    at the point of declaration, file comments are not required. All other files
                    must have file comments.
                </p>

            </div>

            <div class="stylebody">

                <h4 class="stylepoint_subsection">
                    Legal Notice and Author
                    Line
                </h4>



                <p>
                    Every file should contain license
                    boilerplate. Choose the appropriate boilerplate for the
                    license used by the project (for example, Apache 2.0,
                    BSD, LGPL, GPL).
                </p>

                <p>
                    If you make significant changes to a file with an
                    author line, consider deleting the author line.
                </p>

                <h4 class="stylepoint_subsection">File Contents</h4>

                <p>
                    If a
                    <code>.h</code> declares multiple abstractions, the file-level comment
                    should broadly describe the contents of the file, and how the abstractions are
                    related. A 1 or 2 sentence file-level comment may be sufficient. The detailed
                    documentation about individual abstractions belongs with those abstractions,
                    not at the file level.
                </p>

                <p>
                    Do not duplicate comments in both the
                    <code>.h</code> and the
                    <code>.cc</code>. Duplicated comments diverge.
                </p>

            </div>

            <h3 id="Class_Comments">Class Comments</h3>

            <div class="summary">
                <p>
                    Every non-obvious class declaration should have an accompanying
                    comment that describes what it is for and how it should be used.
                </p>
            </div>

            <div class="stylebody">

<pre>// Iterates over the contents of a GargantuanTable.
// Example:
//    GargantuanTableIterator* iter = table-&gt;NewIterator();
//    for (iter-&gt;Seek("foo"); !iter-&gt;done(); iter-&gt;Next()) {
//      process(iter-&gt;key(), iter-&gt;value());
//    }
//    delete iter;
class GargantuanTableIterator {
  ...
};
</pre>

                <p>
                    The class comment should provide the reader with enough information to know
                    how and when to use the class, as well as any additional considerations
                    necessary to correctly use the class. Document the synchronization assumptions
                    the class makes, if any. If an instance of the class can be accessed by
                    multiple threads, take extra care to document the rules and invariants
                    surrounding multithreaded use.
                </p>

                <p>
                    The class comment is often a good place for a small example code snippet
                    demonstrating a simple and focused usage of the class.
                </p>

                <p>
                    When sufficiently separated (e.g.
                    <code>.h</code> and
                    <code>.cc</code>
                    files), comments describing the use of the class should go together with its
                    interface definition; comments about the class operation and implementation
                    should accompany the implementation of the class's methods.
                </p>

            </div>

            <h3 id="Function_Comments">Function Comments</h3>

            <div class="summary">
                <p>
                    Declaration comments describe use of the function (when it is
                    non-obvious); comments at the definition of a function describe
                    operation.
                </p>
            </div>

            <div class="stylebody">

                <h4 class="stylepoint_subsection">Function Declarations</h4>

                <p>
                    Almost every function declaration should have comments immediately
                    preceding it that describe what the function does and how to use
                    it. These comments may be omitted only if the function is simple and
                    obvious (e.g. simple accessors for obvious properties of the
                    class).  These comments should be descriptive ("Opens the file")
                    rather than imperative ("Open the file"); the comment describes the
                    function, it does not tell the function what to do. In general, these
                    comments do not describe how the function performs its task. Instead,
                    that should be left to comments in the function definition.
                </p>

                <p>
                    Types of things to mention in comments at the function
                    declaration:
                </p>

                <ul>
                    <li>What the inputs and outputs are.</li>

                    <li>
                        For class member functions: whether the object
                        remembers reference arguments beyond the duration of
                        the method call, and whether it will free them or
                        not.
                    </li>

                    <li>
                        If the function allocates memory that the caller
                        must free.
                    </li>

                    <li>
                        Whether any of the arguments can be a null
                        pointer.
                    </li>

                    <li>
                        If there are any performance implications of how a
                        function is used.
                    </li>

                    <li>
                        If the function is re-entrant. What are its
                        synchronization assumptions?
                    </li>
                </ul>

                <p>Here is an example:</p>

<pre>// Returns an iterator for this table.  It is the client's
// responsibility to delete the iterator when it is done with it,
// and it must not use the iterator once the GargantuanTable object
// on which the iterator was created has been deleted.
//
// The iterator is initially positioned at the beginning of the table.
//
// This method is equivalent to:
//    Iterator* iter = table-&gt;NewIterator();
//    iter-&gt;Seek("");
//    return iter;
// If you are going to immediately seek to another place in the
// returned iterator, it will be faster to use NewIterator()
// and avoid the extra seek.
Iterator* GetIterator() const;
</pre>

                <p>
                    However, do not be unnecessarily verbose or state the
                    completely obvious. Notice below that it is not necessary
                    to say "returns false otherwise" because this is
                    implied.
                </p>

<pre>// Returns true if the table cannot hold any more entries.
bool IsTableFull();
</pre>

                <p>
                    When documenting function overrides, focus on the
                    specifics of the override itself, rather than repeating
                    the comment from the overridden function.  In many of these
                    cases, the override needs no additional documentation and
                    thus no comment is required.
                </p>

                <p>
                    When commenting constructors and destructors, remember
                    that the person reading your code knows what constructors
                    and destructors are for, so comments that just say
                    something like "destroys this object" are not useful.
                    Document what constructors do with their arguments (for
                    example, if they take ownership of pointers), and what
                    cleanup the destructor does. If this is trivial, just
                    skip the comment. It is quite common for destructors not
                    to have a header comment.
                </p>

                <h4 class="stylepoint_subsection">Function Definitions</h4>

                <p>
                    If there is anything tricky about how a function does
                    its job, the function definition should have an
                    explanatory comment. For example, in the definition
                    comment you might describe any coding tricks you use,
                    give an overview of the steps you go through, or explain
                    why you chose to implement the function in the way you
                    did rather than using a viable alternative. For instance,
                    you might mention why it must acquire a lock for the
                    first half of the function but why it is not needed for
                    the second half.
                </p>

                <p>
                    Note you should
                    <em>not</em> just repeat the comments
                    given with the function declaration, in the
                    <code>.h</code> file or wherever. It's okay to
                    recapitulate briefly what the function does, but the
                    focus of the comments should be on how it does it.
                </p>

            </div>

            <h3 id="Variable_Comments">Variable Comments</h3>

            <div class="summary">
                <p>
                    In general the actual name of the variable should be
                    descriptive enough to give a good idea of what the variable
                    is used for. In certain cases, more comments are required.
                </p>
            </div>

            <div class="stylebody">

                <h4 class="stylepoint_subsection">Class Data Members</h4>

                <p>
                    The purpose of each class data member (also called an instance
                    variable or member variable) must be clear. If there are any
                    invariants (special values, relationships between members, lifetime
                    requirements) not clearly expressed by the type and name, they must be
                    commented. However, if the type and name suffice (
                    <code>
                        int
                        num_events_;
                    </code>), no comment is needed.
                </p>

                <p>
                    In particular, add comments to describe the existence and meaning
                    of sentinel values, such as nullptr or -1, when they are not
                    obvious. For example:
                </p>

<pre>private:
 // Used to bounds-check table accesses. -1 means
 // that we don't yet know how many entries the table has.
 int num_total_entries_;
</pre>

                <h4 class="stylepoint_subsection">Global Variables</h4>

                <p>
                    All global variables should have a comment describing what they
                    are, what they are used for, and (if unclear) why it needs to be
                    global. For example:
                </p>

<pre>// The total number of tests cases that we run through in this regression test.
const int kNumTestCases = 6;
</pre>

            </div>

            <h3 id="Implementation_Comments">Implementation Comments</h3>

            <div class="summary">
                <p>
                    In your implementation you should have comments in tricky,
                    non-obvious, interesting, or important parts of your code.
                </p>
            </div>

            <div class="stylebody">

                <h4 class="stylepoint_subsection">Explanatory Comments</h4>

                <p>
                    Tricky or complicated code blocks should have comments
                    before them. Example:
                </p>

<pre>// Divide result by two, taking into account that x
// contains the carry from the add.
for (int i = 0; i &lt; result-&gt;size(); i++) {
  x = (x &lt;&lt; 8) + (*result)[i];
  (*result)[i] = x &gt;&gt; 1;
  x &amp;= 1;
}
</pre>

                <h4 class="stylepoint_subsection">Line Comments</h4>

                <p>
                    Also, lines that are non-obvious should get a comment
                    at the end of the line. These end-of-line comments should
                    be separated from the code by 2 spaces. Example:
                </p>

<pre>// If we have enough memory, mmap the data portion too.
mmap_budget = max&lt;int64&gt;(0, mmap_budget - index_-&gt;length());
if (mmap_budget &gt;= data_size_ &amp;&amp; !MmapData(mmap_chunk_bytes, mlock))
  return;  // Error already logged.
</pre>

                <p>
                    Note that there are both comments that describe what
                    the code is doing, and comments that mention that an
                    error has already been logged when the function
                    returns.
                </p>

                <p>
                    If you have several comments on subsequent lines, it
                    can often be more readable to line them up:
                </p>

<pre>DoSomething();                  // Comment here so the comments line up.
DoSomethingElseThatIsLonger();  // Two spaces between the code and the comment.
{ // One space before comment when opening a new scope is allowed,
  // thus the comment lines up with the following comments and code.
  DoSomethingElse();  // Two spaces before line comments normally.
}
std::vector&lt;string&gt; list{
                    // Comments in braced lists describe the next element...
                    "First item",
                    // .. and should be aligned appropriately.
                    "Second item"};
DoSomething(); /* For trailing block comments, one space is fine. */
</pre>

                <h4 class="stylepoint_subsection">Function Argument Comments</h4>

                <p>
                    When the meaning of a function argument is nonobvious, consider
                    one of the following remedies:
                </p>

                <ul>
                    <li>
                        If the argument is a literal constant, and the same constant is
                        used in multiple function calls in a way that tacitly assumes they're
                        the same, you should use a named constant to make that constraint
                        explicit, and to guarantee that it holds.
                    </li>

                    <li>
                        Consider changing the function signature to replace a
                        <code>bool</code>
                        argument with an
                        <code>enum</code> argument. This will make the argument
                        values self-describing.
                    </li>

                    <li>
                        For functions that have several configuration options, consider
                        defining a single class or struct to hold all the options
                        ,
                        and pass an instance of that.
                        This approach has several advantages. Options are referenced by name
                        at the call site, which clarifies their meaning. It also reduces
                        function argument count, which makes function calls easier to read and
                        write. As an added benefit, you don't have to change call sites when
                        you add another option.
                    </li>

                    <li>Replace large or complex nested expressions with named variables.</li>

                    <li>
                        As a last resort, use comments to clarify argument meanings at the
                        call site.
                    </li>
                </ul>

                Consider the following example:

<pre class="badcode">// What are these arguments?
const DecimalNumber product = CalculateProduct(values, 7, false, nullptr);
</pre>

                <p>versus:</p>

<pre>ProductOptions options;
options.set_precision_decimals(7);
options.set_use_cache(ProductOptions::kDontUseCache);
const DecimalNumber product =
    CalculateProduct(values, options, /*completion_callback=*/nullptr);
</pre>

                <h4 class="stylepoint_subsection">Don'ts</h4>

                <p>
                    Do not state the obvious. In particular, don't literally describe what
                    code does, unless the behavior is nonobvious to a reader who understands
                    C++ well. Instead, provide higher level comments that describe
                    <i>why</i>
                    the code does what it does, or make the code self describing.
                </p>

                Compare this:

<pre class="badcode">// Find the element in the vector.  &lt;-- Bad: obvious!
auto iter = std::find(v.begin(), v.end(), element);
if (iter != v.end()) {
  Process(element);
}
</pre>

                To this:

<pre>// Process "element" unless it was already processed.
auto iter = std::find(v.begin(), v.end(), element);
if (iter != v.end()) {
  Process(element);
}
</pre>

                Self-describing code doesn't need a comment. The comment from
                the example above would be obvious:

<pre>if (!IsAlreadyProcessed(element)) {
  Process(element);
}
</pre>

            </div>

            <h3 id="Punctuation,_Spelling_and_Grammar">Punctuation, Spelling and Grammar</h3>

            <div class="summary">
                <p>
                    Pay attention to punctuation, spelling, and grammar; it is
                    easier to read well-written comments than badly written
                    ones.
                </p>
            </div>

            <div class="stylebody">

                <p>
                    Comments should be as readable as narrative text, with
                    proper capitalization and punctuation. In many cases,
                    complete sentences are more readable than sentence
                    fragments. Shorter comments, such as comments at the end
                    of a line of code, can sometimes be less formal, but you
                    should be consistent with your style.
                </p>

                <p>
                    Although it can be frustrating to have a code reviewer
                    point out that you are using a comma when you should be
                    using a semicolon, it is very important that source code
                    maintain a high level of clarity and readability. Proper
                    punctuation, spelling, and grammar help with that
                    goal.
                </p>

            </div>

            <h3 id="TODO_Comments">TODO Comments</h3>

            <div class="summary">
                <p>
                    Use
                    <code>TODO</code> comments for code that is temporary,
                    a short-term solution, or good-enough but not perfect.
                </p>
            </div>

            <div class="stylebody">

                <p>
                    <code>TODO</code>s should include the string
                    <code>TODO</code> in all caps, followed by the

                    name, e-mail address, bug ID, or other
                    identifier
                    of the person or issue with the best context
                    about the problem referenced by the
                    <code>TODO</code>. The
                    main purpose is to have a consistent
                    <code>TODO</code> that
                    can be searched to find out how to get more details upon
                    request. A
                    <code>TODO</code> is not a commitment that the
                    person referenced will fix the problem. Thus when you create
                    a
                    <code>TODO</code> with a name, it is almost always your
                    name that is given.
                </p>



                <div>
<pre>// TODO(kl@gmail.com): Use a "*" here for concatenation operator.
// TODO(Zeke) change this to use relations.
// TODO(bug 12345): remove the "Last visitors" feature
</pre>
                </div>

                <p>
                    If your
                    <code>TODO</code> is of the form "At a future
                    date do something" make sure that you either include a
                    very specific date ("Fix by November 2005") or a very
                    specific event ("Remove this code when all clients can
                    handle XML responses.").
                </p>

            </div>

            <h3 id="Deprecation_Comments">Deprecation Comments</h3>

            <div class="summary">
                <p>
                    Mark deprecated interface points with
                    <code>DEPRECATED</code>
                    comments.
                </p>
            </div>

            <div class="stylebody">

                <p>
                    You can mark an interface as deprecated by writing a
                    comment containing the word
                    <code>DEPRECATED</code> in
                    all caps. The comment goes either before the declaration
                    of the interface or on the same line as the
                    declaration.
                </p>



                <p>
                    After the word
                    <code>DEPRECATED</code>, write your name, e-mail address,
                    or other identifier in parentheses.
                </p>

                <p>
                    A deprecation comment must include simple, clear
                    directions for people to fix their callsites. In C++, you
                    can implement a deprecated function as an inline function
                    that calls the new interface point.
                </p>

                <p>
                    Marking an interface point
                    <code>DEPRECATED</code>
                    will not magically cause any callsites to change. If you
                    want people to actually stop using the deprecated
                    facility, you will have to fix the callsites yourself or
                    recruit a crew to help you.
                </p>

                <p>
                    New code should not contain calls to deprecated
                    interface points. Use the new interface point instead. If
                    you cannot understand the directions, find the person who
                    created the deprecation and ask them for help using the
                    new interface point.
                </p>



            </div>

            <h2 id="Formatting">Formatting</h2>

            <p>
                Coding style and formatting are pretty arbitrary, but a

                project is much easier to follow
                if everyone uses the same style. Individuals may not agree with every
                aspect of the formatting rules, and some of the rules may take
                some getting used to, but it is important that all

                project contributors follow the
                style rules so that
                they can all read and understand
                everyone's code easily.
            </p>



            <p>
                To help you format code correctly, we've
                created a
                <a href="https://raw.githubusercontent.com/google/styleguide/gh-pages/google-c-style.el">
                    settings file for emacs
                </a>.
            </p>

            <h3 id="Line_Length">Line Length</h3>

            <div class="summary">
                <p>
                    Each line of text in your code should be at most 80
                    characters long.
                </p>
            </div>

            <div class="stylebody">



                <p>
                    We recognize that this rule is
                    controversial, but so much existing code already adheres
                    to it, and we feel that consistency is important.
                </p>

                <div class="pros">
                    <p>
                        Those who favor  this rule
                        argue that it is rude to force them to resize
                        their windows and there is no need for anything longer.
                        Some folks are used to having several code windows
                        side-by-side, and thus don't have room to widen their
                        windows in any case. People set up their work environment
                        assuming a particular maximum window width, and 80
                        columns has been the traditional standard. Why change
                        it?
                    </p>
                </div>

                <div class="cons">
                    <p>
                        Proponents of change argue that a wider line can make
                        code more readable. The 80-column limit is an hidebound
                        throwback to 1960s mainframes;  modern equipment has wide screens that
                        can easily show longer lines.
                    </p>
                </div>

                <div class="decision">
                    <p> 80 characters is the maximum.</p>

                    <p class="exception">
                        Comment lines can be longer than 80
                        characters if it is not feasible to split them without
                        harming readability, ease of cut and paste or auto-linking
                        -- e.g. if a line contains an example command or a literal
                        URL longer than 80 characters.
                    </p>

                    <p class="exception">
                        A raw-string literal may have content
                        that exceeds 80 characters.  Except for test code, such literals
                        should appear near the top of a file.
                    </p>

                    <p class="exception">
                        An
                        <code>#include</code> statement with a
                        long path may exceed 80 columns.
                    </p>

                    <p class="exception">
                        You needn't be concerned about
                        <a href="#The__define_Guard">header guards</a> that exceed
                        the maximum length.
                    </p>
                </div>

            </div>

            <h3 id="Non-ASCII_Characters">Non-ASCII Characters</h3>

            <div class="summary">
                <p>
                    Non-ASCII characters should be rare, and must use UTF-8
                    formatting.
                </p>
            </div>

            <div class="stylebody">

                <p>
                    You shouldn't hard-code user-facing text in source,
                    even English, so use of non-ASCII characters should be
                    rare. However, in certain cases it is appropriate to
                    include such words in your code. For example, if your
                    code parses data files from foreign sources, it may be
                    appropriate to hard-code the non-ASCII string(s) used in
                    those data files as delimiters. More commonly, unittest
                    code (which does not  need to be localized) might
                    contain non-ASCII strings. In such cases, you should use
                    UTF-8, since that is  an encoding
                    understood by most tools able to handle more than just
                    ASCII.
                </p>

                <p>
                    Hex encoding is also OK, and encouraged where it
                    enhances readability &#8212; for example,
                    <code>"\xEF\xBB\xBF"</code>, or, even more simply,
                    <code>u8"\uFEFF"</code>, is the Unicode zero-width
                    no-break space character, which would be invisible if
                    included in the source as straight UTF-8.
                </p>

                <p>
                    Use the
                    <code>u8</code> prefix
                    to guarantee that a string literal containing
                    <code>\uXXXX</code> escape sequences is encoded as UTF-8.
                    Do not use it for strings containing non-ASCII characters
                    encoded as UTF-8, because that will produce incorrect
                    output if the compiler does not interpret the source file
                    as UTF-8.
                </p>

                <p>
                    You shouldn't use the C++11
                    <code>char16_t</code> and
                    <code>char32_t</code> character types, since they're for
                    non-UTF-8 text. For similar reasons you also shouldn't
                    use
                    <code>wchar_t</code> (unless you're writing code that
                    interacts with the Windows API, which uses
                    <code>wchar_t</code> extensively).
                </p>

            </div>

            <h3 id="Spaces_vs._Tabs">Spaces vs. Tabs</h3>

            <div class="summary">
                <p>Use only spaces, and indent 2 spaces at a time.</p>
            </div>

            <div class="stylebody">

                <p>
                    We use spaces for indentation. Do not use tabs in your
                    code. You should set your editor to emit spaces when you
                    hit the tab key.
                </p>

            </div>

            <h3 id="Function_Declarations_and_Definitions">Function Declarations and Definitions</h3>

            <div class="summary">
                <p>
                    Return type on the same line as function name, parameters
                    on the same line if they fit. Wrap parameter lists which do
                    not fit on a single line as you would wrap arguments in a
                    <a href="#Function_Calls">function call</a>.
                </p>
            </div>

            <div class="stylebody">

                <p>Functions look like this:</p>


<pre>ReturnType ClassName::FunctionName(Type par_name1, Type par_name2) {
  DoSomething();
  ...
}
</pre>

                <p>If you have too much text to fit on one line:</p>

<pre>ReturnType ClassName::ReallyLongFunctionName(Type par_name1, Type par_name2,
                                             Type par_name3) {
  DoSomething();
  ...
}
</pre>

                <p>or if you cannot fit even the first parameter:</p>

<pre>ReturnType LongClassName::ReallyReallyReallyLongFunctionName(
    Type par_name1,  // 4 space indent
    Type par_name2,
    Type par_name3) {
  DoSomething();  // 2 space indent
  ...
}
</pre>

                <p>Some points to note:</p>

                <ul>
                    <li>Choose good parameter names.</li>

                    <li>
                        Parameter names may be omitted only if the parameter is unused and its
                        purpose is obvious.
                    </li>

                    <li>
                        If you cannot fit the return type and the function
                        name on a single line, break between them.
                    </li>

                    <li>
                        If you break after the return type of a function
                        declaration or definition, do not indent.
                    </li>

                    <li>
                        The open parenthesis is always on the same line as
                        the function name.
                    </li>

                    <li>
                        There is never a space between the function name
                        and the open parenthesis.
                    </li>

                    <li>
                        There is never a space between the parentheses and
                        the parameters.
                    </li>

                    <li>
                        The open curly brace is always on the end of the last line of the function
                        declaration, not the start of the next line.
                    </li>

                    <li>
                        The close curly brace is either on the last line by
                        itself or on the same line as the open curly brace.
                    </li>

                    <li>
                        There should be a space between the close
                        parenthesis and the open curly brace.
                    </li>

                    <li>All parameters should be aligned if possible.</li>

                    <li>Default indentation is 2 spaces.</li>

                    <li>Wrapped parameters have a 4 space indent.</li>
                </ul>

                <p>Unused parameters that are obvious from context may be omitted:</p>

<pre>class Foo {
 public:
  Foo(Foo&amp;&amp;);
  Foo(const Foo&amp;);
  Foo&amp; operator=(Foo&amp;&amp;);
  Foo&amp; operator=(const Foo&amp;);
};
</pre>

                <p>
                    Unused parameters that might not be obvious should comment out the variable
                    name in the function definition:
                </p>

<pre>class Shape {
 public:
  virtual void Rotate(double radians) = 0;
};

class Circle : public Shape {
 public:
  void Rotate(double radians) override;
};

void Circle::Rotate(double /*radians*/) {}
</pre>

<pre class="badcode">// Bad - if someone wants to implement later, it's not clear what the
// variable means.
void Circle::Rotate(double) {}
</pre>

                <p>
                    Attributes, and macros that expand to attributes, appear at the very
                    beginning of the function declaration or definition, before the
                    return type:
                </p>
<pre>MUST_USE_RESULT bool IsOK();
</pre>

            </div>

            <h3 id="Formatting_Lambda_Expressions">Lambda Expressions</h3>

            <div class="summary">
                <p>
                    Format parameters and bodies as for any other function, and capture
                    lists like other comma-separated lists.
                </p>
            </div>

            <div class="stylebody">
                <p>
                    For by-reference captures, do not leave a space between the
                    ampersand (&amp;) and the variable name.
                </p>
<pre>int x = 0;
auto x_plus_n = [&amp;x](int n) -&gt; int { return x + n; }
</pre>
                <p>Short lambdas may be written inline as function arguments.</p>
<pre>std::set&lt;int&gt; blacklist = {7, 8, 9};
std::vector&lt;int&gt; digits = {3, 9, 1, 8, 4, 7, 1};
digits.erase(std::remove_if(digits.begin(), digits.end(), [&amp;blacklist](int i) {
               return blacklist.find(i) != blacklist.end();
             }),
             digits.end());
</pre>

            </div>

            <h3 id="Function_Calls">Function Calls</h3>

            <div class="summary">
                <p>
                    Either write the call all on a single line, wrap the
                    arguments at the parenthesis, or start the arguments on a new
                    line indented by four spaces and continue at that 4 space
                    indent. In the absence of other considerations, use the
                    minimum number of lines, including placing multiple arguments
                    on each line where appropriate.
                </p>
            </div>

            <div class="stylebody">

                <p>Function calls have the following format:</p>
<pre>bool result = DoSomething(argument1, argument2, argument3);
</pre>

                <p>
                    If the arguments do not all fit on one line, they
                    should be broken up onto multiple lines, with each
                    subsequent line aligned with the first argument. Do not
                    add spaces after the open paren or before the close
                    paren:
                </p>
<pre>bool result = DoSomething(averyveryveryverylongargument1,
                          argument2, argument3);
</pre>

                <p>
                    Arguments may optionally all be placed on subsequent
                    lines with a four space indent:
                </p>
<pre>if (...) {
  ...
  ...
  if (...) {
    bool result = DoSomething(
        argument1, argument2,  // 4 space indent
        argument3, argument4);
    ...
  }
</pre>

                <p>
                    Put multiple arguments on a single line to reduce the
                    number of lines necessary for calling a function unless
                    there is a specific readability problem. Some find that
                    formatting with strictly one argument on each line is
                    more readable and simplifies editing of the arguments.
                    However, we prioritize for the reader over the ease of
                    editing arguments, and most readability problems are
                    better addressed with the following techniques.
                </p>

                <p>
                    If having multiple arguments in a single line decreases
                    readability due to the complexity or confusing nature of the
                    expressions that make up some arguments, try creating
                    variables that capture those arguments in a descriptive name:
                </p>
<pre>int my_heuristic = scores[x] * y + bases[x];
bool result = DoSomething(my_heuristic, x, y, z);
</pre>

                <p>
                    Or put the confusing argument on its own line with
                    an explanatory comment:
                </p>
<pre>bool result = DoSomething(scores[x] * y + bases[x],  // Score heuristic.
                          x, y, z);
</pre>

                <p>
                    If there is still a case where one argument is
                    significantly more readable on its own line, then put it on
                    its own line. The decision should be specific to the argument
                    which is made more readable rather than a general policy.
                </p>

                <p>
                    Sometimes arguments form a structure that is important
                    for readability. In those cases, feel free to format the
                    arguments according to that structure:
                </p>
<pre>// Transform the widget by a 3x3 matrix.
my_widget.Transform(x1, x2, x3,
                    y1, y2, y3,
                    z1, z2, z3);
</pre>

            </div>

            <h3 id="Braced_Initializer_List_Format">Braced Initializer List Format</h3>

            <div class="summary">
                <p>
                    Format a
                    <a href="#Braced_Initializer_List">braced initializer list</a>
                    exactly like you would format a function call in its place.
                </p>
            </div>

            <div class="stylebody">

                <p>
                    If the braced list follows a name (e.g. a type or
                    variable name), format as if the
                    <code>{}</code> were the
                    parentheses of a function call with that name. If there
                    is no name, assume a zero-length name.
                </p>

<pre>// Examples of braced init list on a single line.
return {foo, bar};
functioncall({foo, bar});
std::pair&lt;int, int&gt; p{foo, bar};

// When you have to wrap.
SomeFunction(
    {"assume a zero-length name before {"},
    some_other_function_parameter);
SomeType variable{
    some, other, values,
    {"assume a zero-length name before {"},
    SomeOtherType{
        "Very long string requiring the surrounding breaks.",
        some, other values},
    SomeOtherType{"Slightly shorter string",
                  some, other, values}};
SomeType variable{
    "This is too long to fit all in one line"};
MyType m = {  // Here, you could also break before {.
    superlongvariablename1,
    superlongvariablename2,
    {short, interior, list},
    {interiorwrappinglist,
     interiorwrappinglist2}};
</pre>

            </div>

            <h3 id="Conditionals">Conditionals</h3>

            <div class="summary">
                <p>
                    Prefer no spaces inside parentheses. The
                    <code>if</code>
                    and
                    <code>else</code> keywords belong on separate lines.
                </p>
            </div>

            <div class="stylebody">

                <p>
                    There are two acceptable formats for a basic
                    conditional statement. One includes spaces between the
                    parentheses and the condition, and one does not.
                </p>

                <p>
                    The most common form is without spaces. Either is
                    fine, but
                    <em>be consistent</em>. If you are modifying a
                    file, use the format that is already present. If you are
                    writing new code, use the format that the other files in
                    that directory or project use. If in doubt and you have
                    no personal preference, do not add the spaces.
                </p>

<pre>if (condition) {  // no spaces inside parentheses
  ...  // 2 space indent.
} else if (...) {  // The else goes on the same line as the closing brace.
  ...
} else {
  ...
}
</pre>

                <p>
                    If you prefer you may add spaces inside the
                    parentheses:
                </p>

<pre>if ( condition ) {  // spaces inside parentheses - rare
  ...  // 2 space indent.
} else {  // The else goes on the same line as the closing brace.
  ...
}
</pre>

                <p>
                    Note that in all cases you must have a space between
                    the
                    <code>if</code> and the open parenthesis. You must
                    also have a space between the close parenthesis and the
                    curly brace, if you're using one.
                </p>

<pre class="badcode">if(condition) {   // Bad - space missing after IF.
if (condition){   // Bad - space missing before {.
if(condition){    // Doubly bad.
</pre>

<pre>if (condition) {  // Good - proper space after IF and before {.
</pre>

                <p>
                    Short conditional statements may be written on one
                    line if this enhances readability. You may use this only
                    when the line is brief and the statement does not use the
                    <code>else</code> clause.
                </p>

<pre>if (x == kFoo) return new Foo();
if (x == kBar) return new Bar();
</pre>

                <p>
                    This is not allowed when the if statement has an
                    <code>else</code>:
                </p>

<pre class="badcode">// Not allowed - IF statement on one line when there is an ELSE clause
if (x) DoThis();
else DoThat();
</pre>

                <p>
                    In general, curly braces are not required for
                    single-line statements, but they are allowed if you like
                    them; conditional or loop statements with complex
                    conditions or statements may be more readable with curly
                    braces. Some
                    projects require that an
                    <code>if</code> must always always have an accompanying
                    brace.
                </p>

<pre>if (condition)
  DoSomething();  // 2 space indent.

if (condition) {
  DoSomething();  // 2 space indent.
}
</pre>

                <p>
                    However, if one part of an
                    <code>if</code>-
                    <code>else</code> statement uses curly
                    braces, the other part must too:
                </p>

<pre class="badcode">// Not allowed - curly on IF but not ELSE
if (condition) {
  foo;
} else
  bar;

// Not allowed - curly on ELSE but not IF
if (condition)
  foo;
else {
  bar;
}
</pre>

<pre>// Curly braces around both IF and ELSE required because
// one of the clauses used braces.
if (condition) {
  foo;
} else {
  bar;
}
</pre>

            </div>

            <h3 id="Loops_and_Switch_Statements">Loops and Switch Statements</h3>

            <div class="summary">
                <p>
                    Switch statements may use braces for blocks. Annotate
                    non-trivial fall-through between cases.
                    Braces are optional for single-statement loops.
                    Empty loop bodies should use empty braces or
                    <code>continue</code>.
                </p>
            </div>

            <div class="stylebody">

                <p>
                    <code>case</code> blocks in
                    <code>switch</code>
                    statements can have curly braces or not, depending on
                    your preference. If you do include curly braces they
                    should be placed as shown below.
                </p>

                <p>
                    If not conditional on an enumerated value, switch
                    statements should always have a
                    <code>default</code> case
                    (in the case of an enumerated value, the compiler will
                    warn you if any values are not handled). If the default
                    case should never execute, simply
                    <code>assert</code>:
                </p>



                <div>
<pre>switch (var) {
  case 0: {  // 2 space indent
    ...      // 4 space indent
    break;
  }
  case 1: {
    ...
    break;
  }
  default: {
    assert(false);
  }
}
</pre>
                </div>





                <p> Braces are optional for single-statement loops.</p>

<pre>for (int i = 0; i &lt; kSomeNumber; ++i)
  printf("I love you\n");

for (int i = 0; i &lt; kSomeNumber; ++i) {
  printf("I take it back\n");
}
</pre>


                <p>
                    Empty loop bodies should use an empty pair of braces or
                    <code>continue</code>,
                    but not a single semicolon.
                </p>

<pre>while (condition) {
  // Repeat test until it returns false.
}
for (int i = 0; i &lt; kSomeNumber; ++i) {}  // Good - one newline is also OK.
while (condition) continue;  // Good - continue indicates no logic.
</pre>

<pre class="badcode">while (condition);  // Bad - looks like part of do/while loop.
</pre>

            </div>

            <h3 id="Pointer_and_Reference_Expressions">Pointer and Reference Expressions</h3>

            <div class="summary">
                <p>
                    No spaces around period or arrow. Pointer operators do not
                    have trailing spaces.
                </p>
            </div>

            <div class="stylebody">

                <p>
                    The following are examples of correctly-formatted
                    pointer and reference expressions:
                </p>

<pre>x = *p;
p = &amp;x;
x = r.y;
x = r-&gt;y;
</pre>

                <p>Note that:</p>

                <ul>
                    <li>
                        There are no spaces around the period or arrow when
                        accessing a member.
                    </li>

                    <li>
                        Pointer operators have no space after the
                        <code>*</code> or
                        <code>&amp;</code>.
                    </li>
                </ul>

                <p>
                    When declaring a pointer variable or argument, you may
                    place the asterisk adjacent to either the type or to the
                    variable name:
                </p>

<pre>// These are fine, space preceding.
char *c;
const string &amp;str;

// These are fine, space following.
char* c;
const string&amp; str;
</pre>

                It is allowed (if unusual) to declare multiple variables in the same
                declaration, but it is disallowed if any of those have pointer or
                reference decorations. Such declarations are easily misread.
<pre>// Fine if helpful for readability.
int x, y;
</pre>
<pre class="badcode">int x, *y;  // Disallowed - no &amp; or * in multiple declaration
char * c;  // Bad - spaces on both sides of *
const string &amp; str;  // Bad - spaces on both sides of &amp;
</pre>

                <p>
                    You should do this consistently within a single
                    file,
                    so, when modifying an existing file, use the style in
                    that file.
                </p>

            </div>

            <h3 id="Boolean_Expressions">Boolean Expressions</h3>

            <div class="summary">
                <p>
                    When you have a boolean expression that is longer than the
                    <a href="#Line_Length">standard line length</a>, be
                    consistent in how you break up the lines.
                </p>
            </div>

            <div class="stylebody">

                <p>
                    In this example, the logical AND operator is always at
                    the end of the lines:
                </p>

<pre>if (this_one_thing &gt; this_other_thing &amp;&amp;
    a_third_thing == a_fourth_thing &amp;&amp;
    yet_another &amp;&amp; last_one) {
  ...
}
</pre>

                <p>
                    Note that when the code wraps in this example, both of
                    the
                    <code>&amp;&amp;</code> logical AND operators are at
                    the end of the line. This is more common in Google code,
                    though wrapping all operators at the beginning of the
                    line is also allowed. Feel free to insert extra
                    parentheses judiciously because they can be very helpful
                    in increasing readability when used
                    appropriately. Also note that you should always use
                    the punctuation operators, such as
                    <code>&amp;&amp;</code> and
                    <code>~</code>, rather than
                    the word operators, such as
                    <code>and</code> and
                    <code>compl</code>.
                </p>

            </div>

            <h3 id="Return_Values">Return Values</h3>

            <div class="summary">
                <p>
                    Do not needlessly surround the
                    <code>return</code>
                    expression with parentheses.
                </p>
            </div>

            <div class="stylebody">

                <p>
                    Use parentheses in
                    <code>return expr;</code> only
                    where you would use them in
                    <code>x = expr;</code>.
                </p>

<pre>return result;                  // No parentheses in the simple case.
// Parentheses OK to make a complex expression more readable.
return (some_long_condition &amp;&amp;
        another_condition);
</pre>

<pre class="badcode">return (value);                // You wouldn't write var = (value);
return(result);                // return is not a function!
</pre>

            </div>



            <h3 id="Variable_and_Array_Initialization">Variable and Array Initialization</h3>

            <div class="summary">
                <p>
                    Your choice of
                    <code>=</code>,
                    <code>()</code>, or
                    <code>{}</code>.
                </p>
            </div>

            <div class="stylebody">

                <p>
                    You may choose between
                    <code>=</code>,
                    <code>()</code>, and
                    <code>{}</code>; the following are
                    all correct:
                </p>

<pre>int x = 3;
int x(3);
int x{3};
string name = "Some Name";
string name("Some Name");
string name{"Some Name"};
</pre>

                <p>
                    Be careful when using a braced initialization list
                    <code>{...}</code>
                    on a type with an
                    <code>std::initializer_list</code> constructor.
                    A nonempty
                    <i>braced-init-list</i> prefers the
                    <code>std::initializer_list</code> constructor whenever
                    possible. Note that empty braces
                    <code>{}</code> are special, and
                    will call a default constructor if available. To force the
                    non-
                    <code>std::initializer_list</code> constructor, use parentheses
                    instead of braces.
                </p>

<pre>std::vector&lt;int&gt; v(100, 1);  // A vector of 100 1s.
std::vector&lt;int&gt; v{100, 1};  // A vector of 100, 1.
</pre>

                <p>
                    Also, the brace form prevents narrowing of integral
                    types. This can prevent some types of programming
                    errors.
                </p>

<pre>int pi(3.14);  // OK -- pi == 3.
int pi{3.14};  // Compile error: narrowing conversion.
</pre>

            </div>

            <h3 id="Preprocessor_Directives">Preprocessor Directives</h3>

            <div class="summary">
                <p>
                    The hash mark that starts a preprocessor directive should
                    always be at the beginning of the line.
                </p>
            </div>

            <div class="stylebody">

                <p>
                    Even when preprocessor directives are within the body
                    of indented code, the directives should start at the
                    beginning of the line.
                </p>

<pre>// Good - directives at beginning of line
  if (lopsided_score) {
#if DISASTER_PENDING      // Correct -- Starts at beginning of line
    DropEverything();
# if NOTIFY               // OK but not required -- Spaces after #
    NotifyClient();
# endif
#endif
    BackToNormal();
  }
</pre>

<pre class="badcode">// Bad - indented directives
  if (lopsided_score) {
    #if DISASTER_PENDING  // Wrong!  The "#if" should be at beginning of line
    DropEverything();
    #endif                // Wrong!  Do not indent "#endif"
    BackToNormal();
  }
</pre>

            </div>

            <h3 id="Class_Format">Class Format</h3>

            <div class="summary">
                <p>
                    Sections in
                    <code>public</code>,
                    <code>protected</code> and
                    <code>private</code> order, each indented one space.
                </p>
            </div>

            <div class="stylebody">

                <p>
                    The basic format for a class definition (lacking the
                    comments, see
                    <a href="#Class_Comments">
                        Class
                        Comments
                    </a> for a discussion of what comments are
                    needed) is:
                </p>

<pre>class MyClass : public OtherClass {
 public:      // Note the 1 space indent!
  MyClass();  // Regular 2 space indent.
  explicit MyClass(int var);
  ~MyClass() {}

  void SomeFunction();
  void SomeFunctionThatDoesNothing() {
  }

  void set_some_var(int var) { some_var_ = var; }
  int some_var() const { return some_var_; }

 private:
  bool SomeInternalFunction();

  int some_var_;
  int some_other_var_;
};
</pre>

                <p>Things to note:</p>

                <ul>
                    <li>
                        Any base class name should be on the same line as
                        the subclass name, subject to the 80-column limit.
                    </li>

                    <li>
                        The
                        <code>public:</code>,
                        <code>protected:</code>,
                        and
                        <code>private:</code> keywords should be indented
                        one space.
                    </li>

                    <li>
                        Except for the first instance, these keywords
                        should be preceded by a blank line. This rule is
                        optional in small classes.
                    </li>

                    <li>
                        Do not leave a blank line after these
                        keywords.
                    </li>

                    <li>
                        The
                        <code>public</code> section should be first,
                        followed by the
                        <code>protected</code> and finally the
                        <code>private</code> section.
                    </li>

                    <li>
                        See
                        <a href="#Declaration_Order">
                            Declaration
                            Order
                        </a> for rules on ordering declarations within
                        each of these sections.
                    </li>
                </ul>

            </div>

            <h3 id="Constructor_Initializer_Lists">Constructor Initializer Lists</h3>

            <div class="summary">
                <p>
                    Constructor initializer lists can be all on one line or
                    with subsequent lines indented four spaces.
                </p>
            </div>

            <div class="stylebody">

                <p>The acceptable formats for initializer lists are:</p>

<pre>// When everything fits on one line:
MyClass::MyClass(int var) : some_var_(var) {
  DoSomething();
}

// If the signature and initializer list are not all on one line,
// you must wrap before the colon and indent 4 spaces:
MyClass::MyClass(int var)
    : some_var_(var), some_other_var_(var + 1) {
  DoSomething();
}

// When the list spans multiple lines, put each member on its own line
// and align them:
MyClass::MyClass(int var)
    : some_var_(var),             // 4 space indent
      some_other_var_(var + 1) {  // lined up
  DoSomething();
}

// As with any other code block, the close curly can be on the same
// line as the open curly, if it fits.
MyClass::MyClass(int var)
    : some_var_(var) {}
</pre>

            </div>

            <h3 id="Namespace_Formatting">Namespace Formatting</h3>

            <div class="summary">
                <p>The contents of namespaces are not indented.</p>
            </div>

            <div class="stylebody">

                <p>
                    <a href="#Namespaces">Namespaces</a> do not add an
                    extra level of indentation. For example, use:
                </p>

<pre>namespace {

void foo() {  // Correct.  No extra indentation within namespace.
  ...
}

}  // namespace
</pre>

                <p>Do not indent within a namespace:</p>

<pre class="badcode">namespace {

  // Wrong.  Indented when it should not be.
  void foo() {
    ...
  }

}  // namespace
</pre>

                <p>
                    When declaring nested namespaces, put each namespace
                    on its own line.
                </p>

<pre>namespace foo {
namespace bar {
</pre>

            </div>

            <h3 id="Horizontal_Whitespace">Horizontal Whitespace</h3>

            <div class="summary">
                <p>
                    Use of horizontal whitespace depends on location. Never put
                    trailing whitespace at the end of a line.
                </p>
            </div>

            <div class="stylebody">

                <h4 class="stylepoint_subsection">General</h4>

<pre>void f(bool b) {  // Open braces should always have a space before them.
  ...
int i = 0;  // Semicolons usually have no space before them.
// Spaces inside braces for braced-init-list are optional.  If you use them,
// put them on both sides!
int x[] = { 0 };
int x[] = {0};

// Spaces around the colon in inheritance and initializer lists.
class Foo : public Bar {
 public:
  // For inline function implementations, put spaces between the braces
  // and the implementation itself.
  Foo(int b) : Bar(), baz_(b) {}  // No spaces inside empty braces.
  void Reset() { baz_ = 0; }  // Spaces separating braces from implementation.
  ...
</pre>

                <p>
                    Adding trailing whitespace can cause extra work for
                    others editing the same file, when they merge, as can
                    removing existing trailing whitespace. So: Don't
                    introduce trailing whitespace. Remove it if you're
                    already changing that line, or do it in a separate
                    clean-up
                    operation (preferably when no-one
                    else is working on the file).
                </p>

                <h4 class="stylepoint_subsection">Loops and Conditionals</h4>

<pre>if (b) {          // Space after the keyword in conditions and loops.
} else {          // Spaces around else.
}
while (test) {}   // There is usually no space inside parentheses.
switch (i) {
for (int i = 0; i &lt; 5; ++i) {
// Loops and conditions may have spaces inside parentheses, but this
// is rare.  Be consistent.
switch ( i ) {
if ( test ) {
for ( int i = 0; i &lt; 5; ++i ) {
// For loops always have a space after the semicolon.  They may have a space
// before the semicolon, but this is rare.
for ( ; i &lt; 5 ; ++i) {
  ...

// Range-based for loops always have a space before and after the colon.
for (auto x : counts) {
  ...
}
switch (i) {
  case 1:         // No space before colon in a switch case.
    ...
  case 2: break;  // Use a space after a colon if there's code after it.
</pre>

                <h4 class="stylepoint_subsection">Operators</h4>

<pre>// Assignment operators always have spaces around them.
x = 0;

// Other binary operators usually have spaces around them, but it's
// OK to remove spaces around factors.  Parentheses should have no
// internal padding.
v = w * x + y / z;
v = w*x + y/z;
v = w * (x + z);

// No spaces separating unary operators and their arguments.
x = -5;
++x;
if (x &amp;&amp; !y)
  ...
</pre>

                <h4 class="stylepoint_subsection">Templates and Casts</h4>

<pre>// No spaces inside the angle brackets (&lt; and &gt;), before
// &lt;, or between &gt;( in a cast
std::vector&lt;string&gt; x;
y = static_cast&lt;char*&gt;(x);

// Spaces between type and pointer are OK, but be consistent.
std::vector&lt;char *&gt; x;
</pre>

            </div>

            <h3 id="Vertical_Whitespace">Vertical Whitespace</h3>

            <div class="summary">
                <p>Minimize use of vertical whitespace.</p>
            </div>

            <div class="stylebody">

                <p>
                    This is more a principle than a rule: don't use blank
                    lines when you don't have to. In particular, don't put
                    more than one or two blank lines between functions,
                    resist starting functions with a blank line, don't end
                    functions with a blank line, and be discriminating with
                    your use of blank lines inside functions.
                </p>

                <p>
                    The basic principle is: The more code that fits on one
                    screen, the easier it is to follow and understand the
                    control flow of the program. Of course, readability can
                    suffer from code being too dense as well as too spread
                    out, so use your judgement. But in general, minimize use
                    of vertical whitespace.
                </p>

                <p>
                    Some rules of thumb to help when blank lines may be
                    useful:
                </p>

                <ul>
                    <li>
                        Blank lines at the beginning or end of a function
                        very rarely help readability.
                    </li>

                    <li>
                        Blank lines inside a chain of if-else blocks may
                        well help readability.
                    </li>
                </ul>

            </div>

            <h2 id="Exceptions_to_the_Rules">Exceptions to the Rules</h2>

            <p>
                The coding conventions described above are mandatory.
                However, like all good rules, these sometimes have exceptions,
                which we discuss here.
            </p>



            <div>
                <h3 id="Existing_Non-conformant_Code">Existing Non-conformant Code</h3>

                <div class="summary">
                    <p>
                        You may diverge from the rules when dealing with code that
                        does not conform to this style guide.
                    </p>
                </div>

                <div class="stylebody">

                    <p>
                        If you find yourself modifying code that was written
                        to specifications other than those presented by this
                        guide, you may have to diverge from these rules in order
                        to stay consistent with the local conventions in that
                        code. If you are in doubt about how to do this, ask the
                        original author or the person currently responsible for
                        the code. Remember that
                        <em>consistency</em> includes
                        local consistency, too.
                    </p>

                </div>
            </div>



            <h3 id="Windows_Code">Windows Code</h3>

            <div class="summary">
                <p>
                    Windows
                    programmers have developed their own set of coding
                    conventions, mainly derived from the conventions in Windows
                    headers and other Microsoft code. We want to make it easy
                    for anyone to understand your code, so we have a single set
                    of guidelines for everyone writing C++ on any platform.
                </p>
            </div>

            <div class="stylebody">
                <p>
                    It is worth reiterating a few of the guidelines that
                    you might forget if you are used to the prevalent Windows
                    style:
                </p>

                <ul>
                    <li>
                        Do not use Hungarian notation (for example, naming
                        an integer
                        <code>iNum</code>). Use the Google naming
                        conventions, including the
                        <code>.cc</code> extension
                        for source files.
                    </li>

                    <li>
                        Windows defines many of its own synonyms for
                        primitive types, such as
                        <code>DWORD</code>,
                        <code>HANDLE</code>, etc. It is perfectly acceptable,
                        and encouraged, that you use these types when calling
                        Windows API functions. Even so, keep as close as you
                        can to the underlying C++ types. For example, use
                        <code>const TCHAR *</code> instead of
                        <code>LPCTSTR</code>.
                    </li>

                    <li>
                        When compiling with Microsoft Visual C++, set the
                        compiler to warning level 3 or higher, and treat all
                        warnings as errors.
                    </li>

                    <li>
                        Do not use
                        <code>#pragma once</code>; instead use
                        the standard Google include guards. The path in the
                        include guards should be relative to the top of your
                        project tree.
                    </li>

                    <li>
                        In fact, do not use any nonstandard extensions,
                        like
                        <code>#pragma</code> and
                        <code>__declspec</code>,
                        unless you absolutely must. Using
                        <code>__declspec(dllimport)</code> and
                        <code>__declspec(dllexport)</code> is allowed; however,
                        you must use them through macros such as
                        <code>DLLIMPORT</code> and
                        <code>DLLEXPORT</code>, so
                        that someone can easily disable the extensions if they
                        share the code.
                    </li>
                </ul>

                <p>
                    However, there are just a few rules that we
                    occasionally need to break on Windows:
                </p>

                <ul>
                    <li>
                        Normally we
                        <a href="#Multiple_Inheritance">
                            forbid
                            the use of multiple implementation inheritance
                        </a>;
                        however, it is required when using COM and some ATL/WTL
                        classes. You may use multiple implementation
                        inheritance to implement COM or ATL/WTL classes and
                        interfaces.
                    </li>

                    <li>
                        Although you should not use exceptions in your own
                        code, they are used extensively in the ATL and some
                        STLs, including the one that comes with Visual C++.
                        When using the ATL, you should define
                        <code>_ATL_NO_EXCEPTIONS</code> to disable exceptions.
                        You should investigate whether you can also disable
                        exceptions in your STL, but if not, it is OK to turn on
                        exceptions in the compiler. (Note that this is only to
                        get the STL to compile. You should still not write
                        exception handling code yourself.)
                    </li>

                    <li>
                        The usual way of working with precompiled headers
                        is to include a header file at the top of each source
                        file, typically with a name like
                        <code>StdAfx.h</code>
                        or
                        <code>precompile.h</code>. To make your code easier
                        to share with other projects, avoid including this file
                        explicitly (except in
                        <code>precompile.cc</code>), and
                        use the
                        <code>/FI</code> compiler option to include the
                        file automatically.
                    </li>

                    <li>
                        Resource headers, which are usually named
                        <code>resource.h</code> and contain only macros, do not
                        need to conform to these style guidelines.
                    </li>
                </ul>

            </div>

            <h2 class="ignoreLink">Parting Words</h2>

            <p>
                Use common sense and
                <em>BE CONSISTENT</em>.
            </p>

            <p>
                If you are editing code, take a few minutes to look at the
                code around you and determine its style. If they use spaces
                around their
                <code>if</code> clauses, you should, too. If their
                comments have little boxes of stars around them, make your
                comments have little boxes of stars around them too.
            </p>

            <p>
                The point of having style guidelines is to have a common
                vocabulary of coding so people can concentrate on what you are
                saying, rather than on how you are saying it. We present global
                style rules here so people know the vocabulary. But local style
                is also important. If code you add to a file looks drastically
                different from the existing code around it, the discontinuity
                throws readers out of their rhythm when they go to read it. Try
                to avoid this.
            </p>



            <p>
                OK, enough writing about writing code; the code itself is much
                more interesting. Have fun!
            </p>

            <hr>

        </div>
    </div>
</body>
</html>
